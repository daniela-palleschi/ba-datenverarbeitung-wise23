[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Angewandte Datenverarbeitung und Visualisierung",
    "section": "",
    "text": "Kursübersicht\nDies ist die Webseite der Lehrveranstaltung “Angewandte Datenverarbeitung und Visualisierung: R für Linguistik und Sozialwissenschaften” an der Humboldt-Universität zu Berlin, Institut der deutschen Sprache und Linguistik für das Sommersemester 2024. Wenn Sie für den Kurs eingeschrieben sind, finden Sie alle relevanten Materialien auf dem Kurs Moodle hier (Moodle-Schlüssel wird in der Vorlesung bereitgestellt).\nJedes Kapitel entspricht einer Vorlesung von einer Woche. Vorerst werden die Materialien auf dieser Website im Bullet-Point-Format erscheinen und genau denselben Inhalt wie die Kursfolien enthalten. Ich plane, die Aufzählungspunkte später in Prosa umzuwandeln und die einzelnen Themen zu vertiefen.",
    "crumbs": [
      "Kursübersicht",
      "Kursübersicht"
    ]
  },
  {
    "objectID": "index.html#kursbeschreibung-auf-agnes",
    "href": "index.html#kursbeschreibung-auf-agnes",
    "title": "Angewandte Datenverarbeitung und Visualisierung",
    "section": "Kursbeschreibung auf AGNES",
    "text": "Kursbeschreibung auf AGNES\n\nDies ist ein Einführungskurs in das Denken, Arbeiten und Kommunizieren mit / über sprachliche Daten. Der Kurs fokussiert sich auf praktische Anwendungen und die Vermittlung übertragbarer Fähigkeiten. In RStudio machen sich die Teilnehmenden sich mit der Programmiersprache R vertraut und entwickeln Fähigkeiten zur Erstellung und Vermittlung zusammenfassender Statistiken für den akademischen und beruflichen Kontext. Die Teilnehmenden lernen, Rohdaten zu laden und zu manipulieren, Tabellen mit deskriptiven Statistiken zu erstellen und die Daten angemessen visuell darzustellen. Am Ende des Kurses werden die Teilnehmenden ein besseres Verständnis dafür haben, wie man mit Daten umgeht und die Fähigkeiten besitzen, Ergebnisse klar zu kommunizieren. Studierende, die keinen eigenen Laptop zum Unterricht mitbringen können, setzen sich bitte so früh wie möglich mit der Dozentin in Verbindung, damit ein alternativer Laptop organisiert werden kann. Der Kurs wird auf Deutsch gehalten.",
    "crumbs": [
      "Kursübersicht",
      "Kursübersicht"
    ]
  },
  {
    "objectID": "index.html#ziele-des-kurses",
    "href": "index.html#ziele-des-kurses",
    "title": "Angewandte Datenverarbeitung und Visualisierung",
    "section": "Ziele des Kurses",
    "text": "Ziele des Kurses\nDas Hauptziel dieses Kurses ist es, die Kenntnisse und Fähigkeiten zu entwickeln, die für die Durchführung einer “Explorativen Datenanalyse (EDA)” erforderlich sind. EDA ist kein formaler Prozess mit spezifischen Regeln, sondern vielmehr “a state of mind” (Wickham et al., 2023, Kapitel 11). Das Wissen, das für die Durchführung einer EDA erforderlich ist, besteht einfach darin, die Daten zu verstehen und ihre Struktur zu erforschen, um ein Verständnis für ihre Verteilung und Muster zu bekommen. Die für die Durchführung einer EDA erforderlichen Fähigkeiten sind spezifisch für die zur Durchführung der EDA verwendete Sprache, in unserem Fall R.",
    "crumbs": [
      "Kursübersicht",
      "Kursübersicht"
    ]
  },
  {
    "objectID": "index.html#ressourcen",
    "href": "index.html#ressourcen",
    "title": "Angewandte Datenverarbeitung und Visualisierung",
    "section": "Ressourcen",
    "text": "Ressourcen\nDie meisten unserer Materialien basieren auf dem Buch “R for Data Science” von Hadley Wickham (2. Auflage), das Sie hier vollständig online einsehen können. Wo es möglich war, habe ich die in diesem Buch verwendeten Daten durch linguistische Datensätze ersetzt, damit Sie sich ein Bild davon machen können, wie Linguisten R verwenden könnten.\nEinige andere Ressourcen, die wir von Zeit zu Zeit verwenden werden oder die Sie vielleicht selbst erkunden möchten, sind das E-book Data visualisation using R, for researchers who don’t use R (Nordmann et al., 2022) und das Lehrbuch Statistics for Linguists: An Introduction Using R by Bodo Winter [Winter (2019); PDF erhältlich über das Grimm Zentrum].\n\n\n\n\n\n\nNordmann, E., McAleer, P., Toivo, W., Paterson, H., & DeBruine, L. M. (2022). Data Visualization Using R for Researchers Who Do Not Use R. Advances in Methods and Practices in Psychological Science, 5(2), 251524592210746. https://doi.org/10.1177/25152459221074654\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. In Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547",
    "crumbs": [
      "Kursübersicht",
      "Kursübersicht"
    ]
  },
  {
    "objectID": "setup/setup.html",
    "href": "setup/setup.html",
    "title": "Erforderliche Software",
    "section": "",
    "text": "R und RStudio\nUm an diesem Kurs teilnehmen zu können, müssen Sie R und RStudio installieren.\nR ist eine statistische Programmiersprache, die für statistische Berechnungen und grafische Darstellungen verwendet wird. Am häufigsten wird sie zur Analyse und Visualisierung von Daten verwendet, beides werden wir in diesem Semester tun. RStudio ist eine IDE (integrierte Entwicklungsumgebung) für R und andere Sprachen. RStudio macht die Analyse und Visualisierung von Daten in R viel einfacher (glauben Sie mir, als ich mit R anfing, gab es kein RStudio!).\nSie müssen R herunterladen, bevor Sie RStudio herunterladen können.",
    "crumbs": [
      "Kursübersicht",
      "Erforderliche Software"
    ]
  },
  {
    "objectID": "setup/setup.html#sec-packages",
    "href": "setup/setup.html#sec-packages",
    "title": "Erforderliche Software",
    "section": "Pakete",
    "text": "Pakete\nR-Pakete, die im Comprehensive R Archive Network, allgemein bekannt als CRAN-Repository, verfügbar sind, können einfach mit dem Befehl install.packages(\"packageName\") installiert werden. Einige Pakete, die wir brauchen werden, sind:\n\nhere Paket (Müller, 2020)\ntidyverse-Paketfamilie (Wickham et al., 2019)\n\nenthält automatisch Pakete, die wir brauchen, wie dplyr und ggplot2\n\nlanguageR-Paket (Baayen & Shafaei-Bajestan, 2019)\n\nUm mehrere Pakete auf einmal herunterzuladen, verwenden Sie die ‘concatenate’-Funktion in r (c()) innerhalb von install.packages():\n\ninstall.packages(c(\"here\", \n                   \"tidyverse\",\n                   \"pacman\"))",
    "crumbs": [
      "Kursübersicht",
      "Erforderliche Software"
    ]
  },
  {
    "objectID": "setup/setup.html#rstudio-globale-optionen-optional",
    "href": "setup/setup.html#rstudio-globale-optionen-optional",
    "title": "Erforderliche Software",
    "section": "RStudio Globale Optionen (optional)",
    "text": "RStudio Globale Optionen (optional)\nHier sind meine bevorzugten globalen Optionen (RStudio &gt; Werkzeuge &gt; Globale Optionen). Ich empfehle dringend, die Einstellungen für “Arbeitsbereich” und “R-Sitzungen” zu befolgen, um die Reproduzierbarkeit zu gewährleisten. Mit den anderen Einstellungen können Sie herumspielen, um herauszufinden, was Ihnen gefällt.\n\nAllgemein &gt; Grundeinstellungen\n\nArbeitsbereich (für reproduzierbare Arbeitsabläufe!!!)\n\nDeaktivieren Sie das Kontrollkästchen “.RData beim Starten in Arbeitsbereich wiederherstellen”.\nArbeitsbereich beim Beenden in .RData speichern: Niemals\n\nR-Sitzungen\n\nDeaktivieren Sie das Kontrollkästchen “Zuvor geöffnete Quelldokumente beim Start wiederherstellen”.\n\n\nCode &gt; Anzeige\n\nAllgemein\n\nLeerzeichen anzeigen\nScrollen über das Ende des Dokuments hinaus zulassen\nAusgewählte Zeile hervorheben\n\n\nErscheinungsbild\n\nEditor-Thema: Kobalt",
    "crumbs": [
      "Kursübersicht",
      "Erforderliche Software"
    ]
  },
  {
    "objectID": "session_info.html",
    "href": "session_info.html",
    "title": "Sitzungsinformationen",
    "section": "",
    "text": "GitHub repository\ngit2r::repository()\n\nLocal:    main /Users/danielapalleschi/Documents/IdSL/Webbooks/r4ling\nRemote:   main @ origin (git@github.com:daniela-palleschi/r4ling.git)\nHead:     [dc7b037] 2024-06-14: fix incorrect cross-refs",
    "crumbs": [
      "Kursübersicht",
      "Sitzungsinformationen"
    ]
  },
  {
    "objectID": "session_info.html#session-info",
    "href": "session_info.html#session-info",
    "title": "Sitzungsinformationen",
    "section": "Session Info",
    "text": "Session Info\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.4.0    fastmap_1.1.1     cli_3.6.2        \n [5] htmltools_0.5.8.1 tools_4.4.0       rstudioapi_0.16.0 yaml_2.3.8       \n [9] rmarkdown_2.26    knitr_1.46        git2r_0.33.0      jsonlite_1.8.8   \n[13] xfun_0.43         digest_0.6.35     rlang_1.1.3       renv_1.0.7       \n[17] evaluate_0.23",
    "crumbs": [
      "Kursübersicht",
      "Sitzungsinformationen"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html",
    "href": "mats/01-intro_r.html",
    "title": "1  Einführung in R und RStudio",
    "section": "",
    "text": "Heutige Ziele",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#heutige-ziele",
    "href": "mats/01-intro_r.html#heutige-ziele",
    "title": "1  Einführung in R und RStudio",
    "section": "",
    "text": "R und RStudio installieren\nin der Lage sein, Zusatzpakete zu installieren\nin der Lage sein, Hilfe für Pakete und Funktionen zu erhalten\nin der Lage sein, Objekte in der Konsole zu erstellen",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#weitere-lektüre",
    "href": "mats/01-intro_r.html#weitere-lektüre",
    "title": "1  Einführung in R und RStudio",
    "section": "Weitere Lektüre",
    "text": "Weitere Lektüre\n\nDieser Vortrag basiert lose auf Kapitel 1 - Introduction und Kapitel 3 - Workflow Basics von Wickham et al. (2023)\ndieser Kurs folgt mehr oder weniger diesem Buch\nwo möglich, ersetze ich die Datensätze im Buch durch linguistische Datenbeispiele",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#vorbereitung",
    "href": "mats/01-intro_r.html#vorbereitung",
    "title": "1  Einführung in R und RStudio",
    "section": "1.1 Vorbereitung",
    "text": "1.1 Vorbereitung\n\nhoffentlich haben Sie R und RStudio bereits installiert/aktualisiert\n\nfalls nicht: Versuchen Sie es mit Posit Cloud für heute posit.cloud\n\nGehen Sie zum Kurs GitHub und laden Sie eine ZIP-Datei des Repositorys herunter\n\ngroße grüne Schaltfläche ‘&lt;&gt; Code’ &gt; ZIP herunterladen\n\n\n\n\n\n\n\nDownload GitHub repositiory",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#rprojekt",
    "href": "mats/01-intro_r.html#rprojekt",
    "title": "1  Einführung in R und RStudio",
    "section": "1.2 RProjekt",
    "text": "1.2 RProjekt\n\nSuchen Sie die ZIP-Datei, die Sie soeben heruntergeladen haben, auf Ihrem Computer und dekomprimieren Sie sie.\nÖffnen Sie den Ordner und navigieren Sie zu r4ling_student.Rproj, doppelklicken Sie darauf\nSie sollten nun RStudio sehen, wie in Abbildung 1.1\nJetzt können wir an unserem ersten Skript arbeiten\n\n\n\n\n\n\n\n\n\nAbbildung 1.1: Student RProject\n\n\n\n\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nWichtig!!\nVerschieben oder benennen Sie den Ordner data/ nicht um! Sie müssen denselben Dateipfad zu den Datensätzen haben, um meinen Code in den nächsten Wochen nahtlos verwenden zu können.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#r-in-rstudio",
    "href": "mats/01-intro_r.html#r-in-rstudio",
    "title": "1  Einführung in R und RStudio",
    "section": "1.3 R in RStudio",
    "text": "1.3 R in RStudio\n\nÖffnen Sie RStudio immer durch einen Doppelklick auf r4ling_student.Rproj (für diesen Kurs)\nklicken Sie auf File &gt; New File &gt; R Script\n\nsehen Sie nun vier Quadrate (statt 3 in Abbildung 1.1):\n\n\nTexteditor - oben Links - wo wir unseren Code schreiben werden\nR-Konsole (EN: Console) - unten links - wo wir die Ausgabe unseres Codes und Warn-/Fehlermeldungen sehen werden\nArbeitsumgebung (EN: Environment) - oben rechts - wo unsere Daten und Objekte nach dem Laden gespeichert werden\nDateien und Grafikausgabe - unten links - wo wir unsere Dateien und die von uns erstellten Grafiken sehen oder Hilfe bekommen können\n\n\n\n1.3.1 Erweitungspakete\n\nR hat eine Reihe von nativen Funktionen und Datensätzen, auf die wir zugreifen können\n\nähnlich wie die Standard-Apps, die auf Ihrem Handy vorinstalliert sind\n\nJeder kann Zusatzpakete für R erstellen, z.B.,\n\nfür Datenvisualisierung\nDatenverarbeitung\n\nDies ist ähnlich wie bei Handy-Apps, die von jedem erstellt und auf Ihr Gerät heruntergeladen werden können\n\naber Pakete sind immer kostenlos\n\nEs gibt 2 Schritte, um ein Paket zu verwenden:\n\nInstallieren des Pakets (einmalig) mit install.packages(\"Paket\")\nLaden Sie das Paket (zu Beginn jeder Sitzung) library(Paket)\n\n\n\n1.3.1.1 Paket-Installation\n\nerfolgt mit der Funktion install.packages()\n\nSie machen dies nur einmal (wie das Herunterladen einer App)\n\ndas Paket tidyverse ist sehr hilfreich für Datenverarbeitung und Visualisierung\n\nInstallieren wir es jetzt\n\n\n\n\nPaket-Installation\n\ninstallieren Sie die Pakete tidyverse und beepr\n\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"beepr\")\n\n\n\n\n\n\n\nPakete in der Konsole installieren\n\n\n\nInstallieren Sie Pakete immer über die Konsole, nicht über ein Skript!\nSie können auch die Registerkarte “Pakete” in der unteren rechten Box verwenden (Pakete &gt; Installieren)\n\n\n\n\n1.3.1.2 tinytex\n\nwir brauchen auch LaTeX und tinytex (Xie, 2023), um PDF-Dokumente zu erstellen\nführen Sie diesen Code aus, um tinytex zu installieren\n\n\n## run this in the console\ninstall.packages(\"tinytex\")\ntinytex::install_tinytex()\n\n\nSie müssen auch LaTeX installieren, wenn Sie es noch nicht haben: https://www.latex-project.org/get/\n\n\n\n\n1.3.2 Laden eines Pakets\n\ndie Funktion library() lädt ein Paket in Ihre Umgebung\ndies muss zu Beginn jeder Sitzung geschehen, um auf das entsprechende Paket zugreifen zu können\n\n\nlibrary(beepr)\n\n\n1.3.2.1 Verwendung einer Funktion\n\nSobald Sie ein Paket geladen haben, können Sie auf dessen Funktionen zugreifen\nZum Beispiel hat das Paket beepr eine Funktion beep(), probieren wir sie aus\n\n\n\n\nin der Konsole laufen\n\nbeep()\n\n\n\n\n1.3.2.2 Funktionsargumente\n\nArgumente enthalten optionale Informationen, die an eine Funktion übergeben werden\n\nDie Funktion beep() hat das Argument sound, das einen numerischen Wert von 1:11 annimmt.\nVersuchen Sie, den folgenden Code mit anderen Zahlen auszuführen, was passiert?\n\n\n\n\n\nin der Konsole laufen\n\nbeep(sound = 5)\n\n\n\n\nFunktionsargumente\n\n\n\n\n\n\n?help\n\n\n\nSie können mehr über eine Funktion (einschließlich ihrer verfügbaren Argumente) herausfinden, indem Sie ihren Namen nach einem Fragezeichen in die Konsole schreiben (z.B. ?beep). Versuchen Sie, ?beep auszuführen. Kannst du auf der Hilfeseite herausfinden, was du anstelle von sound = 5 schreiben kannst, um denselben Ton zu erzeugen?\n\n\n\n\n\n1.3.3 Aufgabe: Paket-Installation\n\n\n\n\n\n\nAufgabe\n\n\n\nWir brauchen auch das here-Paket. Installieren Sie dieses.\nNachdem Sie das Paket installiert haben, führen Sie den Befehl here() aus. Was geschieht?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#reproduzierbarkeit",
    "href": "mats/01-intro_r.html#reproduzierbarkeit",
    "title": "1  Einführung in R und RStudio",
    "section": "1.4 Reproduzierbarkeit",
    "text": "1.4 Reproduzierbarkeit\n\nin diesem Kurs werden wir lernen, wie man reproduzierbare Berichte erstellt\n\nDas bedeutet, dass unser Code später noch einmal ausgeführt werden kann und immer noch die gleichen Ergebnisse liefert\n\nwenn Ihre Arbeit reproduzierbar ist, können andere Leute (und Sie selbst) Ihre Arbeit verstehen und überprüfen\n\nFür Kursaufgaben werden Sie Berichte sowie den Quellcode einreichen, die ich auf meinem Rechner ausführen können sollte\n\n\n\n1.4.1 RStudio-Einstellungen\n\nwir wollen immer mit einem freien Arbeitsbereich in RStudio beginnen, um die Reproduzierbarkeit zu gewährleisten\n\nWir wollen auch niemals unseren Arbeitsbereich für später speichern\nwir wollen nur unseren Code (und die Ausgabeberichte) speichern\n\nGehen Sie zu Tools &gt; Global Options\n\nDeaktivieren Sie das Kontrollkästchen Restore .RData into workspace at startup\nSetzen Sie Save workspace to .RData on exit: to Never\n\n\n\n\nRStudio-Einstellungen\n\n\nRStudio: Tools &gt; Global Options:\n\nRestore .RData into workspace at startup\n\nnein\n\nSave workspace to .RData on exit:\n\nNever\n\n\n\n\n\n\n\n\n\nIhre ‘Global Options’ sollten wie folgt aussehen\n\n\n\n\n\n\nRStudio-Einstellungen\n\nKlicken Sie auf Appearance (linke Spalte)\n\nÖffnen Sie die Optionen “Editor Theme” und wählen Sie ein Farbschema, das Ihnen gefällt\nSie können auch die Schriftart/Schriftgröße ändern, wenn Sie dies wünschen\n\n\n\n\n1.4.2 Aufgabe: neues R-Skript\n\n\n\n\n\n\nAufgabe\n\n\n\n\nin RStudio: File &gt; New File &gt; R Script\n\nwenn sich oben links ein neues Fenster öffnet: “Datei &gt; Speichern unter…”.\n\nspeichern Sie es in Ihrem ‘notizen’ Ordner\n\nschreiben Sie oben in das Skript: ## Angewandte Datenverarbeitung und Visualisierung - Woche 1 (17.04.2023)\n\n\n\n\n\n\n\n\n\nIhre Skript (oben links) sollten so aussehen",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#rechnen-in-r",
    "href": "mats/01-intro_r.html#rechnen-in-r",
    "title": "1  Einführung in R und RStudio",
    "section": "1.5 Rechnen in R",
    "text": "1.5 Rechnen in R\n\nkönnen wir Berechnungen in R durchführen\nwir können addieren (+), subtrahieren (-), multiplizieren (*) und dividieren (/)\n\n\n1.5.1 Aufgabe: Berechnungen\n\n\n\n\n\n\nAufgabe\n\n\n\n\nVersuchen Sie, die folgenden Berechnungen in der Konsole auszuführen:\n\n\n# Addition\n16+32\n\n[1] 48\n\n\n\n# Multiplikation\n16*32\n\n[1] 512\n\n\n\n# Subtraktion\n16-32\n\n[1] -16\n\n\n\n# Division\n16/32\n\n[1] 0.5\n\n\n\nschreiben Sie diese Berechnungen in Ihr Skript, und drücken Sie Cmd/Strg-Enter, um sie auszuführen\n\n\nWas passiert?\n\n\n\n\n\n1.5.2 Kommentare\n\nSie haben vielleicht bemerkt, dass in meinen Code-Blöcken z. B. # Subtraktion über dem Code stand\nR ignoriert jeden Text nach # (plus ein Leerzeichen )\nalso können wir Kommentare nach # schreiben\n\n\n# Kommentar zum folgenden Code\n16-32\n\n[1] -16\n\n\n\nWir können auch eine Abschnittsüberschrift erstellen, um unsere R-Skripte zu strukturieren, indem wir vier # nach einem Titel hinzufügen\nDie Struktur des Skripts kann dann durch Klicken auf die Schaltfläche “Gliederung” oberhalb des Skriptfensters angezeigt werden\n\n\n# Rechnen mit R ####\n\n# Subtraction\n16-32\n\n[1] -16\n\n\n\n\n1.5.3 Objekte\n\nwir können auch Werte als Objekte/Variablen speichern, die in der Arbeitsumgebung gespeichert sind\n\n\nx &lt;- 16\ny &lt;- 32\n\n\n\n\n\n\n\nAssignment operator\n\n\n\nDas Symbol &lt;- ist ein sogenannter assignment operator. Es erstellt ein neues Objekt in Ihrer Arbeitsumgebung oder überschreibt ein vorhandenes Objekt mit demselben Namen. Es ist wie ein Pfeil, der sagt: “Nimm das, was rechts steht, und speichere es als den Objektnamen auf der linken Seite”.\n\n\n\n\n1.5.4 Rechnen mit Funktionen\n\nes gibt auch eingebaute Funktionen für komplexere Berechnungen\nz.B., mean() (DE: Durchschnitt), sum() (DE: Summe)\nwas passiert, wenn wir folgendes ausführen?\n\n\nsum(6,10)\n\n[1] 16\n\n\n\n6+10\n\n[1] 16\n\n\n\nmean(6,10)\n\n[1] 6\n\n\n\n(6+10)/2\n\n[1] 8\n\n\n\n\nRechnen mit Funktionen\n\ndie Funktion mean() nimmt nur ein Argument an; alles andere wird ignoriert\n\ndas Komma in 6,10 listet 2 Argumente auf, also wird alles nach dem Komma ignoriert\n\nwenn wir mehr als ein Objekt in ein Argument einschließen wollen, müssen wir die “concatenate”-Funktion c() verwenden\n\n“concatenate” bedeutet zusammenfügen oder kombinieren\n\n\n\nmean(c(6,10))\n\n[1] 8\n\n\n\n\nRechnen mit Funktionen\n\nSie können auch benannte Objekte (d.h. die in Ihrer Arbeitsumgebung) verwenden, die einen numerischen Wert haben\n\n\n\n\n\n\n\nAufgabe: Rechnen mit Funktionen\n\n\n\n\nVersuchen Sie, die Funktion mean() mit Ihren gespeicherten Variablen (x und y) als “verkettete” Argumente auszuführen\nMachen Sie dasselbe mit der Funktion sum(). Was passiert, wenn Sie c() nicht verwenden?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#vektoren",
    "href": "mats/01-intro_r.html#vektoren",
    "title": "1  Einführung in R und RStudio",
    "section": "1.6 Vektoren",
    "text": "1.6 Vektoren\n\nVektoren sind eine Liste von Elementen desselben Typs (z. B. numerisch, Zeichenkette)\nwir können einen Vektor mit der Verkettungsfunktion c() erstellen\nDer folgende Code speichert in einem Objekt namens ‘vec’ einen Vektor aus mehreren Zahlen\n\n\n# einen Vektor erstellen\nvec &lt;- c(171, 164, 186, 191)\n\n\nder folgende Code ruft das Objekt auf, das wir als ‘vec’ gespeichert haben, und gibt seinen Inhalt aus\n\n\n# print vec\nvec\n\n[1] 171 164 186 191\n\n\n\n1.6.1 Arithmetic mit Vektoren\n\nGrundlegende Arithmetik auf Vektoren wird auf jedes Element angewendet\n\n\n# add 5 to vec\nvec + 5\n\n[1] 176 169 191 196\n\n\n\nkönnen wir auch Funktionen auf Vektoren anwenden\n\n\n# Summe von vec\nsum(vec)\n\n[1] 712\n\n\n\n# Mittelwert von vec\nmean(vec)\n\n[1] 178\n\n\n\n# Quadratwurzel aus vec\nsqrt(vec)\n\n[1] 13.07670 12.80625 13.63818 13.82027\n\n\n\n\n1.6.2 Ausgabe: Vektoren\n\n\n\n\n\n\nAusgabe\n\n\n\n\nErstelle einen Vektor namens vec1, der die Werte 12, 183, 56, 25 und 18 enthält\nErstellen Sie einen Vektor namens vec2, der die Werte 8, 5, 1, 6 und 8 enthält\nCreate a vector called vec3 that contains the values 28, 54, 10, 13, 2, and 81\nFinde die Summe von vec1.\nFinde die Summe von vec1 plus vec2. Wie unterscheidet sich das Ergebnis von dem, das Sie für vec1 allein erhalten haben?\nWas passiert, wenn du versuchst, die Summe von vec1 und vec3 zu finden?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#endergebnis",
    "href": "mats/01-intro_r.html#endergebnis",
    "title": "1  Einführung in R und RStudio",
    "section": "1.7 Endergebnis",
    "text": "1.7 Endergebnis\n\nSpeichern Sie Ihr R-Skript (File &gt; Save, oder Cmd/Strg-S)\nSie sollten nun einen RProject-Ordner für diesen Kurs, der Folgendes enthält:\n\nr4ling_student.RProj`\neinen Ordner namens Daten\neinen Ordner namens notes, der Folgendes enthält + eine .R-Datei mit der heutigen Arbeit\n\nSie wissen jetzt, wie man\n\neinfache Berechnungen in R durchführen\nObjekte in Ihrer Arbeitsumgebung zu speichern\neinfache mathematische Berechnungen mit Ihren gespeicherten Objekten durchführen",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#session-info",
    "href": "mats/01-intro_r.html#session-info",
    "title": "1  Einführung in R und RStudio",
    "section": "1.8 Session Info",
    "text": "1.8 Session Info\n\nUm die Reproduzierbarkeit zu verbessern, ist es nützlich, die Version von R, RStudio und die verwendeten Pakete zu verfolgen\n\nZu diesem Zweck können Sie die folgenden Befehle ausführen:\n\n\n\n## R version\nR.version.string\n\n[1] \"R version 4.4.0 (2024-04-24)\"\n\n## R version name\nR.version$nickname\n\n[1] \"Puppy Cup\"\n\n\n\n## RStudio version\nRStudio.Version()$version\n## RStudio version name\nRStudio.Version()$release_name\n\n\n## alle Paketeversionen\nsessionInfo()",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/01-intro_r.html#nächste-woche",
    "href": "mats/01-intro_r.html#nächste-woche",
    "title": "1  Einführung in R und RStudio",
    "section": "1.9 Nächste Woche",
    "text": "1.9 Nächste Woche\nvor nächster Woche, stellen Sie bitte sicher, dass Sie:\n\nR und RStudio installiert/aktualisiert haben\ndie Pakete tidyverse und here installiert haben\nbitte stellen Sie sicher, dass Sie die Übungen des heutigen Kurses in Ihrem R-Skript durcharbeiten\n(optional) speichern Sie das Skript, und laden Sie es auf Moodle hoch, wenn Sie es auf Ihre 6 Skripte für die Teilnahme-LP anrechnen lassen möchten\n\n\nSession Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.3.0.386 (Cherry Blosson).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] beepr_1.3    magick_2.8.3\n\nloaded via a namespace (and not attached):\n [1] digest_0.6.35     fastmap_1.1.1     xfun_0.43         magrittr_2.0.3   \n [5] glue_1.7.0        stringr_1.5.1     audio_0.1-11      knitr_1.46       \n [9] htmltools_0.5.8.1 rmarkdown_2.26    lifecycle_1.0.4   cli_3.6.2        \n[13] renv_1.0.7        compiler_4.4.0    rprojroot_2.0.4   here_1.0.1       \n[17] rstudioapi_0.16.0 tools_4.4.0       evaluate_0.23     Rcpp_1.0.12      \n[21] yaml_2.3.8        rlang_1.1.3       jsonlite_1.8.8    htmlwidgets_1.6.4\n[25] stringi_1.8.3    \n\n\n\n\n\n\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).\n\n\nXie, Y. (2023). tinytex: Helper Functions to Install and Maintain TeX Live, and Compile LaTeX Documents. https://github.com/rstudio/tinytex",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html",
    "href": "mats/02-dataviz_1.html",
    "title": "2  Datenvisualiserung 1",
    "section": "",
    "text": "Wiederholung\nLetzte Woche haben wir…",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#wiederholung",
    "href": "mats/02-dataviz_1.html#wiederholung",
    "title": "2  Datenvisualiserung 1",
    "section": "",
    "text": "R und RStudio installiert\nunser erstes R-Skript erstellt\neinfache Arithmetik mit Objekten und Vektoren durchgeführt\n\n\nWiederholung\n\nx &lt;- c(1,2,3)\ny &lt;- sum(1,2,3)\n\n\n\nWas enthalten die Vektoren x und y?\nDas Objekt x enthält 1, 2, 3\nDas Objekt y enthält ` 6 ``",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#heutige-ziele",
    "href": "mats/02-dataviz_1.html#heutige-ziele",
    "title": "2  Datenvisualiserung 1",
    "section": "Heutige Ziele",
    "text": "Heutige Ziele\nHeute werden wir lernen…\n\nwas Datenframes sind\nden Unterschied zwischen kategorialen und kontinuierlichen Daten\nwie man Diagramme mit ggplot erstellt\ndie richtige Darstellung für unsere Daten auszuwählen\n\n\nEndgültiges Ziel\n\nUnser heutiges Ziel ist es, die Daten wie folgt zu visualisieren\n\nDas Diagramm zeigt die Verteilung (Anzahl) der Reaktionszeiten und der Muttersprache der Teilnehmer\n\n\n\n\n\n\n\n\n\n\n\n\n\nLust auf mehr?\n\nKapitel 2 (Datenvisualisierung) in Wickham et al. (2023), bis zum Abschnitt 2.4\nKapitel 3 (Datenvisualisierung) in Nordmann & DeBruine (2022)\n\n\n\nVorbereitung\nIn Ihrem RProject-Ordner…\n\nerstellen Sie einen neuen Ordner mit dem Namen moodle\n\nLaden Sie die Moodle-Materialien von heute herunter und speichern Sie sie dort\n\nErstellen Sie einen neuen Ordner in notes mit dem Namen 02-datenviz1\nöffne ein neues .R Skript\n\nspeichere es in dem neuen Ordner\n\n\n\n2.0.0.1 Pakete\n\nPakete laden (und installieren)\n\ntidyverse\nlanguageR\nggthemes\npatchwork\n\n\n\n## in the CONSOLE: install packages if needed\ninstall.packages(\"tidyverse\")\ninstall.packages(\"languageR\")\ninstall.packages(\"ggthemes\") ## for customising our plots\ninstall.packages(\"patchwork\") ## plot layouts\n\n\n## Pakete laden\nlibrary(tidyverse)\nlibrary(languageR)\nlibrary(ggthemes)\nlibrary(patchwork)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#datenrahmen",
    "href": "mats/02-dataviz_1.html#datenrahmen",
    "title": "2  Datenvisualiserung 1",
    "section": "2.1 Datenrahmen",
    "text": "2.1 Datenrahmen\n\nDatenrahmen sind eine Sammlung von Variablen, wobei\n\njede Variable eine Spalte ist\njede Zeile eine einzelne Beobachtung/ein einzelner Datenpunkt ist\njede Zelle in einer Zeile verknüpft ist\n\nDatenrahmen sind genau wie Tabellenkalkulationen, aber rechteckig\nVerschiedene Wörter für Datenrahmen:\n\nDatenrahmen\nDatensatz\nTibble (im tidyverse)\n\n\n\n2.1.1 Sprechen über Datensätze\n\neine Variable: eine Menge, Qualität oder Eigenschaft, die man messen kann\nein Wert: der Zustand einer Variablen, wenn man sie misst\neine Beobachtung: eine Reihe von Messungen, die unter ähnlichen Bedingungen durchgeführt werden\n\nenthält mehrere Werte, die jeweils mit einer Variablen verbunden sind\neine Beobachtung für eine einzelne Variable wird manchmal als Datenpunkt bezeichnet\n\nTabellendaten sind eine Reihe von Werten, die jeweils mit einer Variablen und einer Beobachtung verbunden sind\n\nTabellarische Daten sind “tidy”, wenn jeder Wert in einer eigenen Zelle, jede Variable in einer eigenen Spalte und jede Beobachtung in einer eigenen Zeile steht\n\n\n\n\n2.1.2 Kategoriale und kontinuierliche Variablen\n\nWie wir die Verteilung einer Variablen darstellen, hängt davon ab, welche Art von Daten sie repräsentiert: kategorisch oder numerisch\nEine Variable ist kategorisch, wenn sie eine kleine Menge von Werten annehmen kann, die sich in Gruppen zusammenfassen lassen\n\n\nB. alt/jung, klein/groß, grammatikalisch/ungrammatikalisch, L1/L2-Sprecher\n\n\neine Variable ist numerisch (d. h. quantitativ), wenn sie eine große Bandbreite an numerischen Werten annehmen kann\n\nund es sinnvoll wäre, zu addieren, zu subtrahieren, den Mittelwert zu berechnen usw.\nkann kontinuierlich sein (Dezimalpunkte sind sinnvoll, z. B. 1,5 cm)\noder diskret (Dezimalpunkte sind nicht sinnvoll, z. B. 1,5 Kinder sind nicht sinnvoll)\n\nwir erstellen verschiedene Diagramme, je nachdem, welche Art von Variablen wir visualisieren wollen",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#lexical-decision-task-ldt",
    "href": "mats/02-dataviz_1.html#lexical-decision-task-ldt",
    "title": "2  Datenvisualiserung 1",
    "section": "2.2 Lexical Decision Task (LDT)",
    "text": "2.2 Lexical Decision Task (LDT)\n\nunser erster Datensatz enthält Daten aus einer lexikalischen Entscheidungsaufgabe\nBei der LDT drücken die Teilnehmer eine Taste, um anzugeben, ob ein Wort ein echtes Wort oder ein Pseudowort ist.\n\n\n\n\n\n\n\n\n\n\n\n2.2.1 LDT-Variablen\n\nDie üblichen Variablen, die in einem Experiment zur lexikalischen Entscheidungsaufgabe erhoben werden, sind:\n\nReaktionszeit\nGenauigkeit (richtig/falsch)\nWortkategorie (z. B. real/pseudo, Nomen/Verb)\nWorthäufigkeit\n\nZusätzliche Variablen, die erhoben werden könnten, sind:\n\ndemografische Daten der Teilnehmer (z. B. Alter, L1/L2, Geschlecht)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#lexdec-datensatz",
    "href": "mats/02-dataviz_1.html#lexdec-datensatz",
    "title": "2  Datenvisualiserung 1",
    "section": "2.3 lexdec Datensatz",
    "text": "2.3 lexdec Datensatz\n\nlanguageR ist ein Begleitpaket für das Lehrbuch Baayen (2008)\n\nenthält linguistische Datensätze, z.B. lexdec.\n\nder lexdec-Datensatz enthält Daten für eine lexikalische Entscheidungsaufgabe im Englischen\n\nwir werden mit Variablen wie Reaktionszeiten und Genauigkeit arbeiten\n\n\n\n2.3.1 lexdec-Variablen\n\neine Liste einiger der Variablen ist in Tabelle 2.1 enthalten\n\n\n\n\n\nTabelle 2.1: Datenwörterbuch für df_lexdec: Lexikalische Entscheidungslatenzen, die von 21 Probanden für 79 konkrete englische Substantive erhoben wurden, mit Variablen, die mit dem Subjekt oder dem Wort verknüpft sind.\n\n\n\n\n\n\n\nVariable\nBeschreibung\n\n\n\n\nSubject\nein Faktor für die Probanden\n\n\nRT\nein numerischer Vektor für die Reaktionszeit in Millisekunden\n\n\nTrial\nein numerischer Vektor für den Rang des Versuchs in der Versuchsliste\n\n\nSex\nein Faktor mit den Ausprägungen F (weiblich) und M (männlich)\n\n\nNativeLanguage\nein Faktor mit den Niveaus English und Other, der zwischen englischen Muttersprachlern und Nicht-Muttersprachlern unterscheidet\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.2 LDT-Forschungsfragen\n\nbevor wir ein Experiment durchführen, haben wir Forschungsfragen, die wir mit den Daten beantworten wollen\n\nWir werden uns heute mit der folgenden Frage beschäftigen:\n\nUnterscheiden sich die Reaktionszeiten zwischen Muttersprachlern und Nicht-Muttersprachlern?\n\n\n\n\n\n2.3.3 Laden der Daten\n\nunsere Daten sind in dem Paket lanaugeR verfügbar, das wir bereits geladen haben\n\num die Daten zu drucken, geben Sie einfach den Namen des Datensatzes ein und führen Sie ihn aus\n\nUnten sehen wir nur ein paar Variablen, aber Sie sollten mehr in Ihrer Konsole sehen\n\n\nlexdec\n\n\n\n  Subject       RT Trial Sex NativeLanguage Correct PrevType PrevCorrect\n1      A1 6.340359    23   F        English correct     word     correct\n2      A1 6.308098    27   F        English correct  nonword     correct\n3      A1 6.349139    29   F        English correct  nonword     correct\n4      A1 6.186209    30   F        English correct     word     correct\n5      A1 6.025866    32   F        English correct  nonword     correct\n6      A1 6.180017    33   F        English correct     word     correct\n\n\n\nWie viele Variablen haben wir? Beobachtungen?\n\n\n2.3.3.1 Daten als Objekt speichern\n\nUm die Daten in unserer Umgebung zu speichern, müssen wir ihnen einen Namen zuweisen\n\nNennen wir es df_lexdec, was soviel bedeutet wie “Datenrahmen lexikalische Entscheidung”.\n\n\n\ndf_lexdec &lt;- lexdec\n\n\njetzt sehen wir es in unserem Enrivonment\n\nDoppelklicken Sie darauf, um es im Editorfenster zu sehen.\n\n\n\n\n\n2.3.4 Relevante Variablen\n\nZu den Variablen, die wir haben, gehören:\n\nSubjekt: Teilnehmer-ID\nRT: protokollierte Reaktionszeiten\nNativeLanguage: die Muttersprache des Teilnehmers\nWord: welches Wort präsentiert wurde\nClass: ob das Wort ein Tier oder eine Pflanze war\n\n\n\n\n\n\n\n\nAufgabe 9.2: ?lexdec\n\n\n\n\nBeispiel 2.1  \n\nUm herauszufinden, wofür die anderen Variablen stehen, führen Sie ?lexdec in der Konsole aus.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#erstellen-von-plots-mit-ggplot2",
    "href": "mats/02-dataviz_1.html#erstellen-von-plots-mit-ggplot2",
    "title": "2  Datenvisualiserung 1",
    "section": "2.4 Erstellen von Plots mit ggplot2",
    "text": "2.4 Erstellen von Plots mit ggplot2\n\ndas tidyverse ist eine Sammlung von Paketen, die das Aufräumen und die Visualisierung von Daten erleichtern\n\nwenn wir tidyverse laden, wird diese Sammlung von Paketen automatisch geladen\n\ndas ggplot2-Paket ist ein tidyverse-Paket, das Plots in Schichten aufbaut\n\n\nggplot2 Schichten\n\n\n\n\n\n\n\n\nAbbildung 2.1: Example of layers in a ggplot figure\n\n\n\n\n\n\n\n2.4.1 Ebene 1: leere Leinwand\n\ndie erste Ebene mit der Funktion ggplot() ist wie eine leere Leinwand\n\n\nggplot(data = df_lexdec)\n\n\n\n\n\n\n\n\n\n\n2.4.2 Ebene 2: Ästhetik der Darstellung\n\nals nächstes teilen wir ggplot() mit, wie unsere Variablen visuell dargestellt werden sollen\n\nWir fügen das “+” am Ende unserer Codezeile ein und verwenden in einer neuen Codezeile die Funktion “aes()”, um unsere Ästhetik zu definieren.\n\nUnsere erste Ästhetik bildet die Reaktionszeiten (RT) auf der x-Achse ab (der untere Teil der Grafik)\n\nwir wickeln die protokollierte RT in die Funktion exp() ein, um RTs in Millisekunden zu erhalten (aus Gründen, die wir nicht diskutieren werden)\n\n\n\nggplot(data = df_lexdec) +\n  aes(x = exp(RT))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAufgabe 2.2: Ästhetische Kartierung\n\n\n\n\nBeispiel 2.2  \n\nAdd the x-axis aesthetic.\n\n\n\n\n\n\n2.4.3 Schicht 3: Hinzufügen von Beobachtungen\n\nwir sehen keine Beobachtungen (d.h. die Balken) in der Grafik, warum nicht?\n\nwir haben ggplot() nicht gesagt, wie sie dargestellt werden sollen\n\nwir müssen ein Geom definieren: das geometrische Objekt, das ein Diagramm verwendet, um Daten darzustellen\n\nin ggplot2 beginnen die Geom-Funktionen mit geom_\nwir beschreiben Diagramme oft in Bezug auf die Arten von Geomen, die sie verwenden, z.B. verwenden Balkendiagramme Balkengeome (geom_bar()), Liniendiagramme Liniengeome (geom_line()), Punktdiagramme ein Punktgeom (geom_point()), usw.\n\n\n\nErzeugen wir unser Histogramm mit dem Geom geom_histogram()\n\n\nggplot(data = df_lexdec) +\n  aes(x = exp(RT)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nWir erhielten die folgende Meldung, als wir geom_point() einschlossen:\n\nstat_bin() mit bins = 30. Wählen Sie einen besseren Wert mit binwidth.\n\nDies sagt uns nur etwas über die Breite unserer Balken: jeder Balken repräsentiert einen Bereich möglicher Reaktionszeitwerte + bins = 30 bedeutet einfach, dass es 30 Balken gibt, wir können dies ändern und mehr oder weniger Balken haben, indem wir z.B. bins = 20 oder bins = 100 in geom_histogram() einfügen\n\n\n\n\nCode\nggplot(\n  data = df_lexdec,\n  mapping = aes(x = exp(RT))\n) +\n  labs(title = \"with geom_histogram(bins = 20)\") +\n  geom_histogram(bins = 20) +\n\n  ggplot(\n  data = df_lexdec,\n  mapping = aes(x = exp(RT))\n) +\n  labs(title = \"with geom_histogram(bins = 100)\") +\n  geom_histogram(bins = 100)\n\n\n\n\n\n\n\n\n\n\n\n2.4.4 Hinzufügen von Ästhetik\n\nEs ist nützlich, die Verteilung der Reaktionszeiten im Allgemeinen zu sehen.\n\naber wir wollen normalerweise Gruppen vergleichen\n\nB. Unterschiede zwischen Muttersprachlern und Nicht-Muttersprachlern oder zwischen verschiedenen Wortarten\n\n\nWir haben auch die Muttersprache als Variable, wie könnten wir diese in unserem Diagramm visualisieren?\n\n\n\nCode\nggplot(\n  data = df_lexdec,\n  aes(x = exp(RT), fill = NativeLanguage)\n) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\n\nwir sehen die roten und die blauen Balken, aber ist das blaue Histogramm über das rote geschichtet?\n\noder sind die roten Balken über den blauen Balken gestapelt?\n\nEs ist letzteres\n\nstellen wir es so ein, dass das blaue Histogramm über dem roten liegt\n\n\n\n\nCode\nggplot(\n  data = df_lexdec,\n  aes(x = exp(RT))\n) +\n  labs(title = \"No grouping\") +\n  geom_histogram() + \n\nggplot(\n  data = df_lexdec,\n  aes(x = exp(RT), fill = NativeLanguage)\n) +\n  labs(title = \"Stacked\") +\n  geom_histogram() + \n  \nggplot(\n  data = df_lexdec,\n  aes(x = exp(RT), fill = NativeLanguage)\n) +\n  labs(title = \"Layered: position = \\\"identity\\\"\") +\n  geom_histogram(position = \"identity\") +\n  \n  \n  plot_layout(guides = \"collect\") & theme(legend.position = 'bottom') \n\n\n\n\n\n\n\n\n\n\n\n2.4.5 Globale und lokale Ästhetik\n\nin unserer endgültigen Darstellung ist die Farbe der Histogramme leicht transparent\n\nWir können dies steuern, indem wir das Argument alpha = 0.3 zu geom_histogram() hinzufügen.\nalpha kann jeden anderen Wert zwischen 0 und 1 annehmen.\n\n\n\n\n\n\n\n\nAufgabe 2.3: Transparenz\n\n\n\n\nBeispiel 2.3  \n\nSpielen Sie mit der Transparenz des Histogramms geom. Wählen Sie den von Ihnen bevorzugten Alpha-Wert. Die Ausgabe sollte in etwa so aussehen:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.6 Anpassen unseres Plots\n\nwir können unsere Achsen- und Legendenbeschriftungen verbessern und auch Titel hinzufügen, indem wir die Funktion labs() verwenden\nWir können auch die Funktion scale_fill_colorblind() aus dem Paket ggthemes verwenden.\n\ndies erzeugt farbenblind-sichere Farben\n\nWir werden auch die Funktion theme_minimal() aus dem Paket ggplot2 verwenden; was bewirkt diese Funktion?\nVersuchen Sie, Ihrem Diagramm Folgendes hinzuzufügen\n\nÄndern Sie die Beschriftungen entsprechend\nund fügen Sie dem Code sinnvolle Kommentare mit # hinzu\n\n\n\nlabs(title = \"Plot title\",\n     x = \"x-axis label\",\n     y = \"y-axis label\") +\n  scale_fill_colorblind() +\n  theme_minimal()\n\n\n\n2.4.7 Kommentar\n\nDer Code und die Darstellung sollten in etwa so aussehen:\n\n\n## histogram of reaction times by native language\nggplot(data = df_lexdec) +\n  aes(x = exp(RT), fill = NativeLanguage) + ## set aesthetics\n  labs(title = \"Reaction times by L1\",\n     x = \"Reaction times (ms)\") +\n  geom_histogram(position = \"identity\", alpha = 0.3) +\n  scale_fill_colorblind() + ## make fill colorblind friendly\n  theme_minimal() ## set plot theme\n\n\n\n\n\n\n\n\n\n\n2.4.8 Speichern von Plots\n\nWir können Diagramme in unserer Umgebung speichern, genau wie wir Zahlen und Daten als Objekte speichern können.\n\nSie können Objekte beliebig benennen\naber es ist ratsam, den Namen sinnvoll zu gestalten (z.B. nicht fig1 oder xyz)\n\nNennen wir diese Grafik fig_lexdec_rt, für “figure lexical decision task reaction times”.\n\n\n\n\n\n\n\nAufgabe 2.4: Figur als Objekt speichern\n\n\n\n\nBeispiel 2.4  \n\n\nSpeichern Sie unsere endgültige Darstellung als Objekt mit dem Namen fig_lexdec_rt.\n\n\n\n\n\n\n\n2.4.9 Balkendiagramme\n\nKopieren Sie den Code für Ihr Histogramm\nNehmen Sie die folgenden Änderungen vor, um unser Balkendiagramm darzustellen\n\nEntfernen Sie die Namenszuweisung (fig_lexdec_rt)\nauf der x-Achse wollen wir NativeLanguage\nErsetzen Sie geom_histogram() durch geom_bar()\n\nEntfernen Sie die Argumente für das Histogramm (kein position oder alpha)\n\nändern Sie die Beschriftungen entsprechend\n\nSpeichern Sie das Diagramm als Objekt mit einem aussagekräftigen Namen (z.B. fig_lexdec_l1)\n\n\n\n\n\nsollte das Diagramm in etwa so aussehen:\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.10 Kombinieren von Plots\n\nEin Grund, Ihre Darstellung als Objekt zu speichern, ist, dass wir sie später aufrufen können\n\nd.h. Sie können den Plot an einer Stelle in Ihrem Dokument erstellen, sich aber entscheiden, ihn erst im gerenderten Bericht weiter unten zu drucken\n\nein weiterer Grund ist, dass wir mehrere Diagramme kombinieren können\n\nDies kann mit einer Vielzahl von Paketen geschehen\nVersuchen wir es mit dem Paket patchwork\n\nBenutze + um zwei Plots nebeneinander zu verbinden\noder /, um sie übereinander darzustellen\n\n\n\n\n2.4.10.1 Kombinieren von Plots mit +\n\nfig_lexdec_rt + fig_lexdec_l1\n\n\n\n\n\n\n\n\n\n\n2.4.10.2 Kombinieren von Plots mit /\n\nfig_lexdec_rt / fig_lexdec_l1",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#entscheidung-für-ein-geom",
    "href": "mats/02-dataviz_1.html#entscheidung-für-ein-geom",
    "title": "2  Datenvisualiserung 1",
    "section": "2.5 Entscheidung für ein Geom",
    "text": "2.5 Entscheidung für ein Geom\n\nWarum verwenden wir ein Histogramm für die Reaktionszeit und ein Balkendiagramm für die Muttersprache?\nUm welche Arten von Variablen handelt es sich?\n\nReaktionszeit ist kontinuierlich\nMuttersprache ist eine kategoriale Variable\n\nWir verwenden Histogramme, um die Verteilungen von kontinuierlichen Variablen zu visualisieren.\nWir verwenden Balkendiagramme, um Verteilungen von kateogrischen Variablen zu visualisieren.\nWenn wir wissen, was wir visualisieren wollen (z. B. Verteilungen) und welche Art von Variable wir haben (d. h. kontinuierlich, kategorial), können wir entscheiden, welche Art von Diagramm wir erstellen wollen.\nOft ist es eine gute Idee, die Darstellung auf Papier zu zeichnen, bevor man in R beginnt (ich mache das auch oft).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#heutige-ziele-1",
    "href": "mats/02-dataviz_1.html#heutige-ziele-1",
    "title": "2  Datenvisualiserung 1",
    "section": "Heutige Ziele",
    "text": "Heutige Ziele\nHeute haben wir gelernt…\n\nwas Datenrahmen sind\nden Unterschied zwischen kategorialen und kontinuierlichen Daten\nwie man Diagramme mit ggplot erstellt\ndie richtige Darstellung für unsere Daten auszuwählen",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#weitere-übungen",
    "href": "mats/02-dataviz_1.html#weitere-übungen",
    "title": "2  Datenvisualiserung 1",
    "section": "2.6 Weitere Übungen",
    "text": "2.6 Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.2.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/02-dataviz_1.html#session-info",
    "href": "mats/02-dataviz_1.html#session-info",
    "title": "2  Datenvisualiserung 1",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.3.0.386 (Cherry Blossom).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] magick_2.8.3     kableExtra_1.4.0 knitr_1.46       patchwork_1.2.0 \n [5] ggthemes_5.1.0   languageR_1.5.0  lubridate_1.9.3  forcats_1.0.0   \n [9] stringr_1.5.1    dplyr_1.1.4      purrr_1.0.2      readr_2.1.5     \n[13] tidyr_1.3.1      tibble_3.2.1     ggplot2_3.5.1    tidyverse_2.0.0 \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        xml2_1.3.6       \n [5] stringi_1.8.3     hms_1.1.3         digest_0.6.35     magrittr_2.0.3   \n [9] evaluate_0.23     grid_4.4.0        timechange_0.3.0  fastmap_1.1.1    \n[13] rprojroot_2.0.4   jsonlite_1.8.8    fansi_1.0.6       viridisLite_0.4.2\n[17] scales_1.3.0      cli_3.6.2         rlang_1.1.3       munsell_0.5.1    \n[21] withr_3.0.0       yaml_2.3.8        tools_4.4.0       tzdb_0.4.0       \n[25] colorspace_2.1-0  here_1.0.1        pacman_0.5.1      vctrs_0.6.5      \n[29] R6_2.5.1          lifecycle_1.0.4   htmlwidgets_1.6.4 pkgconfig_2.0.3  \n[33] pillar_1.9.0      gtable_0.3.5      Rcpp_1.0.12       glue_1.7.0       \n[37] systemfonts_1.0.6 highr_0.10        xfun_0.43         tidyselect_1.2.1 \n[41] rstudioapi_0.16.0 farver_2.1.1      htmltools_0.5.8.1 rmarkdown_2.26   \n[45] svglite_2.1.3     labeling_0.4.3    compiler_4.4.0   \n\n\n\n\n\n\n\n\nBaayen, R. H. (2008). Analyzing Linguistic Data: A Practical Introduction to Statistics Using R.\n\n\nNordmann, E., & DeBruine, L. (2022). Applied Data Skills. Zenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvisualiserung 1</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html",
    "href": "mats/03-quarto_1.html",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "",
    "text": "Lernziele",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#lernziele",
    "href": "mats/03-quarto_1.html#lernziele",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "",
    "text": "lernen, was dynamische Berichte sind\nunser eigenes Quarto-Dokument erstellen\nlernen, wie man ein Quarto-Dokument bearbeitet\nlernen, wie man Code in ein Quarto-Dokument einfügt\nein Quarto-Dokument in verschiedenen Formaten wiedergeben",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#lesungen",
    "href": "mats/03-quarto_1.html#lesungen",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "Lesungen",
    "text": "Lesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kap. 29 (Quarto) und Kap. 30 (Quarto formats) in Wickham et al. (2023).\nEine ergänzende Lektüre ist Ch. 2 (Reproducible Workflows) in Nordmann & DeBruine (2022). Nordmann & DeBruine (2022) verwendet Rmarkdown-Skripte, während wir die nächste Generation verwenden werden: Quarto. Wir sollten in Quarto immer noch in der Lage sein, genau die gleichen Dinge zu tun, wie sie in Rmarkdown vorgeschlagen werden.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#wiederholung",
    "href": "mats/03-quarto_1.html#wiederholung",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "Wiederholung",
    "text": "Wiederholung\nLetzte Woche haben wir gelernt…\n\nwas Datenrahmen sind\nden Unterschied zwischen kategorialen und kontinuierlichen Daten\nwie man Diagramme mit ggplot erstellt\ndie richtige Darstellung für unsere Daten auszuwählen\n\n\nWiederholung: ggplot()\nSehen Sie sich diesen Code an. Was würde passieren, wenn wir ihn ausführen würden?\n\nlibrary(languageR)\nlibrary(tidyverse)\ndf_lexdec &lt;- lexdec\n\nfig_lexdec &lt;-\n  df_lexdec |&gt; \n  ggplot() +\n  aes(x = RT, colour = Class) +\n  geom_histogram(position = \"identity\", alpha = .5) +\n  theme_bw()\n\nWelche Darstellung in Abbildung 3.1 wird durch den folgenden Code erzeugt?\n\nlibrary(languageR)\nlibrary(tidyverse)\ndf_lexdec &lt;- lexdec\n\nfig_lexdec1 &lt;-\n  df_lexdec |&gt; \n  ggplot() +\n  aes(x = RT, colour = Class) +\n  geom_density(alpha = .5) +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nAbbildung 3.1: Drei aus dem lexdec-Datensatz generierte Diagramme",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#set-up",
    "href": "mats/03-quarto_1.html#set-up",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "Set-up",
    "text": "Set-up\n\nwir müssen eine LaTeX-Distribution verwenden, um PDF-Dokumente mit Quarto zu erstellen\n\nLaTeX ist ein Schriftsatzsystem\nTinyTex ist eine eigene LaTeX-Distribution, mit der wir PDFs erstellen können.\nDas Paket tinytex kann uns helfen, TinyTex zu installieren\n\n\n\nInstallation von LaTeX über tinytex\n\nFühren Sie den folgenden Code in der Konsole aus\noder, wenn Sie ihn in einem Skript ausführen wollen, um zu dokumentieren, was Sie getan haben, kommentieren Sie ihn nach der Ausführung aus (d.h. fügen Sie ein # davor)\n\n\n# run this in the console\ninstall.packages(\"tinytex\")\ntinytex::install_tinytex()\n\n\n\nOrdner für Woche 3\n\nFügen Sie einen Unterordner mit dem Namen 03-quarto in Notes hinzu\nGehen Sie zu Moodle und speichern den Materialordner für ‘03 - Einführung in Quarto’ in Ihrem moodle Ordner\nÖffnen Sie das Dokument _blatt.html auf Ihren Computer\n\nSehen Sie das Dokument an; Sie können oben rechts auf verschiedene Schaltflächen klicken. Probieren Sie es.\n\n\n\n\n\n\n\n\n\n\nAbbildung 3.2: Notes folder structure",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#quarto",
    "href": "mats/03-quarto_1.html#quarto",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.1 Quarto",
    "text": "3.1 Quarto\n\nQuarto ist ein Dateityp, der dynamische Berichte erstellt\nQuarto-Dokumente sehen genauso aus wie ihr Vorgänger, Rmarkdown\n\n\n3.1.1 Dynamische Berichte\n\ndiejenigen, die Text, Code, Codeausgabe enthalten\nQuarto bietet ein “unified authoring framework” für Data Science, das Ihren Text, Ihren Code und Ihre Code-Ausgabe einschließt (Wickham et al., 2023, Kap 29.1)\nQuarto wurde entwickelt, um auf drei Arten verwendet zu werden:\n\n\nFür die Kommunikation mit Entscheidungsträgern, die sich auf die Schlussfolgerungen und nicht auf den Code hinter der Analyse konzentrieren wollen.\nfür die Zusammenarbeit mit anderen Datenwissenschaftlern (einschließlich Ihnen in der Zukunft!), die sich sowohl für Ihre Schlussfolgerungen als auch für die Art und Weise interessieren, wie Sie zu ihnen gekommen sind (d. h. für den Code).\nals eine Umgebung, in der Datenwissenschaft betrieben wird, als ein modernes Labornotizbuch, in dem wir nicht nur aufzeichnen können, was wir getan haben, sondern auch unsere Gedankengänge.\n\n\n\n3.1.2 R v. Rmarkdown v. Quarto\n\n.R -Dateien enthalten nur (R-)Quellcode\n.Rmd dynamische Berichte mit\n\nR-Code (und R-Pakete)\n\n.qmd dynamische Berichte (RStudio v2022.07 oder später) mit\n\nR-Code (und R-Pakete)\nNative Unterstützung für Python (und Jupyter-Notebooks)\nNative Unterstützung für Julia\n\n\n\n\n\n\n\n\nAufgabe 3.1: RStudio version\n\n\n\n\nBeispiel 3.1  \n\n\nFühren den folgenden Code in der Konsole aus: RStudio.Version()$version\n\nwenn die ausgegebene Version 2022.07 oder höher ist, können Sie Quarto benutzen\nwenn nicht:\n\nAktualisieren Sie RStudio: Help &gt; Check for updates\n\n\n\n\n\n\n\n3.1.3 Markdown\n\n.md-Dateien\nein Klartext-Editor-Format, das\n\nFormatierungselemente hinzufügt, die unabhängig von Gerät und Ausgabeformat sind (PDF, Word-Dokument, html…)\nleicht zu lesen ist\n\nMarkdown-Dokumente sind das Bindeglied zwischen unserem Quelldokument (.qmd) und unserer Ausgabe (z.B. PDF)\n\n\n\n3.1.4 Folder structure\n\njede .qmd sollte (normalerweise) in einem eigenen Ordner sein\n\nd.h. es sollten nicht mehrere .qmd Dateien im selben Ordner sein\n\ndies ist nur mein Vorschlag, um die Ordner ordentlich und organisiert zu halten\n\nd.h., es gibt keinen technischen Grund dafür (die Dokumente laufen auch dann, wenn sie sich alle im selben Ordner befinden)\n\nwerfen wir einen Blick auf einige meiner früheren und aktuellen Projektordner",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#unsere-erstes-quarto-dokument",
    "href": "mats/03-quarto_1.html#unsere-erstes-quarto-dokument",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.2 Unsere erstes Quarto-Dokument",
    "text": "3.2 Unsere erstes Quarto-Dokument\n\nletzte Woche haben wir ein R-Skript erstellt, das wir über Moodle eingereicht haben\nwir werden nun unsere erste .qmd-Datei erstellen\nvon nun an wird dies die Datei sein, die wir in Moodle einreichen (kein R-Skript)\n\n\n\n\n\n\n\nAufgabe 3.2: erste Quarto\n\n\n\n\nBeispiel 3.2  \n\n\nErstellen Sie in Ihrem R-Projekt-Ordner, in dem ihr Ihre Kursunterlagen/Notizen aufbewahren, einen neuen Ordner für Woche 3\nFile &gt; New Document &gt; Quarto Document\n\nGeben Sie ihm einen Titel wie “Quarto - Woche 3”\nDeaktivieren Sie die Option “open with Visual Editor”.\n\nSchauen das neue Skript an, um mehr über Quarto zu erfahren.\nKlicken Sie auf die Schaltfläche “Render” am oberen Rand des Dokuments\n\nSpeichern Sie das Dokument in dem Ordner für Woche 3, den Sie gerade erstellt haben.\nWas geschiehen? Vergleichen die Ausgabe mit dem Quellcode des Dokuments.\n\nGehen Sie zurück zu Ihrem neuen Ordner 03-quarto\n\nWas hat sich geändert?\n\n\n\n\n\n\n\n3.2.1 Quarto-Grundlagen\n\nQuarto-Dokumente (wie Rmarkdown) enthalten drei wichtige Arten von Inhalten:\n\nden YAML-Header, der von --- umgeben ist\nText mit einer einfachen Formatierung oder Strukturierung wie ## Überschrift oder *Kursivschrift*\nR-Code-Chunk, umgeben von ```{r} ```\n\n\n\n```{r}\n#| code-line-numbers: false\n## Dies ist ein Code Chunk\n1 + 1\n```\n\n[1] 2\n\n\n\n\n3.2.2 YAML\n\nstand ursprünglich für Yet Another Markup Language\n\nwurde aber in YAML Ain’t Markup Language umbenannt, um den Zweck der Sprache als datenorientiert und nicht als Dokumentauszeichnung zu betonen (laut Wikipedia)\n\nenthält alle Metainformationen zu Ihrem Dokument\n\nz.B. Titel, Autorenname\n\nauch Formatierungsinformationen\n\nz.B. Typ der Ausgabedatei\n\nes gibt viele Möglichkeiten der Dokumentformatierung und -anpassung, die wir in diesem Kurs nicht behandeln werden\n\naber ich habe zum Beispiel viele YAML-Formatierungsoptionen im Quellcode meiner Folien\n\n\n\n\n\n\n\n\nAufgabe 3.3: YAML\n\n\n\n\nBeispiel 3.3  \n\n\nÄndern Sie den Titel, wenn Sie das tun möchten.\nRaten Sie, wie man einen “Untertitel” (EN: subtitle) hinzufügen könnte (Hinweis: es ist ähnlich wie beim Hinzufügen eines title)\nFügen Sie einen Autor hinzu, Autor: \"vorname nachname\" (siehe Beispiel unten)\nFüge ein Inhaltsverzeichnis hinzu (EN: Table of Contents, toc), indem du format so änderst, dass es wie folgt aussieht:\n\n\n---\ntitle: \"Quarto - Woche 3\"\nauthor: \"Vorname Nachname\"\nformat:\n  pdf:\n    toc: true\n---\n\n\nRendern nun das Dokument. Sehen Sie Ihre Änderungen?\n\n\n\n\n\n\n\n3.2.3 Strukturierung Ihres Dokuments\n\nwir können unser Dokument strukturieren mit\n\n## Überschriften\n### Zwischenüberschriften\n#### Unter-Zwischenüberschriften, usw.\n\n\n\n---\ntitle: \"Quarto - Woche 3\"\nauthor: \"Vorname Nachname\"\nformat:\n  pdf:\n    toc: true\n---\n\n## Überschrift 1\n\nHier ist ein Text über das Thema, das mit dieser Überschrift verbunden ist.\n\n## Überschrift 2\n\nHier ist ein weiterer Text zu einem anderen Thema.\n\n### Unterüberschrift 2.1\n\nDies ist ein Text über das Unterthema.\n\n\n\n\n\n\n\nDie Bedeutung der Formatierung\n\n\n\n\nZwischenüberschriften benötigen ein Leerzeichen nach dem letzten Hashtag (## Zwischenüberschrift anstelle von ##Zwischenüberschrift), um als Überschrift gelesen zu werden. YAML erfordert außerdem einen sehr präzisen Schriftsatz. Da die Abstände in der YAML (und anderswo) so wichtig sind, möchte ich die Leerzeichen sehen und zählen können. Um dies zu tun, geht in RStudio:\n\ngehen zu Ihren Globalen Einstellungen (Werkzeuge &gt; Globale Einstellungen)\nunter Code (linke Spalte) &gt; Display (Tab), markieren das Kästchen &gt; Show whitespace character\n\n\n\n\n\n\n\n\n\n\nAufgabe 3.4: Überschriften\n\n\n\n\nBeispiel 3.4  \n\n\nKopiern den obigen Code (Überschriften und Unterüberschriften) und ersetzen den Text in der Quarto-Vorlage.\nErsetzen die erste Überschrift durch den Titel Quarto\n\nSchreiben einen Text, der Quarto beschreibt, unter die Überschrift\n\nSchreiben eine Unterüberschrift namens YAML\n\nSchreiben einen Text, der die YAML-Struktur beschreibt, die wir besprochen haben\n\nErstellen eine Unterüberschrift mit dem Namen Quarto-Struktur.\n\nSchreiben einige Notizen darüber, wie wir ein Quarto-Dokument strukturieren können (z.B. durch das Erstellen von Überschriften)\n\nFinden Sie in RStudio die Schaltfläche Outline oben links im .qmd Text Editor Fenster\n\nWas sehent Sie, wenn Sie darauf klicken?\n\n\n\n\n\n\n\n\n3.2.4 Textformatierung\n\nzum Formatieren von Text müssen wir die Markdown-Syntax verwenden\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormat\nMarkdown\nAusgabe\n\n\n\n\nKursivschrift\nDieser Text ist *kursiv*\nDieser Text ist kursiv\n\n\nFett\nDieser Text ist **fett**\nDieser Text ist fett\n\n\nSubskription\nDieser Text ist ~tiefgestellt~\nDieser Text isttiefgestellt\n\n\nHochgestelt\nDieser Text ist ^hochgestellt^\nDieser Text ist hochgestellt\n\n\n\n\n\n\n\n\n\n\n3.2.5 Aufzählungen\n\nwir können Aufzählungslisten mit Bindestrichen erstellen.\n\nUnteraufzählungen müssen eingerückt werden (drückt die Tabulatortaste)\n\nnummerierte Listen können durch einfaches Schreiben einer nummerierten Liste erstellt werden\n\nUnteraufzählungen müssen in nummerierten Listen doppelt eingerückt werden\n\n\n\n- dies ist ein Aufzählungszeichen\n  + dies ist ein Unterpunkt\n\n1. Dies ist ein nummerierter Punkt\n    a. dies ist ein unternummerierter Punkt (beachtt den doppelten Einzug)\n2. dies ist der zweite nummerierte Punkt\n\n\ndies ist ein Aufzählungszeichen\n\ndies ist ein Unterpunkt\n\n\n\nDies ist ein nummerierter Punkt\n\ndies ist ein unternummerierter Punkt (beachtt den doppelten Einzug)\n\ndies ist der zweite nummerierte Punkt\n\n\n\n\n\n\n\nAufgabe 3.5: Aufzählungen\n\n\n\n\nBeispiel 3.5  \n\n\nFügen Ihrem .qmd Dokumententext eine Textformatierung hinzu.\nFügen eine Aufzählungsliste hinzu\nFügen eine nummerierte Liste hinzu\nRendern Sie das Dokument. Hat es geklappt?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#codierung-in-quarto",
    "href": "mats/03-quarto_1.html#codierung-in-quarto",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.3 Codierung in Quarto",
    "text": "3.3 Codierung in Quarto\n\nDer große Vorteil von dynamischen Berichten ist die Integration von Text und Code\nVorletzte Woche haben wir gelernt, wie man einfache mathematische Berechnungen in R durchführt.\nwie würden wir R-Befehle in ein .qmd-Dokument einfügen?\n\nInline-Code (Code, der innerhalb einer Textzeile ausgeführt wird)\nCode-Chunke (ein Code-Chunk, der nicht in Text enthalten ist)\n\n\n\n3.3.1 Code-Chunks\n\nCode Chunks sind zwischen ```{r} und ``` eingebettet.\neine schöne Tastenkombination:Cmd-Option-I (Mac) oder Strg-Alt-I (PC)\n\n\n```{r}\n#| eval: false\n\n## Addition\n4+6\n```\n\n\nihr könnt den Code in Ihrer RStudio-Sitzung ausführen, indem ihr:\n\nauf das kleine grüne Dreieck oben rechts im Chunk klickt\ndie Tastenkombination Cmd/Strg-Enter verwendt, um eine einzelne Code-Zeile auszuführen (je nachdem, worauf der Cursor steht)\nder Tastenkombination Cmd/Strg-Shift-Enter benutzt, um den gesamten Code-Chunk auszuführen (falls es mehrere Befehle innerhalb eines einzelnen Abschnitts gibt)\n\n\n\n\n\n\n\n\nAufgabe 3.6: Code-Chunks\n\n\n\n\nBeispiel 3.6  \n\n\nFüge einen Code Chunk zu deiner .qmd Datei hinzu\n\nFüge einige mathematische Operationen ein (Addition, Subtraktion, etc)\nFügt informative Anmerkungen zu Ihrem Code hinzu (z.B. ## Addition)\n\nFüge einen Text unter deinem Code-Chunk hinzu, der beschreibt, was der obige Code erreicht hat.\nRendern Sie das Dokument. Hat es geklappt?\n\n\n\n\n\n\n\n\n\n\n\nErinnerung! Überschriften und Code-Anmerkungen\n\n\n\n\nDenken Sie beim Schreiben von Notizen/bei der Bearbeitung von Übungen im Unterricht daran, informative Überschriften/Unterüberschriften zu erstellen! Auf diese Weise wird das Dokument strukturiert und übersichtlich, wenn ihr-in-der-Zukunft (oder ich) darauf zurückblickt.\nÜberschriften/Zwischenüberschriften strukturieren das gesamte Dokument. Code-Anmerkungen beschreiben, was bestimmte Teile des Codes bewirken (und warum). Beide beginnen mit einem Hashtag + Leerzeichen (# ), aber Überschriften stehen außerhalb eines Codeabschnitts, während Codeanmerkungen innerhalb eines Codeabschnitts erscheinen.\nTipp: Klicken Sie auf die Schaltfläche “Outline” oben rechts im Texteditor-Fenster. Was zeigt sie an?\n\n\n\n\n\n3.3.2 Code-Chunk-Optionen\n\nwir können die Ausführung von Code-Chunken steuern\nwir wollen nicht immer unseren Code in einem Bericht wiederholen\n\nwir können dies in jedem Code-Chunk mit #| echo: true oder false steuern\n\nwir wollen nicht immer unseren Code in einem Bericht ausführen lassen\n\nwir können dies in jedem Code-Chunk mit #| eval: true oder false steuern\n\n\n\nDies würde wie folgt aussehen:\n\n\n```{r}\n#| eval: true\n\n## Addition\n4+6\n```\n\n[1] 10\n\n\n\nWichtig ist, dass die Codechunk-Optionen:\n\nmit #| beginnen, mit einem Leerzeichen dahinter und keinem Leerzeichen davor\ndirekt unter ```{r} platziert werden\n\n\n\n\n\n\n\n\nAufgabe 3.7: c()\n\n\n\n\nBeispiel 3.7  \n\n\nErinnern Sie sich, dass wir letzte Woche die Funktion c() (EN: concatenate) gesehen haben, die mehrere Werte kombiniert (z.B. mean(c(3,4,25)) ergibt den Mittelwert von 3,4 und 25)\nIn einem Code-Stück: Erstellen sie ein Objekt, das eine Liste von Zahlen enthält (z.B. Objektname &lt;- c(...))\nBerechnen Sie den Mittelwert dieser Zahlen, indem Sie nur den Objektnamen verwendt.\nSpeichern Sie den Mittelwert dieser Zahlen als ein Objekt\nRendern Sie das Dokument und seht sich den Abschnitt mit Ihrem Code-Chunk an.\n\nÄndern Sie nun im Quellcode die Chunk-Einstellungen auf echo: false und rendern das Dokument. Was ändert sich?\nSetzen nun echo: true, aber eval: false. Rendern das Dokument. Was ändert sich?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#plots-in-quarto",
    "href": "mats/03-quarto_1.html#plots-in-quarto",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.4 Plots in Quarto",
    "text": "3.4 Plots in Quarto\n\nEin großer Vorteil der gerenderten Quarto-Dokumente besteht darin, dass wir unsere Abbildungen zusammen mit den Textbeschreibungen anzeigen können\nLassen Sie uns versuchen, eine Handlung von letzter Woche in unserem neuen Quarto-Dokument zu reproduzieren\n\n\n3.4.1 Set-up\n\nunsere Pakete in einen Codechunk laden: tidyverse, languageR, und ggthemes\n\n\n```{r}\n## Pakete laden\nlibrary(tidyverse)\nlibrary(languageR)\nlibrary(ggthemes)\n```\n\n\nunsere Daten in einen separaten Codechunk laden (am besten ist es, einen einzigen Codechunk für einen einzigen Zweck zu verwenden)\n\n\n```{r}\n## Daten laden\ndf_lexdec &lt;- lexdec\n```\n\n\n\n3.4.2 Plots in Quarto\n\nErstellen Sie jetzt einfach einen neuen Codechunk, der einen Code von letzter Woche enthält\nwir speichern es als Objekt mit dem Namen fig_lexdec_hist:\n\n\n### histogram of reaction times by native language\nfig_lexdec_hist &lt;-\n  ggplot(data = df_lexdec) +\n  aes(x = exp(RT), fill = NativeLanguage) + ### set aesthetics\n  geom_histogram(position = \"identity\", alpha = 0.3) +\n  scale_fill_colorblind() + ### make fill colorblind friendly\n  theme_minimal() ### set plot theme\n\n\n\n3.4.3 Plots drucken\n\nErinnern Sie sich an die letzte Woche: Wenn Sie einen Plot benennen, wird er nur gedruckt, wenn Sie den Namen des Objekts eingeben\nwenn Sie den Plot nicht als Objekt speichern, wird er gedruckt, wenn Sie den Code ausführen, der den Plot erzeugt\nWenn Sie den Plot als Objekt speichern, wird er nicht gedruckt, wenn Sie den Code ausführen.\n\nIn diesem Fall müssen Sie den Objektnamen ausführen, um zu sehen, was unter diesem Namen gespeichert ist\nDies gilt für alle Arten von Objekten, nicht nur für Diagramme!\n\n\n\n\n\n\n\n\nAufgabe 3.8: Plots in Quarto\n\n\n\n\nBeispiel 3.8  \n\n\nEinen neuen Codeabschnitt erstellen und das Balkendiagramm von letzter Woche erzeugen, aber als Objekt speichern\nIn einem separaten Codechunk nur den Objektnamen dieses Diagramms angeben\nRendern Sie das Dokument, um zu sehen, wo die Abbildung gedruckt wurde.\n\n\n\n\n\n\nfig_lexdec_l1 &lt;-\n  ggplot(data = df_lexdec) +\n  aes(x = NativeLanguage, fill = NativeLanguage) +\n  ## add the geom:\n  geom_bar() +\n  scale_fill_colorblind() + ## add colourblind colours\n  theme_minimal()\n\n\nfig_lexdec_l1\n\n\n\n\n\n\n\nAbbildung 3.3: Barplot of observations per native language",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#ausgabeformate",
    "href": "mats/03-quarto_1.html#ausgabeformate",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.5 Ausgabeformate",
    "text": "3.5 Ausgabeformate\n\nes gibt mehrere Ausgabeformate, die wahrscheinlich nützlichsten sind:\n\nhtml (default)\npdf\nrevealjs (Folien)\ndocx\n\n\n\n3.5.1 Ausgabeformate\n\nwenn wir das Dokument rendern:\n\nQuarto sendet die .qmd-Datei an knitr (ein R-Paket für dynamische Berichte mit R)\nknitr führt die Code-Chunke aus und erstellt ein neues .md Dokument mit Code und Ausgabe\ndie .md-Datei wird von pandoc verarbeitet, das .md-Dateien in die fertige Datei konvertieren kann, mit vielen Ausgabeformaten\n\n\n\n\n\n\n\nDiagramm des Quarto-Workflows von qmd, zu knitr, zu md, zu pandoc, zur Ausgabe im PDF-, MS Word- oder HTML-Format. (Quelle: Wickham et al. (2023))\n\n\n\n\n\n\n\n\n\n\nAndere Verwendungen\n\n\n\n\nQuarto kann für eine Vielzahl von Zwecken verwendet werden, wie z. B.:\n\nWebsites/Blogs\nNotizen machen\nDokumentieren von allem, was mit Code zu tun hat, um die Reproduzierbarkeit zu verbessern\n\nTipps zum Arbeitsablauf\nBearbeitung von csv-Dateien (z. B. Stimuluslisten)\n\n\n\n\n\n\n\n\n\n\n\nAufgabe 3.9: Ausgabeformate\n\n\n\n\nBeispiel 3.9  \n\n\nErsetzt html in der YAML durch revealjs. Rendert das Dokument.\n\nSchauen Sie den Ordner für die Notizen dieser Woche an. Welche Dateien seht?\n\nSetzt nun format auf pdf. Rendert das Dokument.\n\nLäuft es?\nVersuche, pdf durch den Buchstaben l zu ersetzen. R schlägt eine Vervollständigung vor, welche ist es? Wähle sie aus und rendere das Dokument.\n\nSetzt das Format wieder auf html. Rendert das Dokument.\nGeht zurück zu Ihrem Ordner mit den Notizen dieser Woche. Welche Dateien seht?\n\nIst die Ausgabe von revealjs dort?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#weitere-übungen",
    "href": "mats/03-quarto_1.html#weitere-übungen",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.6 Weitere Übungen",
    "text": "3.6 Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.3",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#lernziele-1",
    "href": "mats/03-quarto_1.html#lernziele-1",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nWir haben…\n\ngelernt, was dynamische Berichte sind ✅\nunser eigenes Quarto-Dokument erstellt ✅\ngelernt, wie man ein Quarto-Dokument bearbeitet ✅\ngelernt, wie man Code in ein Quarto-Dokument einfügt ✅\nein Quarto-Dokument in verschiedenen Formaten wiedergebt ✅",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#extra-reproduzierbarkeit-in-quarto",
    "href": "mats/03-quarto_1.html#extra-reproduzierbarkeit-in-quarto",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "3.7 Extra: Reproduzierbarkeit in Quarto",
    "text": "3.7 Extra: Reproduzierbarkeit in Quarto\n\ndie Paketversionen mit sessionInfo() ausgeben\n\nwenn ich ein neues Dokument beginne, ist eines der ersten Dinge, die ich tue, eine Kopfzeile ## Session Info am unteren Ende hinzuzufügen, mit dem folgenden:\n\n\n\nsessionInfo()\n\n\n\n\n\n\n\nAufgabe 3.10: Session Info\n\n\n\n\nBeispiel 3.10  \n\nfügt eine “Session Info” Abschnitt am Ende des Dokuments hin",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/03-quarto_1.html#session-info",
    "href": "mats/03-quarto_1.html#session-info",
    "title": "3  Dynamische Berichte mit Quarto",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.3.0.386 (Cherry Blossom).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] ggthemes_5.1.0  magick_2.8.3    patchwork_1.2.0 lubridate_1.9.3\n [5] forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4     purrr_1.0.2    \n [9] readr_2.1.5     tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.1  \n[13] tidyverse_2.0.0 languageR_1.5.0\n\nloaded via a namespace (and not attached):\n [1] gt_0.10.1         sass_0.4.9        utf8_1.2.4        generics_0.1.3   \n [5] renv_1.0.7        xml2_1.3.6        stringi_1.8.3     hms_1.1.3        \n [9] digest_0.6.35     magrittr_2.0.3    evaluate_0.23     grid_4.4.0       \n[13] timechange_0.3.0  fastmap_1.1.1     rprojroot_2.0.4   jsonlite_1.8.8   \n[17] fansi_1.0.6       scales_1.3.0      cli_3.6.2         rlang_1.1.3      \n[21] commonmark_1.9.1  munsell_0.5.1     withr_3.0.0       yaml_2.3.8       \n[25] tools_4.4.0       tzdb_0.4.0        colorspace_2.1-0  here_1.0.1       \n[29] vctrs_0.6.5       R6_2.5.1          lifecycle_1.0.4   htmlwidgets_1.6.4\n[33] pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.5      glue_1.7.0       \n[37] Rcpp_1.0.12       xfun_0.43         tidyselect_1.2.1  rstudioapi_0.16.0\n[41] knitr_1.46        farver_2.1.1      htmltools_0.5.8.1 rmarkdown_2.26   \n[45] labeling_0.4.3    compiler_4.4.0    markdown_1.12    \n\n\n\n\n\n\n\n\nNordmann, E., & DeBruine, L. (2022). Applied Data Skills. Zenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dynamische Berichte mit Quarto</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html",
    "href": "mats/04-wrangling_1.html",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "",
    "text": "Lesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kap. 4 (Data Transformation) in Wickham et al. (2023).\nEine ergänzende Lektüre ist Ch. 9 (Data Wrangling) in Nordmann & DeBruine (2022).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#wiederholung",
    "href": "mats/04-wrangling_1.html#wiederholung",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "Wiederholung",
    "text": "Wiederholung\nLetze Woche haben wir…\n\ngelernt, was dynamische Berichte sind\nunser eigenes Quarto-Dokument erstellt\ngelernt, wie man ein Quarto-Dokument bearbeitet\ngelernt, wie man Code in ein Quarto-Dokument einfügt\nein Quarto-Dokument in verschiedenen Formaten wiedergebt",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#heutige-ziele",
    "href": "mats/04-wrangling_1.html#heutige-ziele",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "Heutige Ziele",
    "text": "Heutige Ziele\nHeute werden wir…\n\nlernen, wie man Daten mit dem Paket dplyr aus dem tidyverse verarbeitet\nlernen, wie man die pipe (|&gt;) verwendet, um das Ergebnis einer Funktion in eine andere Funktion einzuspeisen\nFunktionen kennenlernen, die auf Zeilen operieren\nFunktionen kennenlernen, die mit Spalten arbeiten\nlernen, wie man dplyr-Funktionen mit Plots von ggplot2 kombiniert\n\n\nLust auf mehr?\n\nKapital 4 (Data transformation) in Wickham et al. (2023)\nKapital 9 (Data wrangling) in Nordmann & DeBruine (2022)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#sec-wrangling1-setup",
    "href": "mats/04-wrangling_1.html#sec-wrangling1-setup",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "4.1 Einrichtung",
    "text": "4.1 Einrichtung\n\nFrisches Quarto-Dokument\n\nErstellen Sie ein neues Quarto-Dokument für den heutigen Unterricht\n\nDatei &gt; Neues Dokument &gt; Quarto Dokument, mit dem Namen 04-wrangling\n\nYAML einrichten: Titel, Ihr Name, ein toc hinzufügen\n\n\n\ntitle: \"Data wrangling\"\nsubtitle: \"Transforming data\"\nauthor: \"Your name here\"\nlang: de\ndate: \"11/08/2023\"\nformat: \n  html:\n    toc: true\n\n\nPakete\n\nDie heutigen Pakete sind:\n\ntidyverse: zum Verarbeiten (dplyr) und Plotten (ggplot2)\nlanguageR: für linguistische Datensätze\n\n\n\n\nlibrary(tidyverse)\nlibrary(languageR)\n\n\nDaten\n\nwir arbeiten wieder mit dem lexdec-Datensatz aus dem languageR-Paket (Baayen & Shafaei-Bajestan, 2019)\nwir speichern ihn als Objekt mit dem Namen df_lexdec\nwir wandeln auch die Variable RT um, so dass sie in Millisekunden angegeben wird (vorher war sie in log Millisekunden angegeben, aber machen Sie sich keine Gedanken darüber, was das bedeutet)\nund wir wählen 10 Variablen aus, die für uns heute relevant sind\n\n\n\ndf_lexdec &lt;- lexdec |&gt; \n  mutate(RT = exp(RT)) |&gt; \n  select(Subject, RT, Trial, Sex, NativeLanguage, Correct, Word, Frequency, Class, Length)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#data-wrangling",
    "href": "mats/04-wrangling_1.html#data-wrangling",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "4.2 Data Wrangling",
    "text": "4.2 Data Wrangling\n\nIm Englischen bezieht sich “wrangling” auf einen langen, schwierigen Prozess\n\n\nB. treiben Cowboys ihre Rinder oder Herden zusammen (sammeln, sammeln ihre Tiere)\n\n\nEs gibt zwei Hauptbestandteile des Wrangling\n\nTransformieren: Sortieren oder Erstellen neuer Variablen (was wir heute tun werden)\nAufräumen: Umformung oder Strukturierung Ihrer Daten (dies werden wir in einigen Wochen tun)\n\nSowohl das Aufräumen als auch das Transformieren von Daten erfordern das Paket dplyr aus dem tidyverse.\n\ndplyr Funktionen werden oft als Verben bezeichnet, weil sie etwas tun\n\n\n\n\n\n\n\n\nDer Name dplyr\n\n\n\n\nDer Name dplyr kommt von einem früheren Paket, plyr, das dazu verwendet wird, Daten zu zerlegen, Funktionen darauf anzuwenden und zu kombinieren\n\nIm Englischen klingt plyr wie das Wort für Zangen (“pliers”), die benutzt werden, um Dinge auseinander zu nehmen, wie das, was plyr mit Daten macht\ndas “d” in “dplyr” wurde hinzugefügt, weil das Paket speziell für die Arbeit mit Datenrahmen gedacht ist\n\n\n\n\n\n4.2.1 lexdec\n\nder lexdec-Datensatz enthält Daten für eine lexikalische Entscheidungsaufgabe im Englischen\n\nSchauen wir uns den Datensatz mit der Funktion head() an, die nur die ersten 6 Zeilen ausgibt\n\nhier geben wir die ersten 10 Zeilen aus\n\n\n\n\nIn meinen Materialien verwende ich oft die Funktion “head()”, um zu vermeiden, dass der gesamte Datensatz in der Ausgabe gedruckt wird, aber Sie würden im Allgemeinen nicht “head()” verwenden wollen, wenn Sie Ihre Daten betrachten, sondern Ihren gesamten Datensatz betrachten wollen\n\n\n\n\n\n\n\nAufgabe 4.1: df_lexdec\n\n\n\n\nBeispiel 4.1  \n\n\nBetrachten Sie den Datensatz\n\nwie viele Beobachtungen gibt es?\nWie viele Variablen gibt es?\n\nGeben Sie den Datensatz in die Funktion glimpse() ein.\n\nWas zeigt Ihnen das?\nWie sieht es im Vergleich zu dem aus, was Sie sehen, wenn Sie summary() verwenden?\n\n\n\n\n\n\n\n\n4.2.2 dplyr-Grundlagen\n\nheute lernen wir einige der wichtigsten dplyr-Verben (Funktionen) kennen, mit denen wir die meisten unserer Datenmanipulationsprobleme lösen können\n\nIch verwende diese Verben mehrfach in wahrscheinlich jedem Analyseskript\n\nDie dplyr-Verben haben einige Dinge gemeinsam:\n\ndas erste Argument ist immer ein Datenrahmen\ndie folgenden Argumente beschreiben in der Regel die zu bearbeitenden Spalten, wobei der Variablenname (ohne Anführungszeichen) verwendet wird\ndie Ausgabe ist immer ein neuer Datenrahmen\n\n\n\nDie Verben sind alle für eine Sache gut geeignet, so dass wir oft mehrere Verben auf einmal verwenden wollen.\n\nWir verwenden dazu die Pipe (|&gt; oder |&gt;)\nWir haben diese Pipe bereits gesehen, als wir einen Datenrahmen in ggplot() einspeisten.\nwir können die Pipe als und dann lesen\n\n\n\nIn dem folgenden Code identifizieren\n\nden Datenrahmen\ndplyr-Verben\nVariablennamen\n\nKannst du versuchen, herauszulesen (zu erraten), was der folgende Code macht?\n\n\ndf_lexdec |&gt; \n  filter(Subject == \"A1\") |&gt; \n  select(Subject, Trial, RT, NativeLanguage, Word) |&gt; \n  relocate(NativeLanguage, .after = Trial)\n\n\n\n\n\n\n\nKorrekte Syntax\n\n\n\n.Beachten Sie, dass A1 mit Anführungszeichen geschrieben wird, aber keiner der anderen Codes. Wenn wir ein Objekt (z.B. df_lexdec) oder seine Variablen (z.B. Subject) aufrufen, setzen wir sie nicht in Anführungszeichen. Wenn wir einen bestimmten Wert einer Variablen aufrufen, der nicht numerisch ist, müssen wir diesen Wert in Anführungszeichen setzen, weil die Subject ID A1 ein Wert der Variablen Subject ist, müssen wir sie in Anführungszeichen setzen.\nVersuchen Sie, die Anführungszeichen zu entfernen. Welche Fehlermeldung erhalten Sie?\nVersuchen Sie, einen Variablennamen in Anführungszeichen zu setzen, welche Fehlermeldung erhalten Sie?\nDies ist eine wichtige Übung, denn Sie werden oft feststellen, dass Ihr Code nicht läuft, aber die Lösung ist oft etwas so Einfaches wie fehlende oder zusätzliche Anführungszeichen oder Interpunktion.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#zeilen",
    "href": "mats/04-wrangling_1.html#zeilen",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "4.3 Zeilen",
    "text": "4.3 Zeilen\n\nIn aufgeräumten Daten stellen die Zeilen Beobachtungen dar.\ndie wichtigsten Verben für Zeilen sind:\n\nfilter(): ändert, welche Zeilen vorhanden sind\narrange(): ändert die Reihenfolge der Zeilen\n\nWir besprechen auch\n\ndistinct(): findet Zeilen mit unterschiedlichen Werten basierend auf einer Variablen (Spalte)\n\n\n\n4.3.1 filter()\n\nändert, welche Zeilen vorhanden sind, ohne ihre Reihenfolge zu ändern\nnimmt den Datenrahmen als erstes Argument\n\nDie folgenden Argumente sind Bedingungen, die TRUE sein müssen, damit die Zeile erhalten bleibt\n\n\n\nfindet alle Reaktionszeiten, die länger als 450 Millisekunden waren:\n\n\ndf_lexdec |&gt; \n  filter(RT &gt; 450) |&gt; \n  head()\n\n  Subject       RT Trial Sex NativeLanguage Correct       Word Frequency  Class\n1      A1 566.9998    23   F        English correct        owl  4.859812 animal\n2      A1 548.9998    27   F        English correct       mole  4.605170 animal\n3      A1 572.0000    29   F        English correct     cherry  4.997212  plant\n4      A1 486.0002    30   F        English correct       pear  4.727388  plant\n6      A1 483.0002    33   F        English correct blackberry  4.060443  plant\n8      A1 524.9999    38   F        English correct   squirrel  4.709530 animal\n  Length\n1      3\n2      4\n3      6\n4      4\n6     10\n8      8\n\n\n\nBeachten Sie, dass wir den Wert der Reaktionszeit nicht in Anführungszeichen setzen, da er numerisch ist\n\n\nwenn Sie die gefilterten Daten speichern wollen, ist es in der Regel ratsam, sie unter einem neuen Objektnamen zu speichern\n\nwenn Sie die vorgefilterte Version nicht überschreiben wollen, ist ein neuer Name erforderlich\n\n\n\ndf_lexdec_450 &lt;- \n  df_lexdec |&gt; \n  filter(RT &gt; 450)\n\n\n\n\n\n\n\nLogische Operatoren\n\n\n\n\n\nSymbole, die zur Beschreibung einer logischen Bedingung verwendet werden\n\n== ist identisch (1 == 1)\n!= ist nicht identisch (1 != 2)\n&gt; ist größer als (2 &gt; 1)\n&lt; ist kleiner als (1 &lt; 2)\n\num Bedingungen zu kombinieren\n\n& oder , und auch (für mehrere Bedingungen)\n| oder (für mehrere Bedingungen)\n\nes gibt eine nette Abkürzung für die Kombination von == und |: %in%\n\nbehält Zeilen, in denen die Variable gleich einem der Werte auf der rechten Seite ist\n\n\n\n== und |%in%\n\n\n\ndf_lexdec |&gt; \n  filter(Trial == 30 | Trial == 23) |&gt; \n  head()\n\n    Subject       RT Trial Sex NativeLanguage Correct    Word Frequency  Class\n1        A1 566.9998    23   F        English correct     owl  4.859812 animal\n4        A1 486.0002    30   F        English correct    pear  4.727388  plant\n475      A2 561.0001    23   M        English correct     dog  7.667626 animal\n949       C 688.0001    23   F        English correct vulture  4.248495 animal\n83        D 553.0000    30   M          Other correct  walnut  4.499810  plant\n317       J 824.0004    23   F          Other correct  beaver  3.951244 animal\n    Length\n1        3\n4        4\n475      3\n949      7\n83       6\n317      6\n\n\n\n\n\ndf_lexdec |&gt; \n  filter(Trial %in% c(30, 23)) |&gt; \n  head()\n\n    Subject       RT Trial Sex NativeLanguage Correct    Word Frequency  Class\n1        A1 566.9998    23   F        English correct     owl  4.859812 animal\n4        A1 486.0002    30   F        English correct    pear  4.727388  plant\n475      A2 561.0001    23   M        English correct     dog  7.667626 animal\n949       C 688.0001    23   F        English correct vulture  4.248495 animal\n83        D 553.0000    30   M          Other correct  walnut  4.499810  plant\n317       J 824.0004    23   F          Other correct  beaver  3.951244 animal\n    Length\n1        3\n4        4\n475      3\n949      7\n83       6\n317      6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAufgabe 4.2: filter()\n\n\n\n\nBeispiel 4.2  \n\n\nFiltern Sie die Daten, um Zeilen aus Trial 25 und Nicht-Muttersprachler (Other) einzuschließen.\nWie viele Zeilen gibt es?\n\n\n\n\n\n\n\n4.3.2 arrange()\n\nändert die Reihenfolge der Zeilen auf der Grundlage eines Wertes in einer oder mehreren Spalten\n\n\ndf_lexdec |&gt; \n  arrange(RT) |&gt; \n  head()\n\n     Subject       RT Trial Sex NativeLanguage   Correct    Word Frequency\n542       A2 340.0001   159   M        English incorrect     pig  6.660575\n815        K 347.9998    83   F        English incorrect   lemon  5.631212\n822        K 363.0001    99   F        English incorrect  potato  6.461468\n73        A1 364.9999   174   F        English   correct chicken  6.599870\n524       A2 365.9999   117   M        English   correct   goose  5.267858\n1516       I 367.0001    51   F          Other   correct  carrot  4.976734\n      Class Length\n542  animal      3\n815   plant      5\n822   plant      6\n73   animal      7\n524  animal      5\n1516  plant      6\n\n\n\nwenn Sie mehr als einen Spaltennamen verwenden, wird jede zusätzliche Spalte verwendet, um die Verbindung zwischen den Werten der vorangegangenen Spalten zu lösen\n\n\ndf_lexdec |&gt; \n  arrange(Length,Sex) |&gt; \n  head(10)\n\n    Subject       RT Trial Sex NativeLanguage   Correct Word Frequency  Class\n1        A1 566.9998    23   F        English   correct  owl  4.859812 animal\n5        A1 414.0000    32   F        English   correct  dog  7.667626 animal\n15       A1 556.9999    53   F        English   correct  bee  5.700444 animal\n20       A1 456.9998    61   F        English incorrect  bat  5.918894 animal\n31       A1 581.9997    88   F        English   correct  fox  5.652489 animal\n44       A1 494.0002   113   F        English   correct  pig  6.660575 animal\n62       A1 467.9999   152   F        English   correct  cat  7.086738 animal\n64       A1 875.9999   157   F        English   correct  ant  5.347108 animal\n719      A3 607.0001    41   F          Other   correct  ant  5.347108 animal\n720      A3 562.0001    44   F          Other   correct  pig  6.660575 animal\n    Length\n1        3\n5        3\n15       3\n20       3\n31       3\n44       3\n62       3\n64       3\n719      3\n720      3\n\n\n\nwir können desc() innerhalb von arrange() hinzufügen, um eine absteigende Reihenfolge (groß-klein) anstelle der standardmäßigen aufsteigenden Reihenfolge zu verwenden\n\n\ndf_lexdec |&gt; \n  arrange(desc(Length)) |&gt; \n  head()\n\n    Subject       RT Trial Sex NativeLanguage Correct       Word Frequency\n6        A1 483.0002    33   F        English correct blackberry  4.060443\n7        A1 417.9998    34   F        English correct strawberry  4.753590\n69       A1 540.9998   168   F        English correct woodpecker  2.890372\n505      A2 503.9999    87   M        English correct woodpecker  2.890372\n516      A2 400.9998   105   M        English correct strawberry  4.753590\n518      A2 517.0001   108   M        English correct blackberry  4.060443\n     Class Length\n6    plant     10\n7    plant     10\n69  animal     10\n505 animal     10\n516  plant     10\n518  plant     10\n\n\n\n\n\n\n\n\nAufgabe 4.3: arrange()\n\n\n\n\nBeispiel 4.3  \n\n\nFiltere die Daten so, dass sie nur Beobachtungen der “Probanden” M1 und W2 enthalten, und dann\nOrdnen Sie die Daten nach absteigender Reaktionszeit",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#spalten",
    "href": "mats/04-wrangling_1.html#spalten",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "4.4 Spalten",
    "text": "4.4 Spalten\n\nIn Tidy Data stellen die Spalten Variablen dar.\ndie wichtigsten Verben für Spalten sind:\n\nrename(): ändert die Namen der Spalten\nmutate(): erzeugt neue Spalten, die von den vorhandenen Spalten abgeleitet werden\nselect(): ändert, welche Spalten vorhanden sind\nrelocate(): ändert die Position der Spalten\n\n\n\n4.4.1 rename()\n\nMit rename() können wir den Namen von Spalten ändern\n\ndie Reihenfolge der Argumente ist neuer_name = alter_name\n\nVersuchen wir, einige der Variablennamen auf Deutsch zu ändern\n\nIch neige dazu, Variablennamen in Kleinbuchstaben zu schreiben, als Kodierungskonvention\n\n\n\n## single variable\ndf_lexdec &lt;- \n  df_lexdec |&gt;\n  rename(teilnehmer = Subject)\n\n\n## or multiple variables at once\ndf_lexdec &lt;- \n  df_lexdec |&gt; \n rename(rz_ms = RT,\n        geschlect = Sex,\n        laenge = Length)\n\n\n\n4.4.2 mutate()\n\nMit mutate() werden neue Spalten aus vorhandenen Spalten erzeugt.\n\nSo können wir z.B. einfache Algebra mit den Werten in jeder Spalte durchführen\n\n\n\ndf_lexdec |&gt; \n  mutate(\n    rz_laenge = rz_ms / laenge,\n  ) |&gt; \n  head()\n\n  teilnehmer    rz_ms Trial geschlect NativeLanguage Correct       Word\n1         A1 566.9998    23         F        English correct        owl\n2         A1 548.9998    27         F        English correct       mole\n3         A1 572.0000    29         F        English correct     cherry\n4         A1 486.0002    30         F        English correct       pear\n5         A1 414.0000    32         F        English correct        dog\n6         A1 483.0002    33         F        English correct blackberry\n  Frequency  Class laenge rz_laenge\n1  4.859812 animal      3 188.99994\n2  4.605170 animal      4 137.24994\n3  4.997212  plant      6  95.33333\n4  4.727388  plant      4 121.50005\n5  7.667626 animal      3 138.00000\n6  4.060443  plant     10  48.30002\n\n\n\nMit mutate() werden diese neuen Spalten auf der rechten Seite des Datensatzes hinzugefügt.\n\nDas macht es schwierig zu sehen, was passiert.\n\num zu kontrollieren, wo die neue Spalte hinzugefügt wird, können wir .before oder .after verwenden\n\n\ndf_lexdec |&gt; \n  mutate(\n    rz_laenge = rz_ms / laenge,\n    .after = rz_ms\n  ) |&gt; \n  head()\n\n  teilnehmer    rz_ms rz_laenge Trial geschlect NativeLanguage Correct\n1         A1 566.9998 188.99994    23         F        English correct\n2         A1 548.9998 137.24994    27         F        English correct\n3         A1 572.0000  95.33333    29         F        English correct\n4         A1 486.0002 121.50005    30         F        English correct\n5         A1 414.0000 138.00000    32         F        English correct\n6         A1 483.0002  48.30002    33         F        English correct\n        Word Frequency  Class laenge\n1        owl  4.859812 animal      3\n2       mole  4.605170 animal      4\n3     cherry  4.997212  plant      6\n4       pear  4.727388  plant      4\n5        dog  7.667626 animal      3\n6 blackberry  4.060443  plant     10\n\n\n\n\n\n\n\n\nRendernpause!\n\n\n\n\nNehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wird es gerendert?\nKönnen Sie das Dokument besser strukturieren? Z. B. durch Hinzufügen von mehr Überschriften, Text?\n\n\n\n\n\n\n\n\n\nAufgabe 4.4: mutate()\n\n\n\n\nBeispiel 4.4  \n\n\nErstellen Sie eine neue Variable namens rz_s in df_lexdec, die:\n\nentspricht rz_ms geteilt durch 1000 (d.h. wandelt Millisekunden in Sekunden um)\nerscheint nach rz_ms. Rendern Sie Ihr Dokument\n\n\n\n\n\n\n\n\n4.4.3 select()\n\nselect() fasst die Daten so zusammen, dass sie nur die gewünschten Spalten enthalten\nSpalten nach Namen auswählen\n\n\ndf_lexdec |&gt; \n  select(teilnehmer, rz_ms, Word) |&gt; \n  head()\n\n  teilnehmer    rz_ms       Word\n1         A1 566.9998        owl\n2         A1 548.9998       mole\n3         A1 572.0000     cherry\n4         A1 486.0002       pear\n5         A1 414.0000        dog\n6         A1 483.0002 blackberry\n\n\n\nselect alle Spalten zwischen rz_ms und geschlecht\n\n\ndf_lexdec |&gt; \n  select(rz_ms:geschlect) |&gt; \n  head()\n\n     rz_ms      rz_s Trial geschlect\n1 566.9998 0.5669998    23         F\n2 548.9998 0.5489998    27         F\n3 572.0000 0.5720000    29         F\n4 486.0002 0.4860002    30         F\n5 414.0000 0.4140000    32         F\n6 483.0002 0.4830002    33         F\n\n\n\nalle Spalten außer rz_s auswählen (! wird als “nicht” gelesen)\n\n\ndf_lexdec |&gt; \n  select(!rz_s) |&gt; \n  head()\n\n  teilnehmer    rz_ms Trial geschlect NativeLanguage Correct       Word\n1         A1 566.9998    23         F        English correct        owl\n2         A1 548.9998    27         F        English correct       mole\n3         A1 572.0000    29         F        English correct     cherry\n4         A1 486.0002    30         F        English correct       pear\n5         A1 414.0000    32         F        English correct        dog\n6         A1 483.0002    33         F        English correct blackberry\n  Frequency  Class laenge\n1  4.859812 animal      3\n2  4.605170 animal      4\n3  4.997212  plant      6\n4  4.727388  plant      4\n5  7.667626 animal      3\n6  4.060443  plant     10\n\n\n\n4.4.3.1 select()-Hilfsfunktionen\n\neinige Hilfsfunktionen, die das Leben bei der Arbeit mit select() erleichtern:\n\nstarts_with(\"abc\"): wählt Spalten aus, die mit einer bestimmten Zeichenkette beginnen\nends_with(\"xyz\"): wählt Spalten aus, die mit einer bestimmten Zeichenkette enden\ncontains(\"ijk\"): wählt Spalten aus, die eine bestimmte Zeichenkette enthalten\nwhere(is.character): wählt Spalten aus, die einem logischen Kriterium entsprechen\n\nz.B. gibt die Funktion is.character() den Wert TRUE zurück, wenn eine Variable Zeichenketten enthält, nicht numerische Werte oder Kategorien\n\n\n\n\n\n\ndf_lexdec |&gt; \n  select(starts_with(\"w\")) |&gt; \n  head()\n\n        Word\n1        owl\n2       mole\n3     cherry\n4       pear\n5        dog\n6 blackberry\n\n\n\n\ndf_lexdec |&gt; \n  select(ends_with(\"er\")) |&gt; \n  head()\n\n  teilnehmer\n1         A1\n2         A1\n3         A1\n4         A1\n5         A1\n6         A1\n\n\n\n\n\n\n\n\n\n\nAufgabe 4.5: select()\n\n\n\n\nBeispiel 4.5  \n\n\nDrucke die Spalten in df_lexdec, die mit “t” beginnen\nDrucke die Spalten in df_lexdec, die “ge” enthalten\nDrucke die Spalten in df_lexdec, die\n\nmit mit “r” beginnen, und\nmit “s” enden\n\n\n\n\n\n\n\n\n\n4.4.4 relocate()\n\nrelocate() verschiebt Variablen\n\nstandardmäßig werden sie nach vorne verschoben\n\n\n\ndf_lexdec |&gt; relocate(Trial) |&gt; \n  head()\n\n  Trial teilnehmer    rz_ms      rz_s geschlect NativeLanguage Correct\n1    23         A1 566.9998 0.5669998         F        English correct\n2    27         A1 548.9998 0.5489998         F        English correct\n3    29         A1 572.0000 0.5720000         F        English correct\n4    30         A1 486.0002 0.4860002         F        English correct\n5    32         A1 414.0000 0.4140000         F        English correct\n6    33         A1 483.0002 0.4830002         F        English correct\n        Word Frequency  Class laenge\n1        owl  4.859812 animal      3\n2       mole  4.605170 animal      4\n3     cherry  4.997212  plant      6\n4       pear  4.727388  plant      4\n5        dog  7.667626 animal      3\n6 blackberry  4.060443  plant     10\n\n\n\naber wir können auch .before oder .after verwenden, um eine Variable zu platzieren\n\n\ndf_lexdec |&gt; \n  relocate(Trial, .after = teilnehmer) |&gt; \n  head()\n\n  teilnehmer Trial    rz_ms      rz_s geschlect NativeLanguage Correct\n1         A1    23 566.9998 0.5669998         F        English correct\n2         A1    27 548.9998 0.5489998         F        English correct\n3         A1    29 572.0000 0.5720000         F        English correct\n4         A1    30 486.0002 0.4860002         F        English correct\n5         A1    32 414.0000 0.4140000         F        English correct\n6         A1    33 483.0002 0.4830002         F        English correct\n        Word Frequency  Class laenge\n1        owl  4.859812 animal      3\n2       mole  4.605170 animal      4\n3     cherry  4.997212  plant      6\n4       pear  4.727388  plant      4\n5        dog  7.667626 animal      3\n6 blackberry  4.060443  plant     10",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#dplyr-und-ggplot2",
    "href": "mats/04-wrangling_1.html#dplyr-und-ggplot2",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "4.5 dplyr und ggplot2",
    "text": "4.5 dplyr und ggplot2\n\nwir können einen Datensatz mit den dplyr-Verben ändern und diese Änderungen dann in ggplot2 einspeisen\nWas wird der folgende Code ergeben?\n\n\ndf_lexdec |&gt; \n  ## filter the data\n  filter(rz_ms &gt; 120,\n         rz_ms &lt; 500) |&gt; \n  ## plot the filtered data\n  ggplot(aes(x = rz_ms, fill = Correct)) +\n  geom_histogram() +\n  theme_minimal()\n\n\n4.5.1 Pipe versus plus (|&gt; vs. +)\n\nwichtig: wir können Pipes (|&gt;) verwenden, um zusätzliche Verben/Funktionen mit dem Ergebnis einer vorherigen Codezeile auszuführen\n\nDie Funktion ggplot() verwendet jedoch +, um neue Ebenen zur Darstellung hinzuzufügen\n\n\n\n\n\n\n\n\nRendernpause!\n\n\n\n\nNehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wird es gerendert?\nKönnen Sie das Dokument besser strukturieren? Z. B. durch Hinzufügen von mehr Überschriften, Text?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#weitere-übungen",
    "href": "mats/04-wrangling_1.html#weitere-übungen",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.4.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#heutige-ziele-1",
    "href": "mats/04-wrangling_1.html#heutige-ziele-1",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "Heutige Ziele 🏁",
    "text": "Heutige Ziele 🏁\nHeute haben wir gelernt…\n\nwie man Daten mit dem Paket dplyr aus dem tidyverse verarbeitet ✅\nwie man die pipe (|&gt;) verwendet, um das Ergebnis einer Funktion in eine andere Funktion einzuspeisen ✅\nüber Funktionen, die auf Zeilen operieren ✅\nüber Funktionen, die auf Spalten operieren ✅\nwie man dplyr-Funktionen mit Plots von ggplot2 kombiniert ✅",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/04-wrangling_1.html#session-info",
    "href": "mats/04-wrangling_1.html#session-info",
    "title": "4  Data Wrangling 1: Transformation",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] languageR_1.5.0 lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1  \n [5] dplyr_1.1.4     purrr_1.0.2     readr_2.1.5     tidyr_1.3.1    \n [9] tibble_3.2.1    ggplot2_3.5.1   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5      jsonlite_1.8.8    compiler_4.4.0    renv_1.0.7       \n [5] tidyselect_1.2.1  scales_1.3.0      yaml_2.3.8        fastmap_1.1.1    \n [9] R6_2.5.1          generics_0.1.3    knitr_1.46        htmlwidgets_1.6.4\n[13] munsell_0.5.1     pillar_1.9.0      tzdb_0.4.0        rlang_1.1.3      \n[17] utf8_1.2.4        stringi_1.8.3     xfun_0.43         timechange_0.3.0 \n[21] cli_3.6.2         withr_3.0.0       magrittr_2.0.3    digest_0.6.35    \n[25] grid_4.4.0        rstudioapi_0.16.0 hms_1.1.3         lifecycle_1.0.4  \n[29] vctrs_0.6.5       evaluate_0.23     glue_1.7.0        fansi_1.0.6      \n[33] colorspace_2.1-0  rmarkdown_2.26    tools_4.4.0       pkgconfig_2.0.3  \n[37] htmltools_0.5.8.1\n\n\n\n\n\n\n\n\nBaayen, R. H., & Shafaei-Bajestan, E. (2019). languageR: Analyzing Linguistic Data: A Practical Introduction to Statistics. https://CRAN.R-project.org/package=languageR\n\n\nNordmann, E., & DeBruine, L. (2022). Applied Data Skills. Zenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling 1: Transformation</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html",
    "href": "mats/05-dataviz_2.html",
    "title": "5  Datenvisualisierung 2",
    "section": "",
    "text": "Lesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kap. 2 (Datenvisualisierung) aus Abschnitt 2.5 in Wickham et al. (2023).\nEine ergänzende Lektüre ist Ch. 3 (Data visualtion) in Nordmann & DeBruine (2022).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#wiederholung",
    "href": "mats/05-dataviz_2.html#wiederholung",
    "title": "5  Datenvisualisierung 2",
    "section": "Wiederholung",
    "text": "Wiederholung\nLetzte Woche haben wir gelernt…\n\nwie man Daten mit dem Paket dplyr aus dem tidyverse verarbeitet\ngelernt, wie man die pipe (|&gt;) verwendet, um das Ergebnis einer Funktion in eine andere Funktion einzuspeisen\nüber Funktionen, die auf Zeilen operieren\n\nfilter(), arrange()\n\nüber Funktionen, die auf Spalten operieren\n\nrename(), mutate(), select(), relocate()\n\nwie man dplyr-Funktionen mit Plots von ggplot2 kombiniert",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#lernziele",
    "href": "mats/05-dataviz_2.html#lernziele",
    "title": "5  Datenvisualisierung 2",
    "section": "Lernziele",
    "text": "Lernziele\nHeute werden wir lernen…\n\nwie man zwei oder mehr Variablen darstellt\n\nmit Ästhetik und mit Facettenrastern\n\nwie man Codechunk-Optionen verwendet\nwie man Plots als Dateien speichert\n\n\nLesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kap. 2 (Datenvisualisierung) aus Abschnitt 2.5 in Wickham et al. (2023).\nEine ergänzende Lektüre ist Ch. 3 (Data visualtion) in Nordmann & DeBruine (2022).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#sec-dataviz2-setup",
    "href": "mats/05-dataviz_2.html#sec-dataviz2-setup",
    "title": "5  Datenvisualisierung 2",
    "section": "5.1 Einrichtung {.unnumbered}",
    "text": "5.1 Einrichtung {.unnumbered}\n\nPackages\n\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(ggthemes)\nlibrary(languageR)\n\n\ntidyverse Familie von Paketen\n\nggplot2 für Diagramme\ndplyr für die Datenverarbeitung\n\nggthemes für farbenblindenfreundliche Farbpaletten\npatchwork für Plot-Layouts\nlanguageR für linguistische Datensätze\n\n\n\nggplot theme\nIch habe mein bevorzugtes ggplot-Thema global festgelegt. Das bedeutet, dass nach dem Ausführen dieses Codes alle Diagramme dieses Thema verwenden werden.\n\ntheme_set(theme_bw())\n\n\n\nData\nWir verwenden den english-Datensatz aus dem Baayen & Shafaei-Bajestan (2019).\n\nenthält Daten aus einer lexikalischen Entscheidungsaufgabe in Englisch\nDie logarithmisch transformierten Reaktionszeiten werden zurücktransformiert, so dass sie in Millisekunden angegeben werden.\n\nWir verwenden dazu die Funktion exp().\n\n\n\ndf_english &lt;- \n  english |&gt; \n  mutate(RTlexdec = exp(RTlexdec),\n         RTnaming = exp(RTnaming))\n\n\nenglish dataset\nUnsere Variablen von Interesse sind:\n\n\n\n\nTabelle 5.1: english dataset variables of interest\n\n\n\n\n\n\n\nvariable\ndescription\ntype\n\n\n\n\nRTlexdec\nReaktionszeiten für eine visuelle lexikalische Entscheidung (Millisekunden)\nkontinuierlich\n\n\nRTnaming\nReaktionszeiten für den Beginn einer verbalen Wortbenennungsaufgabe (Millisekunden)\nkontinuierlich\n\n\nWrittenFrequency\nnumerischer Vektor mit der logarithmischen Häufigkeit in der lexikalischen Datenbank von CELEX\nkontinuierlich\n\n\nWort\nein Faktor mit 2284 Wörtern\nkategorisch\n\n\nAgeSubject\nein Faktor mit der Altersgruppe des Probanden als Level: jung versus alt\nkategorisch\n\n\nWordCategory\nein Faktor mit den Wortkategorien N (Substantiv) und V (Verb) als Ebenen\nkategorisch\n\n\nCV\nFaktor, der angibt, ob das Anfangsphonem des Wortes ein Konsonant (C) oder ein Vokal (V) ist.\nkategorisch\n\n\nCorrectLexdec\nnumerischer Vektor mit dem Anteil der Probanden, die das Item bei der lexikalischen Entscheidung als Wort akzeptiert haben.\nkontinuierlich\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHypotheses\n\nWelche Arten von Hypothesen könnten Sie für solche Daten aufstellen?\n\nUnsere Reaktionszeitdaten sind unsere Messvariablen.\n\nd.h. das, was wir messen\n\nAlle anderen Variablen sind mögliche Vorhersagevariablen.\n\nd.h. wir könnten vorhersagen, dass ihr Wert unsere Messvariablen beeinflussen würde\n\n\nWelche Auswirkung (wenn überhaupt) könnte zum Beispiel die Worthäufigkeit auf die Reaktionszeiten bei lexikalischen Entscheidungsaufgaben haben? auf die Benennungszeiten?\n\nWie sieht es mit Unterschieden in den Reaktionszeiten zwischen jüngeren und älteren Teilnehmern aus?\n\nWelchen Effekt (wenn überhaupt) könnte die Wortkategorie auf die Reaktionszeiten haben?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#datenvisualisierung",
    "href": "mats/05-dataviz_2.html#datenvisualisierung",
    "title": "5  Datenvisualisierung 2",
    "section": "5.2 Datenvisualisierung",
    "text": "5.2 Datenvisualisierung\n\nDie Visualisierung unserer Daten hilft uns, die Beziehung zwischen den Variablen zu veranschaulichen, um eine Geschichte zu erzählen.\nIn der Regel visualisieren wir Variablen, für die wir eine bestimmte Hypothese haben: Prädiktor- und Messvariable(n)\n\n\n5.2.1 Visualisierung von Verteilungen\n\nHistogramme, Dichtediagramme und Balkendiagramme für Zählwerte visualisieren die Verteilung von Beobachtungen\n\nSie geben Aufschluss darüber, wie oft wir bestimmte Werte einer Variablen beobachtet haben.\nIn der Regel tun wir dies, um ein Gefühl dafür zu bekommen, wie unsere Daten aussehen\n\nWas ist der Bereich unserer Daten, der Modus, die Gesamtverteilung der Werte?\n\n\n\n\n\n\n\n\n\nAufgabe: Beziehungen visualisieren\n\n\n\n\nErstellen Sie ein Diagramm, das die Verteilung der Häufigkeit der geschriebenen Wörter visualisiert.\nErstellen Sie ein Diagramm, das die Verteilung von Substantiven und Verben visualisiert.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#visualisierung-von-beziehungen",
    "href": "mats/05-dataviz_2.html#visualisierung-von-beziehungen",
    "title": "5  Datenvisualisierung 2",
    "section": "5.3 Visualisierung von Beziehungen",
    "text": "5.3 Visualisierung von Beziehungen\n\nUm Beziehungen zwischen Variablen zu visualisieren, müssen wir mindestens zwei Variablen auf die Ästhetik eines Diagramms abbilden\nWir haben dies bereits getan, indem wir Farbe oder Füllung einer kategorischen Variable zugeordnet haben, während wir eine\n\neine kontinuierliche Variable auf die x-Achse für Histogramme/Dichte-Diagramme, oder\neine kategoriale Variable auf die y-Achse für ein Balkendiagramm\n\n\n\n\n\n\n\n\nAufgabe: Visualisierung von Beziehungen in Verteilungen\n\n\n\n\nFügen Sie den soeben erstellten Diagrammen eine weitere Ästhetik hinzu, um sie darzustellen:\n\ndie Verteilung der WrittenFrequency-Werte für Wörter mit Anfangskonsonanten und Vokalen\ndie Verteilung der Substantive und Verben für Wörter mit Anfangskonsonanten und Vokalen\n\n\n\n\n\n5.3.1 Gruppierte kontinuierliche Variable\n\nUnsere Histogramme, Dichtediagramme und Balkendiagramme zeigen die Verteilung der Werte einer kontinuierlichen Variable nach verschiedenen Stufen einer kategorischen Variable\n\n\n5.3.1.1 Gestapelt\n\nBeachten Sie, dass diese Kategorien standardmäßig übereinander gestapelt sind.\n\n\n\n\n\n\n\n\n\nAbbildung 5.1: Visualising relationships in distributions\n\n\n\n\n\n\n\n5.3.1.2 Dodged (Ausgewiche)\n\naber dass wir sie nebeneinander haben können, indem wir identity auf dodge setzen\n\nIch finde, dass dies für Balkenplots nützlicher ist\n\n\n\n\n\n\n\n\n\n\nAbbildung 5.2: Visualising relationships in distributions\n\n\n\n\n\n\n\n\n5.3.2 Zwei kontinuierliche Variablen\n\nWir wollen oft die Auswirkungen einer kontinuierlichen Variable auf eine andere sehen.\nIn unserem Datensatz english haben wir zum Beispiel die Variablen WrittenFreuqency und RTlexdec\n\nWelche Art von Beziehung werden diese beiden Variablen Ihrer Meinung nach haben?\nDenken Sie z.B., dass Wörter mit einer niedrigeren WrittenFrequency in einer lexikalischen Entscheidungsaufgabe tendenziell längere oder kürzere Reaktionszeiten haben werden?\nWie könnte man sich eine solche Beziehung vorstellen?\n\n\n\n\n\n\n## + geom_?\ndf_english |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec) \n\n\n\n\n\n\n\n\n\n\n\n\ndf_english |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nNehmen Sie sich einen Moment Zeit, um diese Grafik zu betrachten und eine Interpretation zu finden\n\nWelchen Einfluss hat die Schrifthäufigkeit eines Wortes auf die Reaktionszeit bei einer lexikalischen Entscheidungsaufgabe?\nVervollständigen Sie den Satz: “Wörter mit einer höheren Worthäufigkeit lösten ___________ Reaktionszeiten aus”\n\nWo gab es mehr Variation in den Reaktionszeiten? Wo gab es weniger Variation?\n\n\n\n5.3.3 Hinzufügen weiterer Variablen\n\nErinnern Sie sich daran, dass wir andere Ästhetiken wie fill oder colour verwenden können\n\nfür geom_point() ist es auch hilfreich, shape zu verwenden\n\n\n\ndf_english |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nIn der Mitte des Diagramms gibt es viele Überschneidungen.\n\nWie können wir die Deckkraft der Punkte ändern?\n\n\n\ndf_english |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  geom_point(alpha = .5)\n\n\n\n\n\n\n\n\n\nden Zusammenhang zwischen Altersgruppe und Reaktionszeit beschreiben\n\n\n\n\n\n\n\nAufgabe 5.1: Adding another variable\n\n\n\n\nBeispiel 5.1  \n\nWie könnten Sie eine vierte Variable in die obige Darstellung einfügen? Versuchen Sie, CV hinzuzufügen. Ergibt die Darstellung immer noch eine klare Geschichte?\n\n\n\n\n\n\n5.3.4 Facet grids\n\nWenn Sie mehr als drei Variablen darstellen wollen, ist es im Allgemeinen eine gute Idee, kategorische Variablen in Facetten aufzuteilen.\n\nFacetten sind Teilplots, die Teilmengen der Daten anzeigen\n\nwir können facet_wrap() verwenden, das eine Formel als Argument annimmt\n\nDiese Formel enthält ~ und den Namen einer kategorialen Variable, z. B. ~CV\n\n\n\n\n\n\n## + geom_?\ndf_english |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  facet_wrap(~CV) \n\n\n\n\n\n\n\n\n\n\n\n\ndf_english |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  facet_wrap(~CV) +\n  geom_point(alpha = .5)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#bearbeitete-daten",
    "href": "mats/05-dataviz_2.html#bearbeitete-daten",
    "title": "5  Datenvisualisierung 2",
    "section": "5.4 Bearbeitete Daten",
    "text": "5.4 Bearbeitete Daten\n\nWir können unsere Daten auch bearbeiten, bevor wir sie in ggplot() eingeben.\n\nDies ist nützlich, wenn wir keine permanenten Änderungen an den Daten vornehmen wollen, sondern nur eine Teilmenge der Daten darstellen wollen\n\nVielleicht wollen wir nur die Wörter betrachten, die mit einem Vokal beginnen. Wie könnten wir das mit einem dplyr-Verb machen?\n\n\n\n\ndf_english |&gt; \n  filter(CV == \"V\") |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAufgabe 5.2: Plot-Anmerkung\n\n\n\n\nBeispiel 5.2  \n\n\nVergessen Sie nicht, Ihre Diagramme mit nützlichen Beschriftungen zu versehen, um dem Leser die Interpretation des Diagramms zu erleichtern\nFügen wir einen Titel und Beschriftungen für die x- und y-Achse hinzu\n\n\ndf_english |&gt; \n  filter(CV == \"V\") |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  labs(title = \"WrittenFrequency scores by reaction time\",\n       x = \"WrittenFrequency score\",\n       y = \"Reaction time (ms)\",\n       colour = \"Age group\",\n       shape = \"Age group\") +\n  geom_point()",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#quarto-code-chunk-einstellungen",
    "href": "mats/05-dataviz_2.html#quarto-code-chunk-einstellungen",
    "title": "5  Datenvisualisierung 2",
    "section": "5.5 Quarto Code Chunk Einstellungen",
    "text": "5.5 Quarto Code Chunk Einstellungen\n\nlange Codeabschnitte können zu sehr unübersichtlichen Ausgabedokumenten führen\nnormalerweise ist nur die Darstellung für den Leser wichtig, nicht der Code, der sie erzeugt hat\nwir können die Darstellung und Auswertung von Code Chunks durch Code Chunk Optionen steuern\n\ndiese beginnen mit #|\nund befinden sich direkt unter ```{r}```\n\n\n\nwichtige Code-Chunk-Optionen:\n\n\n\n\n\nTabelle 5.2: Most common chunk options\n\n\n\n\n\n\n\noption\nvalues\nfunction\n\n\n\n\n#&#124; echo:\ntrue/false\nshould this code chunk be printed when rendering?\n\n\n#&#124; eval:\ntrue/false\nshould this code chunk be run when rendering?\n\n\n\n\n\n\n\n\n\n\n\n\n5.5.1 Verwendung von Code-Bausteinen\n\nwarum sehen wir das Ergebnis dieser Darstellung nicht?\n\n\n```{r}\n#| eval: false\ndf_english |&gt; \n  ggplot() +\n  aes(x = RTlexdec, y = RTnaming,\n      colour = AgeSubject,\n      shape = AgeSubject) +\n  geom_point()\n```",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#plots-speichern",
    "href": "mats/05-dataviz_2.html#plots-speichern",
    "title": "5  Datenvisualisierung 2",
    "section": "5.6 Plots speichern",
    "text": "5.6 Plots speichern\n\noft wollen wir unsere Plots in einem Dokument verwenden, das nicht in RStudio erstellt wurde\n\nzum Beispiel in einer Dissertation oder einem in LaTeX geschriebenen Papier\n\num dies zu tun, müssen wir unsere Zahlen als einen akzeptierten Dateityp laden, wie jpeg oder png\nDas können wir mit der Funktion ggsave() machen.\nKönnen Sie erraten, welche Arten von Argumenten ggsave() benötigt, um unsere Diagramme zu speichern? Einige sind erforderlich, einige sind optional.\n\n\n5.6.1 ggsave()\nAls Minimum benötigt ggsave() Argumente:\n\nden Namen des Plots in Ihrer Umgebung, den Sie speichern möchten\nden Dateinamen, unter dem Sie Ihre Darstellung speichern möchten\n\nEs ist eine gute Idee, einen Ordner zu erstellen, in dem Sie Ihre Plots speichern, und den Dateipfad in den Namen aufzunehmen\n\n\n\n5.6.1.1 ggsave() optionale Argumente\n\neinige optionale Argumente sind:\n\nwidth = wie breit soll der Plot in cm, mm, Zoll oder Pixel sein?\nheight = wie hoch soll der gespeichert Plot in cm, mm, Zoll oder Pixel sein?\ndpi = gewünschte Auflösung (numerisch, oder eine Reihe von Strings: “retina” = 320, “print” = 300 oder “screen” = 72)\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nSetzen Sie Code-Chunks, die Dateien auf Ihrem Rechner speichern, immer auf eval: false!!! Andernfalls wird jedes Mal, wenn Sie Ihr Skript ausführen, die Datei lokal neu geschrieben.\n\n\n\n\n\n\n\n\nAufgabe 5.3: ggsave()\n\n\n\n\nBeispiel 5.3  \n\n\nKopieren Sie den unten stehenden Code in einen Codechunk und führen Sie ihn aus. Schauen Sie sich Ihre “Files”-Tab an, was hat sich geändert?\n\n\n```{r}\n#| eval: false\nggsave(\n  ## required:\n  \"figures/04-dataviz2/fig_lexdec_rt.png\", \n  plot = fig_lexdec_rt,\n  ## optional:\n  width = 2000,\n  height = 1000,\n  units = \"px\",\n  scale = 1,\n  dpi = \"print\")\n```\n\n\nVersuchen Sie, mit dem Maßstab und den dpi zu spielen. Was ändert sich?\nVersuchen Sie, die Werte für Einheiten, Breite und Höhe zu ändern. Was ändert sich?",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#weitere-übungen",
    "href": "mats/05-dataviz_2.html#weitere-übungen",
    "title": "5  Datenvisualisierung 2",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.5.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/05-dataviz_2.html#session-info",
    "href": "mats/05-dataviz_2.html#session-info",
    "title": "5  Datenvisualisierung 2",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] kableExtra_1.4.0 knitr_1.46       languageR_1.5.0  ggthemes_5.1.0  \n [5] patchwork_1.2.0  lubridate_1.9.3  forcats_1.0.0    stringr_1.5.1   \n [9] dplyr_1.1.4      purrr_1.0.2      readr_2.1.5      tidyr_1.3.1     \n[13] tibble_3.2.1     ggplot2_3.5.1    tidyverse_2.0.0 \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        xml2_1.3.6       \n [5] stringi_1.8.3     hms_1.1.3         digest_0.6.35     magrittr_2.0.3   \n [9] evaluate_0.23     grid_4.4.0        timechange_0.3.0  fastmap_1.1.1    \n[13] jsonlite_1.8.8    fansi_1.0.6       viridisLite_0.4.2 scales_1.3.0     \n[17] cli_3.6.2         rlang_1.1.3       munsell_0.5.1     withr_3.0.0      \n[21] yaml_2.3.8        tools_4.4.0       tzdb_0.4.0        colorspace_2.1-0 \n[25] pacman_0.5.1      vctrs_0.6.5       R6_2.5.1          lifecycle_1.0.4  \n[29] htmlwidgets_1.6.4 pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.5     \n[33] glue_1.7.0        systemfonts_1.0.6 highr_0.10        xfun_0.43        \n[37] tidyselect_1.2.1  rstudioapi_0.16.0 farver_2.1.1      htmltools_0.5.8.1\n[41] labeling_0.4.3    rmarkdown_2.26    svglite_2.1.3     compiler_4.4.0   \n\n\n\n\n\n\n\n\nBaayen, R. H., & Shafaei-Bajestan, E. (2019). languageR: Analyzing Linguistic Data: A Practical Introduction to Statistics. https://CRAN.R-project.org/package=languageR\n\n\nNordmann, E., & DeBruine, L. (2022). Applied Data Skills. Zenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenvisualisierung 2</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html",
    "href": "mats/07-dateneinlesung.html",
    "title": "6  Einlesen von Daten",
    "section": "",
    "text": "Lernziele\nIn diesem Kapitel werden wir lernen, wie man:",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#lernziele",
    "href": "mats/07-dateneinlesung.html#lernziele",
    "title": "6  Einlesen von Daten",
    "section": "",
    "text": "lokale Datendateien mit dem Paket readr zu importieren\nmit fehlenden Werten umzugehen\nVariablen in Faktoren umwandeln\n\n\nLesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kap. 8 (Data Import) in Wickham et al. (2023).\nEine ergänzende Lektüre ist Ch. 4 (Data Import) in Nordmann & DeBruine (2022).",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#wiederholung",
    "href": "mats/07-dateneinlesung.html#wiederholung",
    "title": "6  Einlesen von Daten",
    "section": "Wiederholung",
    "text": "Wiederholung\nIm letzten Kapitel haben wir das Gelernte in die Praxis umgesetzt. Wir haben einen Datensatz aus dem languageR-Paket (Baayen & Shafaei-Bajestan, 2019) eingelesen, ihn mit dem dplyr-Paket aus dem tidyverse verarbeitet und mehrere Diagramme mit dem ggplot2-Paket aus dem tidyverse erstellt. All dies wurde mit einem Quarto-Skript durchgeführt.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#sec-dateneinlesung-setup",
    "href": "mats/07-dateneinlesung.html#sec-dateneinlesung-setup",
    "title": "6  Einlesen von Daten",
    "section": "6.1 Einrichtung",
    "text": "6.1 Einrichtung\n\n6.1.1 Pakete mit pacman\nZu Beginn werden wir mit dem Paket pacman beginnen. Die Funktion p_load() nimmt Paketnamen als Argumente und prüft dann, ob Sie das Paket installiert haben. Wenn ja, dann lädt sie das Paket (genau wie library()). Wenn Sie das Paket nicht installiert haben, wird das Paket installiert und geladen (wie mit install.packages(), library()). Das erspart uns, neue Pakete einzeln zu installieren, und bedeutet auch, dass, wenn wir unser Skript mit anderen teilen, sie einfach pacman::p_load() ausführen können.\n\n## install new packages IN THE CONSOLE!\ninstall.packages(\"pacman\")\n\n\n## load packages\npacman::p_load(tidyverse, ## wrangling\n               janitor, ## wrangling\n               here ## relative file paths\n               )\n\nWir haben nun tidyverse geladen, und die neuen Pakete janitor und here installiert und geladen. Um mehr über diese Pakete herauszufinden, versuchen Sie ?janitor und ?here in der Konsole einzugeben.\n\n\n6.1.2 RProjects\nBevor wir mit unserer ersten Datei beginnen, müssen wir sicherstellen, dass wir innerhalb unseres RProjekts arbeiten. Zu Beginn des Kurses haben Sie eine ZIP-Datei von GitHub (https://github.com/daniela-palleschi/r4ling_student) heruntergeladen, die einige Ordner und eine .RProj-Datei enthielt. Hoffentlich haben Sie bis jetzt innerhalb dieses RProjekts gearbeitet und Ihre Skripte im Ordner notizen gespeichert. Von nun an wird es notwendig sein, innerhalb dieses RProjekts zu arbeiten, damit wir immer auf unsere relevanten Datendateien zugreifen können, die in einem Ordner namens daten gespeichert werden sollten.\nUm ein RProjekt zu öffnen, navigieren Sie einfach zu dem Ordner auf Ihrem Rechner und doppelklicken Sie auf die .RProj-Datei. Wenn Sie sich bereits in RStudio befinden, können Sie auch überprüfen, ob Sie im richtigen RProjekt arbeiten, indem Sie oben im Fenster nachsehen.\n\n\n\n\n\n\nAufgabe\n\n\n\n\nÜberprüfen Sie, ob Sie tatsächlich in Ihrem RProjekt arbeiten. Wenn dies der Fall ist, sehen Sie r4ling_student-main oben in Ihrem RStudio (Abbildung 6.1).\n\n\nWenn dies nicht der Fall ist (Abbildung 6.2), können Sie zum RProjekt wechseln, indem Sie auf die Schaltfläche “Projekt” oben rechts im RStudio klicken (Abbildung 6.3; Hinweis: Die Screenshots stammen von einem Mac, auf einem Windows-Rechner sieht es etwas anders aus).\n\n\nFügen Sie Ihrem RProject-Ordner einen Ordner namens daten hinzu.\n\n\n\n\n\n\n\n\n\nAbbildung 6.1: RStudio will display the RProject name if you are working in an RProject (here: r4ling_student-main).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 6.2: RStudio will display the RProject name if you are working in an RProject.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 6.3: RStudio will say ‘RStudio’ and ‘Project (none)’ if you are not working in an RProject.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#csv-komma-getrennter-wert",
    "href": "mats/07-dateneinlesung.html#csv-komma-getrennter-wert",
    "title": "6  Einlesen von Daten",
    "section": "6.2 CSV: Komma getrennter Wert",
    "text": "6.2 CSV: Komma getrennter Wert\nBisher haben wir mit Daten aus dem R-Paket languageR gearbeitet. Daten aus Paketen sind eine großartige Möglichkeit, die Werkzeuge der Datenwissenschaft zu erlernen, aber normalerweise wollen wir mit unseren eigenen Daten arbeiten, nicht mit eingebauten Spielzeugdaten. Wir werden uns nur auf rechteckige Daten (d. h. aufgeräumte Daten) konzentrieren, obwohl Ihre Daten zu Beginn oft nicht aufgeräumt sind. Es gibt viele verschiedene Dateitypen, die Daten annehmen können, z. B. .xlsx, .txt, .csv, .tsv. Der Dateityp “csv” ist der häufigste Dateityp und steht für: Comma Separated Values.\nSo sieht eine einfache CSV-Datei aus:\n\n\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n\n\nDie erste Zeile (die “Kopfzeile”) enthält die Spaltennamen. Die folgenden Zeilen enthalten die Daten. Wie viele Variablen gibt es? Wie viele Beobachtungen?\nWir lernen jetzt etwas über aufgeräumte Daten und sehen uns ein Beispiel an. Anschließend werden wir eine CSV-Datei in R laden.\n\n\n\n\n\n\nMicrosoft Excel\n\n\n\nVersuchen Sie, .xlsx-Dateien im Allgemeinen zu vermeiden, vor allem aber, wenn Sie Ihre Daten in R laden wollen. Der Grund dafür ist, dass Excel viele Formatierungsprobleme hat, die für R problematisch sind. Wenn Sie einen Excel-Datensatz haben, versuchen Sie, ihn als .csv zu speichern, bevor Sie ihn in R einlesen (Datei &gt; Speichern unter &gt; Dateiformat &gt; Komma-getrennter Wert).\n\n\n\n6.2.1 Tidydaten\nUnabhängig davon, in welchem Format Ihre Daten vorliegen, sollten sie aufgeräumt sein. Das bedeutet erstens, dass die Daten rechteckig sein sollten und dass jede Spalte eine Variable, jede Zeile eine Beobachtung und jede Zelle einen Datenpunkt darstellt (Abbildung 6.4).\n\n\n\n\n\n\n\n\nAbbildung 6.4: Source: Wickham et al. (2023) (all rights reserved)",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#tabelle-zu-csv",
    "href": "mats/07-dateneinlesung.html#tabelle-zu-csv",
    "title": "6  Einlesen von Daten",
    "section": "6.3 Tabelle zu csv",
    "text": "6.3 Tabelle zu csv\nLassen Sie uns einige Spielzeugdaten in einem Arbeitsblatt sammeln, das wir dann als CSV-Datei speichern und in R laden werden. Klicken Sie hier, um zu einem bearbeitbaren Arbeitsblatt zu gelangen. Geben Sie die relevanten Informationen über sich selbst ein, oder erfinden Sie einige Daten: den Namen eines Haustiers, das Sie haben/hatten, Größe, Geburtsmonat und -tag sowie Ihre erste Sprache. Wenn Sie kein Haustier haben, lassen Sie die Zelle leer.\n\n\n\n\n\nOur spreadsheet\n\n\n\n\n\n6.3.1 CSV speichern\nJetzt müssen wir unser Arbeitsblatt als CSV-Datei auf unserem Computer speichern. Solange wir in unserem RProjekt arbeiten, wird R immer nach Dateien aus dem Ordner suchen, der unser RProjekt enthält. Stellen wir also zunächst sicher, dass unser Ordner einen Unterordner namens daten enthält. Darin werden wir alle unsere Daten speichern.\n\n\n\n\n\n\nAufgabe 6.1: Speichern einer CSV\n\n\n\n\nBeispiel 6.1  \n\n\nErstellen Sie einen neuen Ordner mit dem Namen daten in Ihrem Projektordner (falls Sie das nicht schon getan haben).\nLaden Sie das Google Sheet herunter und speichern Sie es in Ihrem daten-Ordner als groesse_geburtstag.csv.\nGehen Sie zu Ihrem daten-Ordner und überprüfen Sie, ob die CSV-Datei dort ist.\n\n\n\n\n\n\nDownload a Google Sheet as a CSV.\n\n\n\n\n\n\n\n\n\nFind the CSV file in your file manager.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#das-readr-paket",
    "href": "mats/07-dateneinlesung.html#das-readr-paket",
    "title": "6  Einlesen von Daten",
    "section": "6.4 Das readr-Paket",
    "text": "6.4 Das readr-Paket\nUnsere Daten können als Tabelle angezeigt werden, genau wie unsere eingebauten Datensätze aus dem languageR-Paket (Baayen & Shafaei-Bajestan, 2019). Genau wie bei den eingebauten Datensätzen müssen wir zuerst die Daten einlesen, aber anstatt nur den Namen des eingebauten Datensatzes anzugeben, müssen wir eine Funktion verwenden, die CSV-Daten liest. Wir müssen auch angeben, wo sich die Daten in unserem RProject-Ordner befinden.\nDas Paket readr (Teil von tidyverse) kann die meisten Datentypen einlesen und hat mehrere Funktionen für verschiedene Datentypen.\n\nread_csv(here::here(\"daten\", \"groesse_geburtstag.csv\"))\n\n\n\n\n\nTabelle 6.1: Data from the students.csv file as a table.\n\n\n\n\n\n\nGröße\nGeburtsmonat\nL1\nHaustier\nWas für ein Haustier?\n\n\n\n\n171\n5\nEnglisch\nLola\nHundin\n\n\n168\n11\nDeutsch\nkeine\nkeine\n\n\n182\n4\nDeutsch\nN/A\nNA\n\n\n190\n8\nDeutsch\nKnut\nKater\n\n\n170\n10\nDeutsch\nEmma\nHundin\n\n\n163\n2\nDeutsch\nÜzgür\nKater\n\n\n164\n7\nItalienisch\nFipsy\nKatze\n\n\n167\n12\nSchwedisch\nAnna\nFisch\n\n\n189\n10\nNorwegisch\nArvid\nPapagei\n\n\n163\n7\nRussisch\nNarzis\nKater\n\n\n159\n11\nPunjabi\nMimi\nKatze\n\n\n173\n9\nDeutsch\nPercy\nHund\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAufgabe 6.2: df_groesse\n\n\n\n\nBeispiel 6.2  \n\n\nImportieren Sie den Datensatz “groesse_geburtstag.csv” und speichern Sie ihn als Objekt mit dem Namen “df_groesse”.\n\ndf_ ist die Abkürzung für DataFrame; es ist eine gute Idee, ein Präfix vor Objektnamen zu verwenden, damit wir wissen, was jedes Objekt enthält.\n\nWenn Daten mit read_csv importiert werden, werden einige Informationen in der Konsole ausgegeben. Was wird gedruckt?\nUntersuche den Datensatz mit Funktionen wie summary() oder head()\nSehen Sie etwas Ungewöhnliches?",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#das-here-paket",
    "href": "mats/07-dateneinlesung.html#das-here-paket",
    "title": "6  Einlesen von Daten",
    "section": "6.5 Das here-Paket",
    "text": "6.5 Das here-Paket\nAber woher weiß R genau, wo der Ordner daten zu finden ist? Unser Arbeitsverzeichnis ist auf den Ort unseres RProjekts auf unserem Computer festgelegt. Wann immer wir auf Daten in unserem RProjekt zugreifen wollen, sollten wir here() verwenden (vorausgesetzt, wir haben das here-Paket bereits geladen). Um zu sehen, von wo aus here() startet, führen Sie here() aus. Wie sieht die Ausgabe im Vergleich zu der von getwd() (für ‘get working directory’)?\n\nhere()\n\n[1] \"/Users/danielapalleschi/Documents/IdSL/Webbooks/r4ling\"\n\ngetwd()\n\n[1] \"/Users/danielapalleschi/Documents/IdSL/Webbooks/r4ling/mats\"\n\n\nDie Ausgabe wird auf allen unseren Rechnern anders aussehen, aber was gleich sein sollte, ist unsere Ordnerstruktur innerhalb unserer Projekte (z. B. data/groesse_geburtstag.csv).\n\n\n\n\n\nImage source: Allison Horst (all rights reserved)\n\n\n\n\n\n\n\n\n\n\nhere-Paket\n\n\n\n\nVor dem here-Paket mussten wir R explizit mitteilen, wo sich eine Datei auf unserem Computer befindet (z.B., /Users/danielapalleschi/Documents/IdSL/Teaching/SoSe23/BA/ba_daten/daten/students.csv), oder die Funktion setwd() (set Working Directory) benutzen, um R mitzuteilen, wo alle Dateien zu finden sind (z.B. setwd(\"/Users/danielapalleschi/Documents/IdSL/Teaching/SoSe23/BA/ba_daten\")). Glücklicherweise brauchen Sie diese absoluten Dateipfade oder setwd() nie zu benutzen!\nAus der hier-Paketdokumentation:\n\nThe goal of the here package is to enable easy file referencing in project-oriented workflows. In contrast to using setwd(), which is fragile and dependent on the way you organize your files, here uses the top-level directory of a project to easily build paths to files.\n\nDas bedeutet, dass wir nun den großen Vorteil haben, dass wir unseren Projektordner überall hin verschieben können und unser Dateipfad immer noch relativ zu dem Ort ist, an den wir unseren Projektordner verschoben haben. Das bedeutet, dass das Projekt unabhängig davon läuft, wo es sich auf Ihrem Computer befindet. Sie können auch jemandem den Projektordner schicken, und alles sollte auf dessen Rechner laufen!",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#arbeit-mit-daten",
    "href": "mats/07-dateneinlesung.html#arbeit-mit-daten",
    "title": "6  Einlesen von Daten",
    "section": "6.6 Arbeit mit Daten",
    "text": "6.6 Arbeit mit Daten\nDaten sind chaotisch, aber mit Erfahrung können wir lernen, sie zu bändigen. Im Folgenden finden Sie einige Tipps, die das Gelernte über die Datenverarbeitung erweitern.\n\n6.6.1 Fehlende Werte\nBei der Datentransformation geht es darum, unsere Daten zu “reparieren”, wenn sie nicht “in Ordnung” sind. In unserem df_groesse Datenrahmen haben Sie vielleicht einige NA oder N/A Werte bemerkt. N/A” wurde in einer unserer Beobachtungen als Text geschrieben und wird von R als solcher gelesen. N/A” in R bezieht sich auf fehlende Daten (“Nicht verfügbar”). Echte fehlende Werte sind komplett leer, so dass N/A in unseren df_groesse-Daten nicht wirklich als fehlender Wert gelesen wird, obwohl wir möchten, dass R weiß, dass dies als fehlende Daten zählt und nicht das Haustier von jemandem namens “NA” (Menschen tun seltsame Dinge!). Um dies zu beheben, können wir das Argument na = für die Funktion read_csv() verwenden, das der Funktion read_csv() mitteilt, welche Werte sie mit fehlenden Werten gleichsetzen soll.\n\n# force \"N/A\" to missing values\ndf_groesse &lt;- read_csv(here::here(\"daten\", \"groesse_geburtstag.csv\"),\n                        na = \"N/A\")\n# print the head of the data set\nhead(df_groesse)\n\n# A tibble: 6 × 5\n  Größe Geburtsmonat L1       Haustier `Was für ein Haustier?`\n  &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;                  \n1   171            5 Englisch Lola     \"Hundin\"               \n2   168           11 Deutsch  keine    \"keine\"                \n3   182            4 Deutsch  &lt;NA&gt;     \"\"                     \n4   190            8 Deutsch  Knut     \"Kater\"                \n5   170           10 Deutsch  Emma     \"Hundin\"               \n6   163            2 Deutsch  Üzgür    \"Kater\"                \n\n\nJetzt wird der Wert, der vorher \"\" war, als NA gelesen. Aber was ist mit der leeren Zelle? Wir haben jetzt überschrieben, dass read_csv() leere Zellen als NA liest. Jetzt wollen wir read_csv() anweisen, mehr als eine Art von Eingabe als NA zu lesen, d.h. wir wollen es anweisen, \"\" und \"N/A\" als NA zu lesen. Dafür verwenden wir unsere immer nützliche Verkettungsfunktion: c().\n\n# force \"N/A\" and empty cells to missing values\ndf_groesse &lt;- read_csv(here::here(\"daten\", \"groesse_geburtstag.csv\"),\n                        na = c(\"N/A\",\"\"))\n# print the head of the data set\nhead(df_groesse)\n\n# A tibble: 6 × 5\n  Größe Geburtsmonat L1       Haustier `Was für ein Haustier?`\n  &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;                  \n1   171            5 Englisch Lola     Hundin                 \n2   168           11 Deutsch  keine    keine                  \n3   182            4 Deutsch  &lt;NA&gt;     &lt;NA&gt;                   \n4   190            8 Deutsch  Knut     Kater                  \n5   170           10 Deutsch  Emma     Hundin                 \n6   163            2 Deutsch  Üzgür    Kater                  \n\n\n\n\n6.6.2 Spaltennamen\nWenn wir df_groesse in der Konsole ausdrucken, werden wir sehen, dass ein Spaltenname von Backticks umgeben ist (z.B. `Monat der Geburt). Das liegt daran, dass er ein Leerzeichen enthält, das syntaktisch nicht gültig ist (Variablennamen müssen mit einem Buchstaben beginnen und dürfen keine Leerzeichen oder Sonderzeichen enthalten). Eine schnelle Lösung ist die Funktion clean_names() aus dem Paket janitor, das wir bereits geladen haben.\n\nclean_names(df_groesse)\n\n# A tibble: 12 × 5\n   grosse geburtsmonat l1          haustier was_fur_ein_haustier\n    &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;               \n 1    171            5 Englisch    Lola     Hundin              \n 2    168           11 Deutsch     keine    keine               \n 3    182            4 Deutsch     &lt;NA&gt;     &lt;NA&gt;                \n 4    190            8 Deutsch     Knut     Kater               \n 5    170           10 Deutsch     Emma     Hundin              \n 6    163            2 Deutsch     Üzgür    Kater               \n 7    164            7 Italienisch Fipsy    Katze               \n 8    167           12 Schwedisch  Anna     Fisch               \n 9    189           10 Norwegisch  Arvid    Papagei             \n10    163            7 Russisch    Narzis   Kater               \n11    159           11 Punjabi     Mimi     Katze               \n12    173            9 Deutsch     Percy    Hund                \n\n\nDas sieht besser aus! Aber wenn Sie jetzt head(df_groesse) ausführen, sehen Sie dann die bereinigten Spaltennamen?\nDas sollten Sie nicht, denn wenn wir ein Objekt durch eine Funktion übergeben, wird das Objekt nicht ‘aktualisiert’, so dass wir das Objekt erneut mit dem Zuweisungsoperator &lt;- zuweisen müssen.\n\ndf_groesse &lt;- janitor::clean_names(df_groesse)\n\nAber wir wissen oft, dass wir mehrere Funktionen (read_csv(), clean_names()) auf demselben Objekt ausführen wollen, denken Sie daran, dass wir das mit Pipes tun können.\n\n\n6.6.3 Pipes\nPipes werden am Ende eines Funktionsaufrufs eingefügt, wenn das Ergebnis dieser Funktion durch eine nachfolgende Funktion weitergegeben werden soll. Pipes können als “und dann…” gelesen werden.\n\nread_csv(here::here(\"daten\", \"groesse_geburtstag.csv\")) |&gt;\n  head()\n\n# A tibble: 6 × 5\n  Größe Geburtsmonat L1       Haustier `Was für ein Haustier?`\n  &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;                  \n1   171            5 Englisch Lola     Hundin                 \n2   168           11 Deutsch  keine    keine                  \n3   182            4 Deutsch  N/A      &lt;NA&gt;                   \n4   190            8 Deutsch  Knut     Kater                  \n5   170           10 Deutsch  Emma     Hundin                 \n6   163            2 Deutsch  Üzgür    Kater                  \n\n\nDerzeit gibt es 2 Pipes, die in R verwendet werden können.\n\ndie magrittr Paket-Pipe: %&gt;%\ndie neue native R-Pipe: |&gt;\n\nEs gibt keine großen Unterschiede, die für unsere aktuellen Anwendungen wichtig sind, also benutzen wir die neue |&gt;. Sie können die Tastenkombination Cmd/Ctrl + Shift/Strg + M verwenden, um eine Pipe zu erzeugen. Dies könnte die “Magrittr”-Paket-Pipe erzeugen, was in Ordnung ist, aber wenn Sie das ändern möchten, können Sie das unter Werkzeuge &gt; Globale Optionen &gt; Code &gt; Native Pipe-Operator verwenden tun.\n\n\n\n\n\n\nAufgabe 6.3: pipes\n\n\n\n\nBeispiel 6.3  \n\n\nLaden Sie den Datensatz groesse_geburtstag.csv erneut mit festen NAs und dann\n\nBenutze eine Pipe, um clean_names() auf dem Datensatz aufzurufen, und dann\nrufen Sie die Funktion “head()” auf\nÜberprüfen Sie die Anzahl der Beobachtungen und Variablen, gibt es ein Problem?\n\nLaden Sie den Datensatz groesse_geburtstag.csv erneut mit festen NAs, speichern Sie ihn als Objekt df_groesse, und dann\n\nVerwenden Sie eine Pipe, um clean_names() auf den Datensatz anzuwenden.\n\nWarum sollte man nicht eine Pipe und die Funktion head() verwenden, wenn man den Datensatz als Objekt speichert?\n\n\n\n\n\n\n\n6.6.4 Variablentypen\nDas Paket readr errät den Typ der Daten, die jede Spalte enthält. Die wichtigsten Spaltentypen, die man kennen muss, sind numerisch und Faktor (kategorisch). Faktoren enthalten Kategorien oder Gruppen von Daten, können aber manchmal aussehen wie numerische Daten. Zum Beispiel enthält unsere Spalte “Monat” Zahlen, aber sie könnte auch den Namen jedes Monats enthalten. Ein guter Weg, um zu wissen, was was ist: Es ist sinnvoll, den Mittelwert einer “numerischen” Variablen zu berechnen, aber nicht den eines “Faktors”. Zum Beispiel ist es sinnvoll, den Mittelwert der Körpergröße zu berechnen, aber nicht den Mittelwert des Geburtsmonats.\nUm sicherzustellen, dass eine Variable als Faktor gespeichert wird, können wir die Funktion as_factor() verwenden. Wir können entweder die R-Basissyntax verwenden, um dies zu tun, indem wir ein $ verwenden, um eine Spalte in einem Datenrahmen zu indizieren:\n\ndf_groesse$geburtsmonat &lt;- as_factor(df_groesse$geburtsmonat)\n\nOr we can use tidyverse syntax and the mutate() function.\n\ndf_groesse &lt;-\n  df_groesse |&gt; \n  mutate(geburtsmonat = as_factor(geburtsmonat))",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#andere-dateitypen-und-begrenzungszeichen",
    "href": "mats/07-dateneinlesung.html#andere-dateitypen-und-begrenzungszeichen",
    "title": "6  Einlesen von Daten",
    "section": "6.7 Andere Dateitypen und Begrenzungszeichen",
    "text": "6.7 Andere Dateitypen und Begrenzungszeichen\nSobald Sie mit read_csv() vertraut sind, sind die anderen Funktionen von readr einfach zu benutzen, Sie müssen nur wissen, wann Sie welche benutzen.\nDie Funktion read_csv2() liest Semikolon-separierte Dateien. Diese verwenden Semikolons (;) anstelle von Kommas (,), um Felder zu trennen und sind in Ländern üblich, die , als Dezimaltrennzeichen verwenden (wie Deutschland).\nDie Funktion read_tsv() liest Tabulator-getrennte Dateien. Die Funktion read_delim() liest Dateien mit beliebigen Trennzeichen ein und versucht, das Trennzeichen zu erraten, es sei denn, Sie geben es mit dem Argument delim = an (z.B. read_delim(students.csv, delim = \",\")).\nreadr hat mehrere andere Funktionen, die ich persönlich noch nicht gebraucht habe, wie zum Beispiel:\n\nread_fwf() liest Dateien mit fester Breite\nread_table() liest eine gängige Variante von Dateien mit fester Breite, bei der die Spalten durch Leerzeichen getrennt sind\nread_log() liest Log-Dateien im Apache-Stil",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#weitere-übungen",
    "href": "mats/07-dateneinlesung.html#weitere-übungen",
    "title": "6  Einlesen von Daten",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.6.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#lernziele-1",
    "href": "mats/07-dateneinlesung.html#lernziele-1",
    "title": "6  Einlesen von Daten",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nHeute haben wir gelernt, wie man…\n\nlokale Datendateien mit dem Paket readr importiert ✅\nfehlende Werte behandeln ✅\nVariablen in Faktoren umwandeln ✅\n\nLassen Sie uns nun dieses neue Wissen anwenden.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/07-dateneinlesung.html#session-info",
    "href": "mats/07-dateneinlesung.html#session-info",
    "title": "6  Einlesen von Daten",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] magick_2.8.3    here_1.0.1      janitor_2.2.0   lubridate_1.9.3\n [5] forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4     purrr_1.0.2    \n [9] readr_2.1.5     tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.1  \n[13] tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        stringi_1.8.3    \n [5] hms_1.1.3         digest_0.6.35     magrittr_2.0.3    evaluate_0.23    \n [9] grid_4.4.0        timechange_0.3.0  fastmap_1.1.1     rprojroot_2.0.4  \n[13] jsonlite_1.8.8    fansi_1.0.6       scales_1.3.0      cli_3.6.2        \n[17] crayon_1.5.2      rlang_1.1.3       bit64_4.0.5       munsell_0.5.1    \n[21] withr_3.0.0       yaml_2.3.8        parallel_4.4.0    tools_4.4.0      \n[25] tzdb_0.4.0        colorspace_2.1-0  pacman_0.5.1      vctrs_0.6.5      \n[29] R6_2.5.1          lifecycle_1.0.4   snakecase_0.11.1  htmlwidgets_1.6.4\n[33] bit_4.0.5         vroom_1.6.5       pkgconfig_2.0.3   pillar_1.9.0     \n[37] gtable_0.3.5      glue_1.7.0        Rcpp_1.0.12       xfun_0.43        \n[41] tidyselect_1.2.1  rstudioapi_0.16.0 knitr_1.46        htmltools_0.5.8.1\n[45] rmarkdown_2.26    compiler_4.4.0   \n\n\n\n\n\n\n\n\nBaayen, R. H., & Shafaei-Bajestan, E. (2019). languageR: Analyzing Linguistic Data: A Practical Introduction to Statistics. https://CRAN.R-project.org/package=languageR\n\n\nNordmann, E., & DeBruine, L. (2022). Applied Data Skills. Zenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Einlesen von Daten</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html",
    "href": "mats/08-desc_stats.html",
    "title": "7  Deskriptive Statistik",
    "section": "",
    "text": "Lernziele\nIn diesem Kapitel werden wir lernen…",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#lernziele",
    "href": "mats/08-desc_stats.html#lernziele",
    "title": "7  Deskriptive Statistik",
    "section": "",
    "text": "über Maße der zentralen Tendenz (Mittelwert, Median, Modus)\nüber Streuungsmaße (Bereich, Standardabweichung)\nwie man die Funktion summarise() von dplyr benutzt\nwie man Zusammenfassungen .by Gruppe erstellt",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#lesungen",
    "href": "mats/08-desc_stats.html#lesungen",
    "title": "7  Deskriptive Statistik",
    "section": "Lesungen",
    "text": "Lesungen\nDie Pflichtlektüre zur Vorbereitungen auf dieses Thema sind\n\nKap. 3, Abschnitt 3.4-3.9 (Descriptive statistics, models, and distributions) in Winter (2019) (online verfügbar über das HU Grimm Zentrum.\nBereich 4.5 (Groups) in Kapital 4 (Data Transformation) in Wickham et al. (2023).",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#sec-desc_stats_setup",
    "href": "mats/08-desc_stats.html#sec-desc_stats_setup",
    "title": "7  Deskriptive Statistik",
    "section": "7.1 Einrichten",
    "text": "7.1 Einrichten\n\n7.1.1 Umgebung löschen\nEin wichtiger Schritt, über den wir noch nicht viel gesprochen haben, ist sicherzustellen, dass Sie ein neues Skript immer mit einer leeren R-Umgebung starten. Das bedeutet, dass wir keine Objekte in der Umgebung gespeichert haben sollten, aber auch keine Pakete geladen haben sollten. Wir wollen nämlich sicherstellen, dass alles, was wir tun, ausschließlich in diesem Skript ausgeführt wird und nicht von einem Paket oder Daten abhängt, die wir aus einem anderen Skript geladen haben. Um dies zu erreichen, können Sie auf Sitzung &gt; R neu starten klicken, um mit einer neuen Umgebung zu beginnen, oder die Tastenkombination Cmd/Strg+Strg+0 verwenden.\n\n\n7.1.2 Pakete\nWir müssen die Pakete tidyverse, here und janitor laden. Die letzten beiden brauchen wir, weil wir lokale CSV-Datensätze laden werden.\n\npacman::p_load(tidyverse,\n               here,\n               janitor)\n\n\n\n7.1.3 Daten laden\nWir werden heute zwei Datensätze verwenden: eine leicht veränderte Version des groesse_geburtstag-Datensatzes aus dem letzten Abschnitt (groesse_geburtstag_ws2324.csv) und languageR_english.csv, das eine kürzere Version des english-Datensatzes aus dem languageR-Paket ist. Wenn Sie diese Daten noch nicht haben, laden Sie sie direkt in Ihren Daten-Ordner vom GitHub-Kurs herunter (klicken Sie auf “Download raw file” neben dem “Raw”-Button):\n\nlanguageR_english.csv\ngroesse_geburtstag_ws2324.csv\n\n\ndf_groesse &lt;- read_csv(here(\"daten\", \"groesse_geburtstag_ws2324.csv\"))\n\n\ndf_eng &lt;- read_csv(here(\"daten\", \"languageR_english.csv\")) |&gt; \n  clean_names() |&gt; \n  # fix some wonky variable names:\n  rename(rt_lexdec = r_tlexdec,\n         rt_naming = r_tnaming)",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#deskriptive-statistik",
    "href": "mats/08-desc_stats.html#deskriptive-statistik",
    "title": "7  Deskriptive Statistik",
    "section": "7.2 Deskriptive Statistik",
    "text": "7.2 Deskriptive Statistik\nDeskriptive Statistiken beschreiben quantitativ die zentrale Tendenz, die Variabilität und die Verteilung von Daten. Sie werden manchmal auch als zusammenfassende Statistiken bezeichnet, weil wir die beobachteten Daten zusammenfassen. Zu den gängigen zusammenfassenden Statistiken gehören der Wertebereich (Minimum, Maximum), der Mittelwert und die Standardabweichung. Deskriptive Statistiken helfen uns, unsere Daten in vollem Umfang zu verstehen, und sind ein wichtiger Schritt bei der Untersuchung unseres Datensatzes, bevor wir fortgeschrittenere Inferenzstatistiken durchführen (die wir in diesem Kurs nicht behandeln werden).\n\n7.2.1 Anzahl der Beobachtungen (\\(n\\))\nDie Anzahl der Beobachtungen in einem Datensatz ist keine statistische Größe, sondern eine wichtige Information bei der Zusammenfassung oder Beschreibung von Daten. Wenn wir mehr Daten haben (höher \\(n\\)), können wir den Schlussfolgerungen, die wir aus unseren Daten ziehen, mehr Vertrauen schenken, da wir mehr Beweise haben. Umgekehrt kann es sein, dass bei weniger Daten (niedriger \\(n\\)) unsere zusammenfassende Statistik nicht auf die Grundgesamtheit verallgemeinerbar ist. Wir können die Anzahl der Beobachtungen in einem Datensatz mit der R-eigenen Funktion nrow() überprüfen:\n\nnrow(df_groesse)\n\n[1] 9\n\n\n\n\n\n\n\n\nlength() gegenüber nrow()\n\n\n\nDie Funktion length() sagt uns, wie viele (horizontale) Werte in einem Objekt enthalten sind. Wenn das Objekt ein Datenrahmen (statt eines Vektors) ist, sagt sie uns, wie viele Spalten wir haben.\n\nlength(df_groesse)\n\n[1] 5\n\n\nWenn es sich bei dem Objekt jedoch um einen Vektor handelt, dann gibt uns length() die Anzahl der Beobachtungen an.\n\nvector &lt;- c(1,5,2,6,8,4,7,8,3)\nlength(vector)\n\n[1] 9\n\n\n\n\n\n\n7.2.2 Maße der zentralen Tendenz (Lagemaße)\nMaße der zentralen Tendenz beschreiben quantitativ die Mitte unserer Daten. Wahrscheinlich haben Sie schon einmal drei Maße der zentralen Tendenz kennengelernt: den Mittelwert, den Median und den Modus.\n\n7.2.2.1 Mittelwert (\\(\\mu\\) oder \\(\\bar{x}\\))\nDer Mittelwert oder Durchschnitt ist die Summe aller Werte geteilt durch die Anzahl der Werte (wie in Gleichung \\(\\ref{eq-mean}\\)). In der mathematischen Notation wird sum mit dem großen griechischen Sigma (\\(\\sum\\)) geschrieben, wie in der Gleichung \\(\\ref{eq-sigma}\\).\n\\[\\begin{align}\n\\mu &= \\frac{Summe\\;der\\;Werte}\n           {n} \\label{eq-mean} \\\\\n\\bar{x} &= \\frac{\\sum{x}}      \n           {n} \\label{eq-sigma}\n\\end{align}\\]\n\n\n7.2.2.2 Populationsmittelwert (\\(\\mu\\)) versus Stichprobenmittelwert (\\(\\bar{x}\\))\nBeide Gleichungen bedeuten dasselbe, verwenden aber unterschiedliche Schreibweisen, um dieselbe Gleichung darzustellen. Während \\(\\mu\\) den Populationsmittelwert darstellt, repräsentiert \\(\\bar{x}\\) den Stichprobenmittelwert. Der Populationsmittelwert ist der wahre Mittelwert einer Messung in einer gesamten Population (z. B. die Körpergröße aller Studenten an der Humboldt-Universität zu Berlin). Ein Stichprobenmittel ist der Mittelwert einer Stichprobenpopulation, aus der wir unsere Daten erhoben haben. Wir haben zum Beispiel 9 Beobachtungen in df_groesse. Diese Daten stellen eine Stichprobe von Daten aus einer größeren Grundgesamtheit dar.\n\nWir können den Mittelwert leicht von Hand berechnen, wenn wir nur ein paar Werte haben. Erinnern Sie sich an unseren Datensatz von letzter Woche, in dem wir unsere Höhen in Zentimetern gesammelt haben (171, 168, 182, 190, 170, 163, 164, 167, 189). Es gibt 9 Werte, also müssen wir diese Höhen addieren und die Summe durch 9 teilen.\n\n171+ 168+ 182+ 190+ 170+ 163+ 164+ 167+ 189 / 9\n\n[1] 1396\n\n\nDaraus ergibt sich eine durchschnittliche Körpergröße von 1396 cm. Das kann nicht richtig sein, was ist also schief gelaufen? Wir können die obige Gleichung korrigieren, indem wir die Höhen in Klammern setzen (()), bevor wir durch \\(n\\) dividieren.\n\n(171+ 168+ 182+ 190+ 170+ 163+ 164+ 167+ 189) / 9\n\n[1] 173.7778\n\n\nDieses Problem wurde durch die Reihenfolge der Operationen verursacht, die im Folgenden näher beschrieben wird. Das Wichtigste ist, dass Sie sicher sein können, dass das Ergebnis einer bestimmten Operation vor allen anderen Operationen ausgeführt wird, wenn Sie es in Paranthesen einschließen.\n\n\n\n\n\n\nOperatorrangfolge: KEMDAS\n\n\n\nVielleicht erinnern Sie sich, dass Sie als Kind im Mathematikunterricht etwas über die Reihenfolge der Operationen gelernt haben. Dies bezieht sich auf die Reihenfolge der Ausführung, wenn wir eine mathematische Gleichung mit mehreren Operatoren wie Division, Addition und Multiplikation haben. R folgt auf KEMDAS (das ich von PEMDAS im Englischen übernommen habe), was für:\n\n\n\n\nTabelle 7.1: KEMDAS\n\n\n\n\n\n\n\nletter\noperation\nR\n\n\n\n\nK\nKlammern\n(x + y)\n\n\nE\nExponenten\nx^y\n\n\nM\nMultiplikation\nx*y\n\n\nD\nDivision\nx/y\n\n\nA\nAddierung\nx + y\n\n\nS\nSubtraktion\nx - y\n\n\n\n\n\n\n\n\n\n\n\nMultiplikation und Division werden jedoch von links nach rechts ausgeführt, ebenso wie Addition und Subtraktion.\n\n\nWir können auch die Ergebnisse einer Gleichung als Objekt oder mehrere Werte als Vektor (eine Liste von Werten der gleichen Klasse) speichern. Wir könnten dann die Funktionen sum() und length() verwenden, um den Mittelwert zu berechnen, oder einfach die Funktion mean() benutzen.\n\n# save groesse as a vector\ngroesse &lt;- c(171, 168, 182, 190, 170, 163, 164, 167, 189)\n# divide the sum of groesse by the n of groesse\nsum(groesse)/length(groesse)\n\n[1] 173.7778\n\n\n\n# or use the mean() function\nmean(groesse)\n\n[1] 173.7778\n\n\nUnsere Daten sind oft nicht in einem einzelnen Vektor gespeichert, sondern in einem Datensatz. Wir können die Funktion mean() auf eine Variable in einem Datenrahmen anwenden, indem wir den Operator $ verwenden, um anzugeben, dass wir eine Spalte aus einem Datenrahmen auswählen wollen (datenrahmen$variable).\n\nmean(df_groesse$groesse)\n\n[1] 173.6667\n\n\nDer $-Operator ist Teil der nativen R-Syntax und ähnelt dem Operator pdf_groesse |&gt;select(groesse) in der dplyr-Syntax.\n\n7.2.2.3 Median\nEin weiteres Maß für die zentrale Tendenz ist der Median, d. h. der Wert in der Mitte des Datensatzes. Wenn Sie alle Ihre Werte in aufsteigender (oder absteigender) Reihenfolge anordnen, ist der mittlere Wert der Median. Wenn Sie zum Beispiel 5 Werte haben, ist der 3. Bei 6 Werten ist der Mittelwert des 3. und 4. Wertes der Median. Die Hälfte der Daten liegt unter dem Median, die andere Hälfte über dem Median.\nUm unsere Daten in aufsteigender Reihenfolge zu sortieren, können wir die Funktion sort() verwenden. Wir können dann einfach zählen, welches der mittlere Wert ist:\n\nsort(df_groesse$groesse)\n\n[1] 163 164 167 167 170 171 182 189 190\n\n\nDas ist einfach, wenn wir nur ein paar Beobachtungen haben. Wir könnten alternativ einfach die Funktion Median() verwenden.\n\nmedian(df_groesse$groesse)\n\n[1] 170\n\n\nEin wichtiges Merkmal des Medians ist, dass er nicht von Ausreißern oder Extremwerten beeinflusst wird. Schauen wir uns an, was passiert, wenn wir unsere größte Körpergröße (190 cm) so ändern, dass sie der Größe der derzeit größten Person der Welt entspricht: 251 cm.\n\ndf_groesste &lt;- df_groesse |&gt; mutate(groesse = ifelse(groesse == 190, 251, groesse))\n\n\nsort(df_groesste$groesse)\n\n[1] 163 164 167 167 170 171 182 189 251\n\n\n\nmedian(df_groesste$groesse)\n\n[1] 170\n\n\n\nmean(df_groesste$groesse)\n\n[1] 180.4444\n\n\nWir sehen, dass sich der Mittelwert von ungefähr 174cm auf 180cm geändert hat. Der Median blieb jedoch gleich (170 cm), weil der Mittelwert unabhängig von den anderen Werten in einem Datensatz ist. Aus diesem Grund wird der Median häufig anstelle des Mittelwerts angegeben, wenn die Daten stark zu extremeren Werten neigen, wie z. B. bei der Angabe der Einkommen in einer Bevölkerung. Durchschnittseinkommen können aufgrund einer kleinen Gruppe von extrem gut Verdienenden stark verzerrt sein und sind in der Regel nicht repräsentativ für das Einkommen der Mehrheit der Bürger.\n\n\n7.2.2.4 Modus\nDer Modus ist der Wert, der in einem Datensatz am häufigsten vorkommt, und ist ein weiteres Maß für die zentrale Tendenz. Es gibt keine R-Funktion, um den Modus zu bestimmen, aber wir haben bereits einige gängige Möglichkeiten gesehen, ihn zu visualisieren: mit einem Histogramm oder einem Dichteplot.\n\ndf_groesse |&gt;\n  ggplot(aes(x = groesse)) +\n  geom_histogram(binwidth = .5) +\n  theme_minimal() \n\n\n\n\n\n\n\n\n\n\n\n7.2.3 Streuungsmaße\nMaße der zentralen Tendenz beschreiben (normalerweise) die Mitte der Daten. Streuungsmaße beschreiben die Streuung der Datenpunkte und sagen etwas darüber aus, wie die Daten insgesamt verteilt sind.\n\n7.2.3.1 Bereich\nDer “Bereich” von Werten kann sich auf den höchsten (maximalen) und den niedrigsten (minimalen) Wert oder auf die Differenz zwischen höchstem und niedrigstem Wert beziehen. Die R-Basisfunktionen max() und min() geben die höchsten und niedrigsten Werte aus.\n\nmax(groesse)\n\n[1] 190\n\n\n\nmin(groesse)\n\n[1] 163\n\n\nOder wir können einfach die Funktion range() verwenden, die diese beiden Zahlen nebeneinander ausgibt.\n\nrange(groesse)\n\n[1] 163 190\n\n\nWir können die Differenz zwischen diesen Werten ermitteln, indem wir den Minimalwert vom Maximalwert subtrahieren.\n\nmax(groesse) - min(groesse)\n\n[1] 27\n\n\nIn einem Histogramm oder Dichteplot werden diese Werte durch den niedrigsten und den höchsten Wert auf der x-Achse dargestellt.\n\n\n\n\n\n\n\n\n\n\n\n7.2.3.2 Standardabweichung (sd oder \\(\\sigma\\))\nDie Standardabweichung ist ein Maß dafür, wie weit die Daten im Verhältnis zum Mittelwert gestreut sind. Eine niedrige Standardabweichung bedeutet, dass die Daten um den Mittelwert herum gruppiert sind (d. h. es gibt weniger Streuung), während eine hohe Standardabweichung bedeutet, dass die Daten stärker gestreut sind. Ob eine Standardabweichung hoch oder niedrig ist, hängt von der Skala und der Maßeinheit ab, in der die Daten vorliegen. Die Standardabweichung wird sehr oft angegeben, wenn der Mittelwert berichtet wird.\nDie Standardabweichung (sd) ist gleich der Quadratwurzel (\\(\\sqrt{}\\) oder sqrt() in R) der Summe der quadrierten Wertabweichungen vom Mittelwert (\\((x - \\mu)^2\\)) geteilt durch die Anzahl der Beobachtungen minus 1 (\\(n-1\\)), angegeben in Gleichung \\(\\ref{eq-sd}\\).\n\\[\\begin{align}\n\\sigma & = \\sqrt{\\frac{(x_1-\\mu)^2 + (x_2-\\mu)^2 + ... + (x_N-\\mu)^2}{N-1}} \\label{eq-sd}\n\\end{align}\\]\nDas sieht einschüchternd aus, aber wir können die Standardabweichung in R mit der Funktion sd() berechnen.\n\nsd(groesse)\n\n[1] 10.46157\n\n\nWenn man jedoch weiß, wie man die Standardabweichung von Hand berechnen kann, versteht man, was die Zahl bedeutet. Lassen Sie uns die Berechnung der Standardabweichung für eine kleine Gruppe von Werten üben. Unter Berücksichtigung der Gleichung für die Standardabweichung in \\(\\ref{eq-sd}\\) können wir die Standardabweichung von Hand berechnen, wenn wir den Wert jeder Beobachtung, den Mittelwert dieser Werte und die Anzahl dieser Werte kennen. In einem Vektor mit 3 Beobachtungen (3, 5, 9) sind unsere Werte (\\(x\\)) zum Beispiel folgende:\n\nvalues &lt;- c(3,5,16)\nvalues\n\n[1]  3  5 16\n\n\nSetzt man diese in die Gleichung für die Standardabweichung ein, erhält man Gleichung \\(\\ref{eq-sd1}\\).\n\\[\\begin{align}\n\\sigma & = \\sqrt{\\frac{(3-\\mu)^2 + (5-\\mu)^2 + (16-\\mu)^2}{N-1}} \\label{eq-sd1}\n\\end{align}\\]\nUnser Mittelwert (\\(\\mu\\)) ist:\n\nmean(values)\n\n[1] 8\n\n\nWenn wir dies zu Gleichung \\(\\ref{eq-sd1}\\) hinzufügen, erhalten wir Gleichung \\(\\ref{eq-sd2}\\).\n\\[\\begin{align}\n\\sigma & = \\sqrt{\\frac{(3-8)^2 + (5-8)^2 + (16-8)^2}{N-1}} \\label{eq-sd2}\n\\end{align}\\]\nDie Anzahl der Werte (\\(n\\)) ist:\n\nlength(values)\n\n[1] 3\n\n\nWenn wir dies zu Gleichung \\(\\ref{eq-sd2}\\) hinzufügen, erhalten wir Gleichung \\(\\ref{eq-sd3}\\).\n\\[\\begin{align}\n\\sigma & = \\sqrt{\\frac{(3-8)^2 + (5-8)^2 + (16-8)^2}{3-1}} \\label{eq-sd3}\n\\end{align}\\]\nIf we carry out all of the operations following PEDMAS, then we get Equations \\(\\ref{eq-sd4}\\) through \\(\\ref{eq-sd}\\):\n\\[\\begin{align}\n\\sigma & = \\sqrt{\\frac{(-5)^2 + (-3)^2 + (8)^2}{3-1}} \\\\ \\label{eq-sd4}\n\\\\\n& = \\sqrt{\\frac{25 + 9 + 64}{3-1}}\n\\\\\n& = \\sqrt{\\frac{98}{2}} \\\\\n& = \\sqrt{49} \\\\\n& = 7\n\\end{align}\\]\nUm unsere Arbeit zu überprüfen, berechnen wir die Standardabweichung (\\(\\sigma\\)) in “R”:\n\nsd(values)\n\n[1] 7\n\n\n\n\n7.2.3.3 Warum Standardabweichung?\nDie Standardabweichung ist ein Maß dafür, wie “eng” die beobachteten Werte am Mittelwert liegen. Wenn die meisten Beobachtungen sehr nahe am Mittelwert liegen, ist die Standardabweichung im Verhältnis zum Mittelwert eine kleine Zahl. Wenn es viele Beobachtungen mit großen Abweichungen vom Mittelwert gibt, wird die Standardabweichung tendenziell eine große Zahl sein (relativ zum Mittelwert).\nVerschiedene Datensätze können denselben Mittelwert, aber sehr unterschiedliche Standardabweichungen aufweisen. Ein Beispiel:\n\nvalues2 &lt;- c(55,55,55,55,55,57,57,57,57,57)\nvalues3 &lt;- c(1,1,1,1,100,100,100,100,100)\n\n\nmean(values2)\n\n[1] 56\n\n\n\nmean(values3)\n\n[1] 56\n\n\nWir sehen, dass values2 und values3 den gleichen Mittelwert haben. Daraus könnte man schließen, dass die Daten ähnlich sind. Aber ihre Standardabweichungen werden sich unterscheiden, weil ihre jeweiligen beobachteten Werte alle unterschiedlich weit vom Mittelwert abweichen. Welcher Vektor wird Ihrer Meinung nach die geringste Standardabweichung haben? Und warum?\n\nsd(values2)\n\n[1] 1.054093\n\n\n\nsd(values3)\n\n[1] 52.17758\n\n\nDie größere Standardabweichung für Werte3 spiegelt die Tatsache wider, dass die Werte tendenziell sehr weit vom Mittelwert entfernt sind. Die kleinere Standardabweichung für Werte2 spiegelt die Tatsache wider, dass der Wert für diese Variable tendenziell recht nahe am Mittelwert liegt.\n\n\n\n\n\n\nQuadrat und Quadratwurzel\n\n\n\nWarum quadrieren wir die Abweichung jeder Beobachtung vom Mittelwert, um dann später die Quadratwurzel aus ihrer Summe geteilt durch \\(N-1\\) zu berechnen? Da die Hälfte unserer Beobachtungen unterhalb und die Hälfte oberhalb des Mittelwerts liegen wird, sind die resultierenden Differenzen, wenn wir den Mittelwert von den Werten abziehen, zur Hälfte negativ und zur Hälfte positiv. Wenn wir positive und negative Werte zusammenzählen, heben sie sich gegenseitig auf. Wenn wir also alle diese Abweichungen vom Mittelwert quadrieren, werden alle Werte positiv sein (eine positive Zahl multipliziert mit einer positiven Zahl ist eine positive Zahl, während eine negative Zahl multipliziert mit sich selbst ebenfalls eine positive Zahl ergibt). Wenn wir dann die Quadratwurzel dieser Werte berechnen, erhalten wir die ursprüngliche Größe der Abweichung, aber immer als positiven Wert.\n\n\n\n\n\n\n\n\nEigenschaften der Grundgesamtheit\n\n\n\nSowohl der Mittelwert als auch die Standardabweichung sagen etwas über die Grundgesamtheit aus, aus der unsere Datenstichprobe stammt. Je mehr Beobachtungen wir sammeln, desto genauer werden diese Maße im Durchschnitt sein.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#deskriptive-statistiken-mit-r",
    "href": "mats/08-desc_stats.html#deskriptive-statistiken-mit-r",
    "title": "7  Deskriptive Statistik",
    "section": "7.3 Deskriptive Statistiken mit R",
    "text": "7.3 Deskriptive Statistiken mit R\nWir haben bereits einige nützliche Funktionen zur Berechnung von zusammenfassenden Statistiken gesehen (z.B. mean(), median(), sd()). In der Regel möchten wir jedoch mehrere zusammenfassende Statistiken auf einmal erstellen und zusammenfassende Statistiken zwischen Gruppen vergleichen. Um dies zu erreichen, bietet das Paket dplyr aus dem tidyverse einige hilfreiche Funktionen. Lassen Sie uns nun den df_eng-Datensatz verwenden, um diese dplyr-Verben kennenzulernen.\n\n7.3.1 dplyr::summarise\nDie Funktion summarise() von dplyr berechnet Zusammenfassungen von Daten, aber wir müssen ihr sagen, was sie berechnen soll, und für welche Variable(n). Die Funktion n() liefert zum Beispiel die Anzahl der Beobachtungen (nur wenn sie innerhalb von summarise() oder mutate() verwendet wird). Lassen Sie uns zunächst prüfen, wie viele Beobachtungen wir im Datensatz df_eng haben:\n\ndf_eng |&gt;\n  summarise(N = n())\n\n# A tibble: 1 × 1\n      N\n  &lt;int&gt;\n1  4568\n\n\nWerfen wir nun einen Blick auf das Histogramm von rt_lexdec, der Variable, die die lexikalische Entscheidungsantwortzeit in Millisekunden enthält:\n\ndf_eng |&gt; \n  ggplot() +\n  aes(x = rt_lexdec) +\n  geom_histogram()\n\n\n\n\n\n\n\n\nWir sehen, dass die Antwortzeit zwischen 500 ms und 1320 ms liegt, wobei die meisten Antworten zwischen 550 ms und 900 ms liegen. Wir sehen auch eine bimodale Verteilung, d. h. es gibt zwei Modi (zwei Spitzen). Der allgemeine Modus liegt bei 700 ms (500 Beobachtungen), mit einer zweiten Spitze bei 600 ms (~420 Beobachtungen).\nWir können auch mehrere Berechnungen auf einmal durchführen. Lassen Sie uns auch den Mittelwert und die Standardabweichung der lexikalischen Entscheidungsaufgabe (rt_lexdec, in Millisekunden) berechnen.\n\ndf_eng |&gt;\n  summarise(mean_lexdec = mean(rt_lexdec, na.rm=T),\n            sd_lexdec = sd(rt_lexdec, na.rm = T),\n            N = n()) \n\n# A tibble: 1 × 3\n  mean_lexdec sd_lexdec     N\n        &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n1        708.      115.  4568\n\n\nJetzt sehen wir, dass die durchschnittliche lexikalische Entscheidungsantwortzeit 708.1 ms betrug, mit einer Standardabweichung von 114.9.\nUnd wir können Berechnungen mit typischen mathematischen Operatoren (z.B. +, -, /, *, ^ …) und/oder Funktionen angeben. Was war der Unterschied zwischen der längsten und der kürzesten lexikalischen Entscheidungsantwortzeit?\n\ndf_eng |&gt;\n  summarise(range_lexdec = max(rt_lexdec) - min(rt_lexdec))\n\n# A tibble: 1 × 1\n  range_lexdec\n         &lt;dbl&gt;\n1         828.\n\n\n\n\n\n\n\n\nFehlende Werte\n\n\n\nEinige Berechnungen sind nicht möglich, wenn Werte fehlen. Die Variable rt_naming hat einen fehlenden Wert. Dies ist in der Ausgabe der Funktion summary() zu sehen, die vor der Berechnung der zusammenfassenden Statistik alle NA-Werte löscht.\n\ndf_eng |&gt;\n  select(rt_lexdec, rt_naming) |&gt;\n  summary()\n\n   rt_lexdec        rt_naming    \n Min.   : 495.4   Min.   :412.3  \n 1st Qu.: 617.4   1st Qu.:468.1  \n Median : 699.6   Median :570.6  \n Mean   : 708.1   Mean   :565.9  \n 3rd Qu.: 775.3   3rd Qu.:658.4  \n Max.   :1323.2   Max.   :808.9  \n                  NA's   :1      \n\n\nDie Funktion mean() entfernt jedoch nicht die NA-Werte.\n\ndf_eng |&gt;\n  summarise(mean_naming = mean(rt_naming))\n\n# A tibble: 1 × 1\n  mean_naming\n        &lt;dbl&gt;\n1          NA\n\n\nWas tun wir mit fehlenden Werten? Bei der Arbeit mit realen Daten ist es nicht trivial, wie wir mit fehlenden Werten umgehen. Wir könnten z. B. alle NA-Werte in 0 umwandeln, wenn wir wollen, dass sie zur Berechnung des Mittelwerts beitragen. Meistens wollen wir sie jedoch einfach entfernen.\nWir können dies leicht mit dem dplyr-Verb drop_na() tun:\n\ndf_eng |&gt;\n  drop_na() |&gt;\n  summarise(mean_naming = mean(rt_naming))\n\n# A tibble: 1 × 1\n  mean_naming\n        &lt;dbl&gt;\n1        566.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#gruppierung-von-variablen",
    "href": "mats/08-desc_stats.html#gruppierung-von-variablen",
    "title": "7  Deskriptive Statistik",
    "section": "7.4 Gruppierung von Variablen",
    "text": "7.4 Gruppierung von Variablen\nWir wollen jedoch nicht immer nur die zusammenfassenden Statistiken für einen gesamten Datensatz kennen. Normalerweise wollen wir bestimmte Gruppen vergleichen (z. B. Vergleich der Reaktionszeiten bei lexikalischen Entscheidungen zwischen Altersgruppen)\n\n7.4.1 .by =\nDas semi-neue (und experimentelle) Argument .by = in summarise() berechnet unsere Berechnungen auf gruppierten Teilmengen der Daten. Es nimmt eine Variable (d.h. einen Spaltennamen) und gruppiert nach den Stufen dieser Variable.\n\ndf_eng |&gt;\n  drop_na() |&gt;\n  summarise(mean_lexdec = mean(rt_lexdec),\n            sd_lexdec = sd(rt_lexdec),\n            N = n(),\n            .by = age_subject) |&gt;\n  arrange(mean_lexdec)\n\n# A tibble: 2 × 4\n  age_subject mean_lexdec sd_lexdec     N\n  &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n1 young              630.      69.1  2283\n2 old                787.      96.2  2284\n\n\n\n\n7.4.2 Gruppieren nach mehreren Variablen\n\nWir können auch nach mehreren Variablen gruppieren\n\ndafür brauchen wir concatenate (c())\n\n\n\ndf_eng |&gt;\n  drop_na() |&gt;\n  summarise(mean_lexdec = mean(rt_lexdec),\n            sd_lexdec = sd(rt_lexdec),\n            N = n(),\n            .by = c(age_subject, word_category)) |&gt;\n  arrange(age_subject)\n\n# A tibble: 4 × 5\n  age_subject word_category mean_lexdec sd_lexdec     N\n  &lt;chr&gt;       &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n1 old         N                    790.     101.   1452\n2 old         V                    780.      86.5   832\n3 young       N                    633.      70.8  1451\n4 young       V                    623.      65.7   832\n\n\n\n\n\n\n\n\ngroup_by()\n\n\n\n\nAnstelle des neuen .by-Arguments können wir das dplyr-Verb group_by() und ungroup() verwenden\n\nIch bevorzuge das neue .by, weil es die Gruppierung lokal hält (keine Notwendigkeit für ungroup())\nBehalten Sie dies im Hinterkopf, Sie könnten group_by() in freier Wildbahn sehen\n\n\n\ndf_eng |&gt;\n  group_by(age_subject, word_category) |&gt; \n  summarise(mean_lexdec = mean(rt_lexdec),\n            sd_lexdec = sd(rt_lexdec),\n            N = n()) |&gt; \n  ungroup() |&gt; \n  arrange(age_subject)\n\n# A tibble: 4 × 5\n  age_subject word_category mean_lexdec sd_lexdec     N\n  &lt;chr&gt;       &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n1 old         N                    790.     101.   1452\n2 old         V                    780.      86.5   832\n3 young       N                    633.      70.8  1452\n4 young       V                    623.      65.7   832",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#anscombes-quartett",
    "href": "mats/08-desc_stats.html#anscombes-quartett",
    "title": "7  Deskriptive Statistik",
    "section": "7.5 Anscombes Quartett",
    "text": "7.5 Anscombes Quartett\nFrancis Anscombe erstellte 1973 vier Datensätze, um zu veranschaulichen, wie wichtig es ist, Daten zu visualisieren, bevor man sie analysiert und ein Modell erstellt. Diese vier Diagramme stellen 4 Datensätze dar, die alle einen nahezu identischen Mittelwert und eine Standardabweichung, aber sehr unterschiedliche Verteilungen aufweisen.\n\n\n\n\nTabelle 7.2: Summary stats of Anscombe’s quratet datasets\n\n\n\n\n\n\n\ngrp\nmean_x\nmean_y\nmin_x\nmin_y\nmax_x\nmax_y\ncrrltn\n\n\n\n\nGroup 1\n9\n7.500909\n4\n4.26\n14\n10.84\n0.8164205\n\n\nGroup 2\n9\n7.500909\n4\n3.10\n14\n9.26\n0.8162365\n\n\nGroup 3\n9\n7.500000\n4\n5.39\n14\n12.74\n0.8162867\n\n\nGroup 4\n9\n7.500909\n8\n5.25\n19\n12.50\n0.8165214\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 7.1: Plots of Anscombe’s quratet distributions\n\n\n\n\n\n\n7.5.1 DatasaurRus\nDas Paket datasauRus (Davies et al., 2022) enthält einige weitere Datensätze, die ähnliche Mittelwerte und sd, aber unterschiedliche Verteilungen aufweisen, die in Tabelle 7.3 angegeben sind.\n\npacman::p_load(\"datasauRus\")\n\n\ndatasaurus_dozen |&gt;\n  filter(dataset != \"x_shape\") |&gt; \n    group_by(dataset) |&gt;\n    summarize(\n      mean_x    = mean(x),\n      mean_y    = mean(y),\n      std_dev_x = sd(x),\n      std_dev_y = sd(y),\n      corr_x_y  = cor(x, y)\n    ) |&gt;\n  knitr::kable() |&gt;\n  kableExtra::kable_styling(font_size = 20)\n\n\n\nTabelle 7.3: Summary stats of datasauRus datasets\n\n\n\n\n\n\n\ndataset\nmean_x\nmean_y\nstd_dev_x\nstd_dev_y\ncorr_x_y\n\n\n\n\naway\n54.26610\n47.83472\n16.76983\n26.93974\n-0.0641284\n\n\nbullseye\n54.26873\n47.83082\n16.76924\n26.93573\n-0.0685864\n\n\ncircle\n54.26732\n47.83772\n16.76001\n26.93004\n-0.0683434\n\n\ndino\n54.26327\n47.83225\n16.76514\n26.93540\n-0.0644719\n\n\ndots\n54.26030\n47.83983\n16.76774\n26.93019\n-0.0603414\n\n\nh_lines\n54.26144\n47.83025\n16.76590\n26.93988\n-0.0617148\n\n\nhigh_lines\n54.26881\n47.83545\n16.76670\n26.94000\n-0.0685042\n\n\nslant_down\n54.26785\n47.83590\n16.76676\n26.93610\n-0.0689797\n\n\nslant_up\n54.26588\n47.83150\n16.76885\n26.93861\n-0.0686092\n\n\nstar\n54.26734\n47.83955\n16.76896\n26.93027\n-0.0629611\n\n\nv_lines\n54.26993\n47.83699\n16.76996\n26.93768\n-0.0694456\n\n\nwide_lines\n54.26692\n47.83160\n16.77000\n26.93790\n-0.0665752\n\n\n\n\n\n\n\n\n\n\n\nWenn wir die Datensätze grafisch darstellen, sehen sie alle sehr unterschiedlich aus (Abbildung 7.2)!\n\n\n\n\n\n\n\n\nAbbildung 7.2: Plots of datasauRus dataset distributions\n\n\n\n\n\nDer Punkt hier ist: Stellen Sie Ihre Daten immer grafisch dar und betrachten Sie nicht nur die beschreibenden Statistiken!!! Beides ist sehr wichtig für das Verständnis Ihrer Daten. Wir haben bereits gesehen, wie wir unsere Rohdaten mithilfe von Histogrammen, Dichteplots, Balkendiagrammen und Streudiagrammen darstellen können. Nächste Woche werden wir uns ansehen, wie wir unsere zusammenfassenden Statistiken darstellen und wie wir die Rohdaten in die Darstellung mit mehrteiligen Diagrammen einbeziehen können.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#lernziele-1",
    "href": "mats/08-desc_stats.html#lernziele-1",
    "title": "7  Deskriptive Statistik",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nToday we learned…\n\nüber Maße der zentralen Tendenz ✅\nüber Streuungsmaße ✅\nwie man die Funktion summarise() von dplyr verwendet ✅\nwie man Zusammenfassungen nach Gruppen erstellt ✅",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#weitere-übungen",
    "href": "mats/08-desc_stats.html#weitere-übungen",
    "title": "7  Deskriptive Statistik",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.7",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/08-desc_stats.html#session-info",
    "href": "mats/08-desc_stats.html#session-info",
    "title": "7  Deskriptive Statistik",
    "section": "Session Info",
    "text": "Session Info\nErstellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] datasauRus_0.1.8 patchwork_1.2.0  janitor_2.2.0    here_1.0.1      \n [5] lubridate_1.9.3  forcats_1.0.0    stringr_1.5.1    dplyr_1.1.4     \n [9] purrr_1.0.2      readr_2.1.5      tidyr_1.3.1      tibble_3.2.1    \n[13] ggplot2_3.5.1    tidyverse_2.0.0 \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        xml2_1.3.6       \n [5] lattice_0.22-6    stringi_1.8.3     hms_1.1.3         digest_0.6.35    \n [9] magrittr_2.0.3    evaluate_0.23     grid_4.4.0        timechange_0.3.0 \n[13] fastmap_1.1.1     Matrix_1.7-0      rprojroot_2.0.4   jsonlite_1.8.8   \n[17] mgcv_1.9-1        fansi_1.0.6       viridisLite_0.4.2 scales_1.3.0     \n[21] cli_3.6.2         rlang_1.1.3       crayon_1.5.2      splines_4.4.0    \n[25] bit64_4.0.5       munsell_0.5.1     withr_3.0.0       yaml_2.3.8       \n[29] parallel_4.4.0    tools_4.4.0       tzdb_0.4.0        colorspace_2.1-0 \n[33] pacman_0.5.1      kableExtra_1.4.0  vctrs_0.6.5       R6_2.5.1         \n[37] lifecycle_1.0.4   snakecase_0.11.1  htmlwidgets_1.6.4 bit_4.0.5        \n[41] vroom_1.6.5       pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.5     \n[45] glue_1.7.0        systemfonts_1.0.6 highr_0.10        xfun_0.43        \n[49] tidyselect_1.2.1  rstudioapi_0.16.0 knitr_1.46        farver_2.1.1     \n[53] nlme_3.1-164      htmltools_0.5.8.1 labeling_0.4.3    svglite_2.1.3    \n[57] rmarkdown_2.26    compiler_4.4.0   \n\n\n\n\n\n\n\n\nDavies, R., Locke, S., & D’Agostino McGowan, L. (2022). datasauRus: Datasets from the Datasaurus Dozen. https://CRAN.R-project.org/package=datasauRus\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. In Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Deskriptive Statistik</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html",
    "href": "mats/09-dataviz_3.html",
    "title": "8  Datenvisualisierung 3",
    "section": "",
    "text": "Lernziele\nIn diesem Kapital lernen wir wie man…",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#lernziele",
    "href": "mats/09-dataviz_3.html#lernziele",
    "title": "8  Datenvisualisierung 3",
    "section": "",
    "text": "Boxplots zu erstellen und zu interpretieren\nMittelwerte und Standardabweichungen zu visualisieren",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#ressourcen",
    "href": "mats/09-dataviz_3.html#ressourcen",
    "title": "8  Datenvisualisierung 3",
    "section": "Ressourcen",
    "text": "Ressourcen\nFür weitere Lektüre und Übungen zu diesem Thema empfehle ich die Lektüre von Abschnitt 2.5 (Visualisierung von Relationen) in Wickham et al. (2023), Kapitel 4 (Darstellung von zusammenfassenden Statistiken) in Nordmann et al. (2022) und die Abschnitte 3.5-3.9 in Winter (2019).",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#wiederholung",
    "href": "mats/09-dataviz_3.html#wiederholung",
    "title": "8  Datenvisualisierung 3",
    "section": "Wiederholung",
    "text": "Wiederholung\nIm letzten Kapitel haben wir etwas über deskriptive Statistik gelernt, insbesondere über Maße der zentralen Tendenz (Mittelwert, Median, Modus) und der Streuung (Bereich, Standardabweichung). Wir haben auch gesehen, wie man diese Werte mit Base R (z. B. mean(), sd()) und der tidyverse (z. B. summarise()) und nach Gruppen (summarise(.by = )) berechnet.\nIn diesem Kapitel werden wir das Konzept der aufgeräumten Daten besprechen und sehen, wie wir unsere Daten organisieren und neu anordnen können, damit sie aufgeräumt sind.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#sec-data_viz3_setup",
    "href": "mats/09-dataviz_3.html#sec-data_viz3_setup",
    "title": "8  Datenvisualisierung 3",
    "section": "8.1 Einrichten {.unnumbered}",
    "text": "8.1 Einrichten {.unnumbered}\n\nPakete\nWie üblich laden wir die tidyverse Familie von Paketen. Um uns beim Laden unserer Daten zu helfen, laden wir auch das here-Paket und das janitor-Paket, das nützlich ist, um unsere Daten aufzuräumen (z.B. die clean_names()-Funktion). Um unsere Diagramme anzupassen, verwenden wir auch die Pakete ggthemes und patchwork. Ersteres hilft uns bei der Erstellung von farbenblindenfreundlichen Diagrammen, während letzteres uns erlaubt, mehrere Diagramme zusammen zu drucken.\n\npacman::p_load(tidyverse,\n               here,\n               janitor,\n               ggthemes,\n               patchwork)\n\n\n\nDaten\nWir arbeiten wieder mit unserer leicht veränderten Version des english-Datensatzes aus dem languageR-Paket. Sie sollten langaugeR_english.csv in Ihrem Daten Ordner haben. Der folgende Code lädt den Datensatz, bereinigt die Namen und korrigiert einige fehlerhafte Namen.\n\ndf_eng &lt;- read_csv(\n  here(\n    \"daten\",\n    \"languageR_english.csv\"\n  )\n) |&gt; \n  clean_names() |&gt; \n  rename(\n    rt_lexdec = r_tlexdec,\n    rt_naming = r_tnaming\n  )",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#rückblick-visualisierung-von-verteilungen",
    "href": "mats/09-dataviz_3.html#rückblick-visualisierung-von-verteilungen",
    "title": "8  Datenvisualisierung 3",
    "section": "8.2 Rückblick: Visualisierung von Verteilungen",
    "text": "8.2 Rückblick: Visualisierung von Verteilungen\nWir haben bereits mehrere Arten von Diagrammen gesehen, die zur Visualisierung der Verteilung und der Beziehungen zwischen Variablen verwendet werden:\n\nHistogramme (1 numerische Variable)\nDichteplots (1 numerische Variable)\nStreudiagramme (2 numerische Variablen)\nBalkendiagramme (kategorische Variablen)\n\nSchauen Sie sich jede Abbildung in Abbildung 8.1 an. Wie viele Variablen werden jeweils dargestellt, und um welche Typen von Variablen handelt es sich? Welche zusammenfassende(n) Statistik(en) wird/werden in jedem Diagramm dargestellt?\n\n\n\n\n\n\n\n\nAbbildung 8.1: Verschiedene Diagrammtypen zur Visualisierung der Verteilung von Rohdaten: Histogramm (A), Dichte-Diagramm (B), Streudiagramm (C), gestapeltes Balkendiagramm (D) und unscharfes Balkendiagramm (E)",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#darstellung-von-zusammenfassenden-statistiken",
    "href": "mats/09-dataviz_3.html#darstellung-von-zusammenfassenden-statistiken",
    "title": "8  Datenvisualisierung 3",
    "section": "8.3 Darstellung von zusammenfassenden Statistiken",
    "text": "8.3 Darstellung von zusammenfassenden Statistiken\nIn ?sec-desc-stats haben wir etwas über zusammenfassende Statistiken gelernt. Wir behandelten Maße der zentralen Tendenz, nämlich Modus, Median und Mittelwert, sowie Maße der Streuung, wie Bereich und Standardabweichung. Wie können wir zusammenfassende Statistiken visualisieren?\nWir haben bereits gesehen, dass Histogramme, Dichtediagramme und nun auch Geigenplots den Modus (höchster Wert) und den Bereich (niedrigster und höchster Wert) visualisieren. Jetzt lernen wir zwei weitere Arten von Diagrammen kennen, eines zur Darstellung der Verteilung der beobachteten Werte und eines zur Darstellung von Mittelwert und Standardabweichung.\n\n8.3.1 Boxplot\nBoxplots (manchmal auch Box-and-Whisker-Plots genannt, z. B. Abbildung 11.2) bestehen aus einer Box mit einer Linie in der Mitte (die “Box”) und Linien, die an beiden Enden der Box herausragen (die “Whisker”), sowie manchmal einigen Punkten. Schauen Sie sich Abbildung 11.2 an und identifizieren Sie jeden dieser 4 Aspekte der Darstellung. Kannst du erraten, was jeder dieser Aspekte darstellen könnte und wie du die Darstellung interpretieren solltest?\n\n\n\n\n\n\n\n\nAbbildung 8.2: Boxplot von df_eng (Körpermasse nach Alter_Proband)\n\n\n\n\n\nDie Box und die Whiskers stellen eine Vielzahl von Informationen in einer einzigen Visualisierung dar. Die Linie in der Mitte des Boxplots stellt den Median dar, auch Q2 genannt (2. Quartil; der mittlere Wert, über/unter dem 50% der Daten liegen). Die Box selbst stellt den Interquartilsbereich (IQR; der Wertebereich, der zwischen den mittleren 50% der Daten liegt) dar. Die Grenzen der Box stellen Q1 (1. Quartil, unter dem 25% der Daten liegen) und Q3 (3. Quartil, über dem 25% der Daten liegen) dar. Die Whisker stellen 1,5*IQR von Q1 (unterer Whisker) oder Q3 (oberer Whisker) dar. Alle Punkte, die außerhalb der Whisker liegen, stellen Ausreißer dar (d. h. Extremwerte, die außerhalb des IQR liegen).\nAbbildung 8.3 zeigt die Beziehung zwischen der Verteilung einer Variablen, wie sie in einem Histogramm dargestellt wird, und einem Boxplot. Während das Histogramm die Balkenhöhe verwendet, um die Anzahl der Beobachtungen innerhalb eines bestimmten Bereichs anzuzeigen, verwendet der Boxplot die Box und die Whiskers, um die Schwellenwerte anzugeben, in denen bestimmte Anteile der Daten enthalten sind (d. h. der Interquartilsbereich).\n\n\n\n\n\n\n\n\nAbbildung 8.3: Image source: Winter (2019) (all rights reserved)\n\n\n\n\n\nAbbildung 8.4 bietet einen ähnlichen Vergleich, wobei die einzelnen Beobachtungen im Streudiagramm auf der linken Seite hinzugefügt wurden.\n\n\n\n\n\n\n\n\nAbbildung 8.4: Image source: Wickham et al. (2023) (all rights reserved)\n\n\n\n\n\nIch hoffe, Sie haben jetzt ein wenig verstanden, wie man Boxplots interpretiert. Man braucht etwas Übung, aber das Wichtigste ist, sich daran zu erinnern, dass die mittleren 50% der Daten in der Box enthalten sind, während die “Schwänze” der Daten durch die “Whisker” dargestellt werden.\n\n8.3.1.1 geom_boxplot()\nWir können Boxplots mit der Funktion geom_boxplot() von ggplot2 erstellen. Zumindest müssen wir eine numerische Variable als x oder y Achse angeben (Abbildung 8.5). Wenn wir Boxplots für verschiedene Gruppen erstellen wollen, können wir den Namen einer kategorischen Variable auf der anderen Achse angeben (Abbildung 8.6).\n\ndf_eng |&gt; \n  ggplot(aes(y = rt_lexdec)) +\n  geom_boxplot() +\n  theme_bw() +\n  theme(axis.text.x = element_blank(),\n        axis.ticks.x = element_blank())\n\n\n\n\n\n\n\nAbbildung 8.5: Ein Boxplot für alle Beobachtungen einer kontinuierlichen Variablen\n\n\n\n\n\n\ndf_eng |&gt; \n  ggplot(aes(x = age_subject, y = rt_lexdec)) +\n  geom_boxplot() +\n  theme_bw()\n\n\n\n\n\n\n\nAbbildung 8.6: Ein Boxplot für zwei Gruppen\n\n\n\n\n\n\n\n8.3.1.2 Gruppierter Boxplot\nGenau wie ein Bargraph können wir gruppierte Boxplots erstellen, um mehr Variablen zu visualisieren. Ordnen Sie einfach eine neue Variable mit colour oder fill ästhetisch zu.\n\ndf_eng |&gt; \n  ggplot(aes(x = age_subject, y = rt_lexdec, colour = word_category)) +\n  geom_boxplot() +\n  labs(\n    x = \"Altersgruppe\",\n    y = \"LDT-Reaktionszeit (ms)\",\n    color = \"Wortart\"\n  ) +\n  scale_colour_colorblind() +\n  theme_bw()\n\n\n\n\nEin gruppierter Boxplot\n\n\n\n\n\n\n\n\n\n\nBoxplots in R\n\n\n\nMit der Funktion boxplot(), die einen kontinuierlichen (d.h. numerischen) Vektor als Argument akzeptiert, kann ein Boxplot in der Base-R-Syntax erstellt werden. Da Datenrahmen eine Ansammlung von Vektoren (d.h. die Variablen/Spalten) gleicher Länge sind, können wir auch eine kontinuierliche Variable in einem Datenrahmen als Argument verwenden. Dazu verwenden wir den Subsetting-Operator $, der einen Datenrahmen in eine einzelne Variable, in unserem Fall rt_lexdec, unterteilt.\n\nboxplot(df_eng$rt_lexdec)\n\n\n\n\n\n\n\nAbbildung 8.7: Boxplot erstellt mit Basis R\n\n\n\n\n\nWir können auch eine kategoriale Variable als “Prädiktor” verwenden, mit der Syntax kontinuierlich ~ kategorisch, wobei ~ als “vorhergesagt von” gelesen werden kann.\n\nboxplot(df_eng$rt_lexdec ~ df_eng$age_subject)\n\n\n\n\n\n\n\nAbbildung 8.8: Boxplot erstellt mit Basis R",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#visualisierung-des-mittelwerts",
    "href": "mats/09-dataviz_3.html#visualisierung-des-mittelwerts",
    "title": "8  Datenvisualisierung 3",
    "section": "8.4 Visualisierung des Mittelwerts",
    "text": "8.4 Visualisierung des Mittelwerts\nBoxplots zeigen ein Maß für die zentrale Tendenz (Median) und mehrere Maße für die Streuung. In der Regel wird auch der Mittelwert mit der Standardabweichung dargestellt.1. Wie könnte man dies tun?\n\n8.4.1 Fehlerbalken-Diagramme\nFehlerbalkendiagramme werden üblicherweise verwendet, um den Mittelwert und die Standardabweichung mit Hilfe von Fehlerbalken zu visualisieren. Auch hier werden in der Regel Standardfehler oder Konfidenzintervalle (oder glaubwürdige Intervalle) durch Fehlerbalken dargestellt, die wir in diesem Kurs jedoch nicht behandeln werden. Diese Diagramme bestehen aus zwei Teilen: dem Mittelwert, der mit geom_point() dargestellt wird, und der Standardabweichung, die mit geom_errorbar() dargestellt wird. Die Fehlerbalken stellen den Bereich von 1 Standardabweichung über und unter dem Mittelwert dar (Mittelwert +/- 1SD).\n\n\n\n\n\n\n\n\nAbbildung 8.9: Fehlerbalken-Diagramm von df_eng (Körpermasse nach Alter_Proband)\n\n\n\n\n\nEs gibt einige Möglichkeiten, Fehlerbalken-Diagramme zu erstellen, aber wir werden uns auf die Verwendung von ggplot2 und die Erstellung von zusammenfassenden Statistiken konzentrieren, wie wir sie in ?sec-desc-stats mit der Funktion summarise() von dplyr gesehen haben.\n\n8.4.1.1 Berechnung der zusammenfassenden Statistik\nZunächst müssen wir den Mittelwert und die Standardabweichung berechnen, gruppiert nach den Variablen, die wir visualisieren wollen. Bleiben wir bei rt_lexdec nach age_subject. Wie können wir den Mittelwert und die Standardabweichung von rt_lexdec nach age_subject berechnen?\n\n\nClick here to see how\ndf_eng |&gt; \n  summarise(mean = mean(rt_lexdec),\n            sd = sd(rt_lexdec),\n            N = n(),\n            .by = age_subject) |&gt; \n  arrange(age_subject)\n\n\n# A tibble: 2 × 4\n  age_subject  mean    sd     N\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 old          787.  96.2  2284\n2 young        630.  69.1  2284\n\n\nUm zusammenfassende Statistiken zu erstellen, können wir entweder den obigen Code direkt in ein ggplot-Objekt einfügen, indem wir eine Pipe verwenden, oder wir können die Zusammenfassung als ein Objekt speichern, das wir dann in ggplot einfügen. Beide Optionen erzeugen das gleiche Diagramm, wie wir unten sehen.\n\nNeues ObjektWith a pipe\n\n\n\n## Neues Objekt mit Zusammenfassungen erstellen\nsum_eng &lt;- df_eng |&gt; \n  summarise(mean = mean(rt_lexdec),\n            sd = sd(rt_lexdec),\n            N = n(),\n            .by = age_subject) |&gt; \n  arrange(age_subject, age_subject)\n\n## Neues Objekt in ggplot einfügen\nsum_eng |&gt; \n  ggplot(aes(x = age_subject, y = mean, colour = age_subject)) \n\n\n\n\n\n\n\n\n\n\n\ndf_eng |&gt; \n  summarise(mean = mean(rt_lexdec),\n            sd = sd(rt_lexdec),\n            N = n(),\n            .by = age_subject) |&gt; \n  arrange(age_subject, age_subject) |&gt; \n  arrange(age_subject, age_subject) |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean, colour = age_subject)\n\n\n\n\n\n\n\n\n\n\n\nIch neige dazu, eine Mischung aus diesen beiden Optionen zu verwenden. Manchmal erstelle ich ein neues Objekt und manchmal nicht, je nachdem, was für meinen Arbeitsablauf am sinnvollsten ist. In den Fällen, in denen ich die zusammenfassenden Statistiken auch drucken oder im Auge behalten möchte, würde ich ein Objekt erstellen, das die Zusammenfassung enthält. Dies hat den zusätzlichen Vorteil, dass es mit zusätzlichen Formatierungen gedruckt werden kann, um eine schöne Tabelle zu erstellen (wie Tabelle 8.1).\n\n\n\n\nTabelle 8.1: Formatierte Tabelle von sum_eng\n\n\n\n\n\n\n\nAltersgruppe\nMittlere LDT (ms)\nSD\nN\n\n\n\n\nold\n786.7\n96.2\n2284\n\n\nyoung\n629.5\n69.1\n2284\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.4.1.2 Plotten von Mittelwerten\nAber alles, was wir bis jetzt haben, ist eine leere Leinwand, wir müssen unsere geoms hinzufügen. Zuerst fügen wir die Mittelwerte mit geom_point() ein.\n\nsum_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n8.4.1.3 Hinzufügen von Fehlerbalken\nFügen wir nun unsere Fehlerbalken hinzu, die eine Standardabweichung über und unter dem Mittelwert darstellen. Wir tun dies mit geom_errorbar(), das ymin und ymax als Argumente benötigt. Diese sind jeweils gleich mean-/+sd. Wir haben sie der Übersichtlichkeit halber in einen weiteren aes()-Aufruf innerhalb von geom_errorbar() eingefügt, aber sie könnten auch im ersten aes()-Aufruf erscheinen.\n\nsum_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean) +\n  geom_point() +\n  geom_errorbar(aes(ymin = mean-sd, \n                    ymax = mean+sd)) +\n  theme_bw()\n\n\n\n\n\n\n\n\nHier sehen wir also den Mittelwert mit +/-1SD für die älteren und jüngeren Teilnehmergruppen. Und wenn wir einige weitere Anpassungen hinzufügen, erhalten wir ?fig-errorbar-custom.\n\nsum_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean, colour = age_subject, shape = age_subject) +\n  labs(title = \"Mittlere LDT-Zeiten (+/-1SD)\",\n    x = \"Altersgruppe\",\n    y = \"Reaktionszeit (ms)\",\n    color = \"Altersgruppe\"\n  ) +\n  geom_point(size = 3) +\n  geom_errorbar(width = .5, aes(ymin=mean-sd, ymax=mean+sd)) +\n  scale_color_colorblind() +\n  theme_bw() +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstat_summary()\n\n\n\nIn ggplot2 gibt es eine weitere nützliche Funktion, mit der zusammenfassende Statistiken visualisiert werden können, ohne dass zuvor mit dplyr::sumarise() Zusammenfassungen erstellt werden müssen. Die Funktion stat_summary() erlaubt es uns, zusammenfassende Statistiken direkt in unserem ggplot()-Objekt zu erstellen, was bedeutet, dass wir mehrere zusammenfassende Statistiken im selben Plot darstellen können (was wir noch nicht tun werden…).\nDie Funktion stat_summary() benötigt mindestens zwei Argumente: stat =, das ist der Typ der Statistik, die man darstellen möchte, und geom =, das ist der Typ des geom, mit dem man es visualisieren möchte. Wir können Mittelwerte leicht mit Punkten (Abbildung 8.10) oder einem Balkenplot (Abbildung 8.11) darstellen, obwohl ich dringend empfehle, Balkenplots zu vermeiden, wenn ein Punktwert wie ein Mittelwert dargestellt werden soll.\n\ndf_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec, colour = age_subject) +\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  labs(title = 'geom = \"point\"')\n\n\n\n\n\n\n\nAbbildung 8.10: stat_summary(stat_summary(fun = \"mean\", geom = \"point\"))\n\n\n\n\n\n\ndf_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec, fill = age_subject) +\n  stat_summary(fun = \"mean\", geom = \"bar\") +\n  labs(title = 'geom = \"bar\"')\n\n\n\n\n\n\n\nAbbildung 8.11: stat_summary(stat_summary(fun = \"mean\", geom = \"bar\"))\n\n\n\n\n\nWir können auch Fehlerbalken mit stat_summary() einfügen, wie in Abbildung 8.12. Dies erzeugt doppelte Standardabweichungen, so dass wir die fun.args =-Werte einfügen müssen, um anzugeben, dass wir einfache Standardabweichungen visualisieren wollen.\n\ndf_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec, colour = age_subject) +\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  stat_summary(fun.data = \"mean_sdl\",\n               geom = \"errorbar\",\n               fun.args = list (mult = 1)) +\n  labs(title = 'Fehlerbalken-Darstellung mit `stat_summary()`') +\n  theme_bw()\n\n\n\n\n\n\n\nAbbildung 8.12: stat_summary(fun.data = \"mean_sdl\", geom = \"errorbar\",...\n\n\n\n\n\nWie Sie sehen können, ist das Hinzufügen von Fehlerbalken mit stat_summary() etwas weniger einfach, weshalb wir uns für den Weg summarise() |&gt; ggplot() + ... entschieden haben. Ein zusätzlicher Vorteil der Verwendung von summarise() ist, dass Sie Ihre Zusammenfassung als Tibble (d.h. als Tabelle oder Datenrahmen) speichern können, die zusätzlich zum Plot gedruckt werden kann (wie wir mit Tabelle 9.4 gesehen haben). Ich habe erst vor ein oder zwei Jahren begonnen, dplyr::summarise() anstelle von ggplot2::stat_summary() zu verwenden, und bevorzuge Ersteres, weil ich dann die berechneten Werte vor dem Plotten überprüfen kann. Dies ist eine Frage der persönlichen Vorliebe, wenn Sie also neugierig sind, schlage ich vor, dass Sie stat_summary() ausprobieren, um zu sehen, ob Sie eine Vorliebe haben. Wenn Sie mehr über stat_summary() erfahren wollen, können Sie ?stat_summary in der Console eingeben oder nach Tutorials oder YouTube-Videos googeln, es gibt viele davon.\n\n\n\n\n\n8.4.2 Balkendiagramm der Mittelwerte: Finger weg!\nIch flehe Sie an, nicht Mittelwerte mit Balkendiagramme darzustellen! Sie werden sehr oft Balkendiagramme von Mittelwerten sehen, und andere unterrichten dies vielleicht sogar in anderen Kursen, aber es gibt viele Gründe, warum dies eine schlechte Idee ist!!!\nErstens können sie sehr irreführend sein. Sie beginnen bei 0 und vermitteln den Eindruck, dass die Daten beim Mittelwert enden, obwohl etwa die Hälfte der Daten (normalerweise) über dem Mittelwert liegt.\nAußerdem hat der Balkenplot ein schlechtes Daten-Tinten-Verhältnis, d. h. die Menge der Datentinte geteilt durch die Gesamttinte, die zur Erstellung der Grafik benötigt wird, oder die Menge der Tinte, die entfernt werden kann, ohne dass Informationen verloren gehen. Beispielsweise beginnen Balkenplots normalerweise bei Null und enden beim Mittelwert. Was aber, wenn es nur sehr wenige oder gar keine Beobachtungen in der Nähe von Null gibt? Wir verbrauchen eine Menge Tinte, wo es keine Beobachtungen gibt! Ein ebenso abscheuliches Verbrechen ist, dass der Balken nur den Bereich abdeckt, in dem die untere Hälfte der Beobachtungen liegt; ebenso viele Beobachtungen liegen über dem Mittelwert!\nMeiner Meinung nach sollten Balkendiagramme nur für Zählungen oder Häufigkeiten verwendet werden. Abgesehen davon sind Fehlerbalken allein nicht die Lösung. Die Darstellung nur des Mittelwerts und der Standardabweichung (oder des Standardfehlers/des Konfidenzintervalls/der glaubwürdigen Intervalle) verbirgt eine Menge Informationen über die tatsächliche Streuung und Verteilung der Daten. Erinnern Sie sich an das Paket datasauRus, das Datensätze mit ähnlichen Mittelwerten, Standardabweichungen und Anzahl der Beobachtungen, aber sehr unterschiedlichen Verteilungen enthält. Abbildung 8.13 zeigt die Verteilung von 5 dieser Datensätze (A), einen Balkenplot des Mittelwerts, der Standardabweichung und der Anzahl der Beobachtungen für die Variablen “x” und “y” (B) sowie einen Fehlerbalkenplot (C).\n\n\n\n\n\n\n\n\nAbbildung 8.13: Datasets with the same means, sds, and Ns, but very different distributions\n\n\n\n\n\nSie werden sehen, dass die Verteilungen sehr unterschiedlich aussehen (in Abbildung 8.13 A), aber Abbildung 8.13 B und C vermitteln das nicht. Aus diesem Grund ist es ein guter Grund, die Rohdatenpunkte immer zu visualisieren, unabhängig davon, welche zusammenfassende Darstellung Sie erstellen (z. B. verbergen Errorbar-Plots auch viele Daten). Eine gute Möglichkeit, alle Grundlagen abzudecken, besteht darin, die Verteilung der Daten zusammen mit einer Visualisierung der zusammenfassenden Statistiken darzustellen. Sie werden dies in der Hausaufgabe üben, und in Kapitel 11 werden wir sehen, wie man diese zusammen in einem Diagramm visualisiert.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#lernziele-1",
    "href": "mats/09-dataviz_3.html#lernziele-1",
    "title": "8  Datenvisualisierung 3",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nIn diesem Kapital haben wir gelernt, wie man…\n\nBoxplots zu erstellen und zu interpretieren ✅\nMittelwerte und Standardabweichungen zu visualisieren ✅",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#weitere-übungen",
    "href": "mats/09-dataviz_3.html#weitere-übungen",
    "title": "8  Datenvisualisierung 3",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.8",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#session-info",
    "href": "mats/09-dataviz_3.html#session-info",
    "title": "8  Datenvisualisierung 3",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nprint(sessionInfo(),locale = F)\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] magick_2.8.3    patchwork_1.2.0 ggthemes_5.1.0  janitor_2.2.0  \n [5] here_1.0.1      lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1  \n [9] dplyr_1.1.4     purrr_1.0.2     readr_2.1.5     tidyr_1.3.1    \n[13] tibble_3.2.1    ggplot2_3.5.1   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        xml2_1.3.6       \n [5] stringi_1.8.3     hms_1.1.3         digest_0.6.35     magrittr_2.0.3   \n [9] evaluate_0.23     grid_4.4.0        timechange_0.3.0  fastmap_1.1.1    \n[13] rprojroot_2.0.4   jsonlite_1.8.8    fansi_1.0.6       viridisLite_0.4.2\n[17] scales_1.3.0      cli_3.6.2         crayon_1.5.2      rlang_1.1.3      \n[21] bit64_4.0.5       munsell_0.5.1     withr_3.0.0       yaml_2.3.8       \n[25] parallel_4.4.0    tools_4.4.0       tzdb_0.4.0        colorspace_2.1-0 \n[29] pacman_0.5.1      kableExtra_1.4.0  vctrs_0.6.5       R6_2.5.1         \n[33] lifecycle_1.0.4   snakecase_0.11.1  bit_4.0.5         htmlwidgets_1.6.4\n[37] vroom_1.6.5       pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.5     \n[41] glue_1.7.0        Rcpp_1.0.12       systemfonts_1.0.6 highr_0.10       \n[45] xfun_0.43         tidyselect_1.2.1  rstudioapi_0.16.0 knitr_1.46       \n[49] farver_2.1.1      datasauRus_0.1.8  htmltools_0.5.8.1 svglite_2.1.3    \n[53] labeling_0.4.3    rmarkdown_2.26    compiler_4.4.0   \n\n\n\n\n\n\n\n\nNordmann, E., McAleer, P., Toivo, W., Paterson, H., & DeBruine, L. M. (2022). Data Visualization Using R for Researchers Who Do Not Use R. Advances in Methods and Practices in Psychological Science, 5(2), 251524592210746. https://doi.org/10.1177/25152459221074654\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. In Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/09-dataviz_3.html#footnotes",
    "href": "mats/09-dataviz_3.html#footnotes",
    "title": "8  Datenvisualisierung 3",
    "section": "",
    "text": "Anstelle der Standardabweichung werden in der Regel Standardfehler oder Konfidenzintervalle (oder glaubwürdige Intervalle) dargestellt, die jedoch in diesem Kurs nicht behandelt werden. Aus diesem Grund sollten wir im Titel der Grafik vermerken, was die Fehlerbalken darstellen↩︎",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung 3</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html",
    "href": "mats/10-wrangling_2.html",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "",
    "text": "Lernziele\nIn diesem Kapitel werden wir lernen…",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#lernziele",
    "href": "mats/10-wrangling_2.html#lernziele",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "",
    "text": "über breite versus lange Daten\nwie man breite Daten länger machen kann\nwie man lange Daten breiter macht",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#lesungen",
    "href": "mats/10-wrangling_2.html#lesungen",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "Lesungen",
    "text": "Lesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kapital 6 (Data tidying) in Wickham et al. (2023).\nEine ergänzende Lektüre ist Kapital 8 (Data tidying) in Nordmann & DeBruine (2022).",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#sec-wrangling2_setup",
    "href": "mats/10-wrangling_2.html#sec-wrangling2_setup",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "9.1 Einrichtung",
    "text": "9.1 Einrichtung\nWir brauchen die Pakete tidyverse, here, und janitor.\n\npacman::p_load(tidyverse,\n               here,\n               janitor)\n\nWe’ll use the languageR_english.csv dataset (in daten folder).\n\ndf_eng &lt;- read_csv(here(\"daten\", \"languageR_english.csv\")) |&gt; \n  clean_names() |&gt; \n  arrange(word) |&gt; \n  rename(\n    rt_lexdec = r_tlexdec,\n    rt_naming = r_tnaming\n  )",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#tidy-arbeitsablauf",
    "href": "mats/10-wrangling_2.html#tidy-arbeitsablauf",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "9.2 ‘Tidy’ Arbeitsablauf",
    "text": "9.2 ‘Tidy’ Arbeitsablauf\nAbbildung 9.1 zeigt einen Überblick über den typischen Data-Science-Prozess, bei dem wir unsere Daten importieren, sie bereinigen und dann einen Zyklus von Umwandlung, Visualisierung und Modellierung durchlaufen, bevor wir schließlich unsere Ergebnisse mitteilen.\n\n\n\n\n\n\n\n\nAbbildung 9.1: Image source: Wickham et al. (2023) (all rights reserved)\n\n\n\n\n\nWir haben bereits gesehen, wie wir unsere Daten importieren (readr::read_csv), transformieren (Paket dplyr) und visualisieren (Paket ggplot) können. Aber wir haben bisher nur aufgeräumte Daten gesehen, so dass wir den Schritt “aufräumen” nicht durchführen mussten.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#tidy-daten",
    "href": "mats/10-wrangling_2.html#tidy-daten",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "9.3 ‘Tidy’ Daten",
    "text": "9.3 ‘Tidy’ Daten\nDieselben Daten können auf verschiedene Weise dargestellt werden. Die folgenden Datensätze zeigen alle dieselben Werte für vier Variablen: Land, Jahr, Bevölkerungszahl und Anzahl der Tuberkulosefälle. Jeder Datensatz ordnet die Werte anders an. Nehmen Sie sich einen Moment Zeit, um die verschiedenen Optionen zu betrachten. Welche ist am einfachsten zu lesen?\n\n\n\n\nTabelle 9.1: Tabelle 1\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTabelle 9.2: Tabelle 2\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\nAfghanistan\n1999\ncases\n745\n\n\nAfghanistan\n1999\npopulation\n19987071\n\n\nAfghanistan\n2000\ncases\n2666\n\n\nAfghanistan\n2000\npopulation\n20595360\n\n\nBrazil\n1999\ncases\n37737\n\n\nBrazil\n1999\npopulation\n172006362\n\n\nBrazil\n2000\ncases\n80488\n\n\nBrazil\n2000\npopulation\n174504898\n\n\nChina\n1999\ncases\n212258\n\n\nChina\n1999\npopulation\n1272915272\n\n\nChina\n2000\ncases\n213766\n\n\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTabelle 9.3: Tabelle 3\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\nAfghanistan\n1999\n745/19987071\n\n\nAfghanistan\n2000\n2666/20595360\n\n\nBrazil\n1999\n37737/172006362\n\n\nBrazil\n2000\n80488/174504898\n\n\nChina\n1999\n212258/1272915272\n\n\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\n\n\n\n\nWahrscheinlich ist Tabelle 9.1 für Sie am einfachsten zu lesen. Das liegt daran, dass sie den drei Regeln für aufgeräumte Daten folgt (visualisiert in Abbildung 9.2):\n\nJede Variable ist eine Spalte, jede Spalte ist eine Variable\nJede Beobachtung ist eine Zeile, jede Zeile ist eine Beobachtung\nJeder Wert ist eine Zelle, jede Zelle ist ein Einzelwert\n\n\n\n\n\n\n\n\n\nAbbildung 9.2: Image source: Wickham et al. (2023) (all rights reserved)\n\n\n\n\n\nIn Tabelle 9.1 steht jede Spalte für eine Variable: country, year, population und case. Jede Zeile steht für eine einzelne Beobachtung: ein Land in einem bestimmten Jahr. Und schließlich enthält jede Zelle einen einzigen Wert.\n\n9.3.1 Warum ‘tidy’ Daten?\n\n“Glückliche Familien sind alle gleich; jede unglückliche Familie ist auf ihre eigene Art unglücklich.” — Leo Tolstoy\n\n\n“Saubere Datensätze sind alle gleich, aber jeder unordentliche Datensatz ist auf seine eigene Weise unordentlich.” — Hadley Wickham\n\nWenn Sie erst einmal ‘tidy’ Daten haben, verbringen Sie weniger Zeit mit dem Versuch, Ihre Daten in die richtige Form zu bringen, um das zu tun, was Sie wollen. Das Aufräumen von Daten erfordert im Vorfeld etwas Arbeit, ist aber langfristig gesehen hilfreich.\nDie Arbeit mit aufgeräumten Daten hat zwei wesentliche Vorteile:\n\nDie Arbeit mit einer einheitlichen Datenstruktur ermöglicht es uns, Konventionen zu übernehmen.\n\nDa aufgeräumte Daten die allgemein vereinbarte Datenstruktur sind, basieren die Konventionen auf der Annahme dieser Struktur.\nso haben die Werkzeuge eine zugrunde liegende Einheitlichkeit\n\nDie vektorisierte Natur von R kann glänzen\n\ndie meisten eingebauten R-Funktionen arbeiten mit Vektorwerten (und Spalten sind im Wesentlichen Vektoren)\nAlle Pakete im tidyverse sind darauf ausgelegt, mit aufgeräumten Daten zu arbeiten (z.B. ggplot2 und dplyr)\n\n\n\n\n\n\n\n\nRückblick: Vektoren\n\n\n\nVektoren sind der grundlegendste Datenobjekttyp in R. Ein Vektor enthält Daten desselben Typs und ist im Wesentlichen eine Liste. Sie können einen Vektor z.B. mit der Funktion c() erzeugen.\n\nvector1 &lt;- c(2, 3, 4, 6, 7)\nvector2 &lt;- c(2, 3, 4, 6, \"x\")\n\nVektor1 enthält numerische Werte, da alle Elemente Zahlen sind. vector2 wird alle Zeichenwerte (d.h. Text) enthalten, da es ein einziges eindeutiges Zeichenelement (\"x\") gibt. R liest also alle Elemente als Zeichentyp. Wir können einen Datenrahmen aus Vektoren gleicher Länge erstellen, indem wir z. B. die Funktion tibble() verwenden.\n\ntibble(vector1,vector2)\n\n# A tibble: 5 × 2\n  vector1 vector2\n    &lt;dbl&gt; &lt;chr&gt;  \n1       2 2      \n2       3 3      \n3       4 4      \n4       6 6      \n5       7 x      \n\n\n\n\nDie meisten Daten “in freier Wildbahn” sind unordentlich. Die Daten werden oft zunächst für ein anderes Ziel als die Analyse organisiert. Dieses Ziel ist in der Regel die Erleichterung der Dateneingabe: Wir wollen unsere Beobachtungen zunächst einfach dokumentieren können. Die meisten Menschen sind mit den Grundsätzen ordentlicher Daten nicht vertraut, und erst wenn sie viel Zeit mit Daten verbringen, wird klar, warum ordentliche Daten notwendig sind. Das bedeutet, dass die meisten echten Analysen zumindest ein gewisses Maß an Aufräumen erfordern.\n\n\n\n\n\n\nAufgabe 9.1: Tidy data\n\n\n\n\nBeispiel 9.1  \n\n\nGehen Sie zurück zu den Tabellen 1-3. Beschreiben Sie für jede Tabelle, was jede Beobachtung und jede Spalte darstellt.\nSkizzieren Sie das Verfahren, mit dem Sie die Rate für table1. berechnen würden. Sie brauchen nur ein Verb, das:\n\neine neue Variable erzeugt (nennen Sie sie rate), die Folgendes enthält:\n\ndie Anzahl der TB-Fälle (cases) pro Land und Jahr, geteilt durch\ndie entsprechende Bevölkerung (population) pro Land und Jahr,\nmultipliziert mit 10000\n\nHinweis: Welches dplyr-Verb erzeugt neue Variablen? (Sehen Sie sich das ?sec-data-transform an.)\n\nSchauen Sie die Tabelle 9.2 und Tabelle 9.3 an. Wäre es so einfach gewesen, die rate mit diesen Datenstrukturen zu berechnen?",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#datenbereinigung",
    "href": "mats/10-wrangling_2.html#datenbereinigung",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "9.4 Datenbereinigung",
    "text": "9.4 Datenbereinigung\nDie Datenbereinigung besteht im Wesentlichen aus der Umwandlung breiter Daten in lange Daten und langer Daten in breite Daten (neben anderen Schritten). Das Ergebnis sind aufgeräumte Daten, bei denen jede Spalte eine Variable und jede Zeile eine Beobachtung darstellt. Wie genau wir eine Beobachtung definieren, hängt davon ab, was genau wir erreichen wollen, und kann sich von einem Analyseschritt zum anderen ändern.\n\n9.4.1 Datenaufräumung mit dem tidyverse\nDas Paket tidyr aus tidyverse hat zwei nützliche Funktionen zum Transponieren unserer Daten:\n\npivot_longer(): macht breite Daten länger\npivot_wider(): lange Daten breiter machen\n\nOft müssen wir zwischen diesen Formaten konvertieren, um verschiedene Arten von Zusammenfassungen oder Visualisierungen zu erstellen. Aber was genau sind breite und lange Daten?\n\n\n\n\n\n\n\n\nAbbildung 9.3: die berühmteste Verwendung des Wortes Pivot (zumindest für Millenials) (Friends)\n\n\n\n\n\n\n\n9.4.2 Breite versus lange Daten\nBei breiten Daten befinden sich alle Beobachtungen zu einer Sache in derselben Zeile. Breite Daten sind normalerweise nicht aufgeräumt. Bei langen Daten befindet sich jede Beobachtung in einer eigenen Zeile. Lange Daten sind normalerweise aufgeräumt. Beginnen wir mit dem typischsten Fall: der Umwandlung breiter Daten in lange Daten.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#verlängern-von-daten-df_eng",
    "href": "mats/10-wrangling_2.html#verlängern-von-daten-df_eng",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "9.5 Verlängern von Daten: df_eng",
    "text": "9.5 Verlängern von Daten: df_eng\n\nim Datensatz languageR_english.csv\n\njede Zeile ist eine Beobachtung\ndie erste Spalte beschreibt die Altersgruppe des Teilnehmers\ndie Spalten word, length_in_letters, written_frequency und word_category beschreiben Eigenschaften des Stimulus für eine bestimmte Beobachtung (d. h. das Wort)\nwir haben 4568 Beobachtungen\n\n\n\ndf_eng %&gt;% \n  head() %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::kable_styling()\n\n\n\nTabelle 9.4: df_eng\n\n\n\n\n\n\n\nage_subject\nword\nlength_in_letters\nwritten_frequency\nword_category\nrt_lexdec\nrt_naming\n\n\n\n\nyoung\nace\n3\n4.219508\nN\n623.61\n456.3\n\n\nold\nace\n3\n4.219508\nN\n775.67\n607.8\n\n\nyoung\nact\n3\n8.118207\nV\n617.10\n445.8\n\n\nold\nact\n3\n8.118207\nV\n715.52\n639.7\n\n\nyoung\nadd\n3\n7.319203\nV\n575.70\n467.8\n\n\nold\nadd\n3\n7.319203\nV\n742.19\n605.4\n\n\n\n\n\n\n\n\n\n\n\n\nSind diese Daten in Tabelle 9.4 aufgeräumt?\nSind diese Daten zu breit oder zu lang?\nWie können wir diese Daten länger machen?\n\nOb wir diese Daten verlängern wollen oder nicht, hängt von der jeweiligen Aufgabe ab. Wenn wir die Antwortzeiten für die lexikalische Entscheidungsaufgabe (rt_lexdec) zusammen mit der Antwortzeit für die Benennungsaufgabe (rt_naming) aufzeichnen wollen, könnten wir die beiden in facet_wrap() einschließen. Allerdings nimmt facet_wrap() eine kategorische Variable als Argument und erzeugt Diagramme für jede Kategorie. Wir bräuchten eine neue Variable, zum Beispiel response, die die Stufen lexdec und naming enthält, und eine weitere, zum Beispiel time, die die Antwortzeit enthält. Versuchen wir das mal.\n\n9.5.1 pivot_longer()\nDie Funktion tidyr pivot_longer() konvertiert eine breite Datentabelle in ein längeres Format, indem sie die Überschriften der angegebenen Spalten in die Werte neuer Spalten umwandelt und die Werte dieser Spalten zu einer neuen, zusammengefassten Spalte kombiniert.\n\ndf_eng_long &lt;- \n  df_eng %&gt;% \n  pivot_longer(\n    cols = starts_with(\"rt_\"), \n    names_to = \"response\", \n    values_to = \"time\"\n  )\n\nDie Ausgabe der ersten 12 Zeilen (nach einigen zusätzlichen Formatierungen, um eine hübsche Tabelle zu erstellen) sollte wie Tabelle 9.5 aussehen.\n\ndf_eng_long %&gt;% \n  head(n = 12) %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::kable_styling(font_size = 20)\n\n\n\nTabelle 9.5: A pivoted version of df_billboard (first 10 rows)\n\n\n\n\n\n\n\nage_subject\nword\nlength_in_letters\nwritten_frequency\nword_category\nresponse\ntime\n\n\n\n\nyoung\nace\n3\n4.219508\nN\nrt_lexdec\n623.61\n\n\nyoung\nace\n3\n4.219508\nN\nrt_naming\n456.30\n\n\nold\nace\n3\n4.219508\nN\nrt_lexdec\n775.67\n\n\nold\nace\n3\n4.219508\nN\nrt_naming\n607.80\n\n\nyoung\nact\n3\n8.118207\nV\nrt_lexdec\n617.10\n\n\nyoung\nact\n3\n8.118207\nV\nrt_naming\n445.80\n\n\nold\nact\n3\n8.118207\nV\nrt_lexdec\n715.52\n\n\nold\nact\n3\n8.118207\nV\nrt_naming\n639.70\n\n\nyoung\nadd\n3\n7.319203\nV\nrt_lexdec\n575.70\n\n\nyoung\nadd\n3\n7.319203\nV\nrt_naming\n467.80\n\n\nold\nadd\n3\n7.319203\nV\nrt_lexdec\n742.19\n\n\nold\nadd\n3\n7.319203\nV\nrt_naming\n605.40\n\n\n\n\n\n\n\n\n\n\n\nNehmen wir uns einen Moment Zeit, um die Werte in Tabelle 9.5 mit denen der ersten 6 Zeilen in df_eng zu vergleichen, die in Tabelle 9.4 angegeben sind. Vergleichen Sie die Werte in der df_eng-Variablen rt_lexdec (Tabelle 9.4) mit den time-Werten, wenn response rt_lexdec (Tabelle 9.5) ist: Sie sind identisch. Was ist nun mit rt_naming sowohl in Tabelle 9.4 als auch in Tabelle 9.5? Sie sind ebenfalls identisch. Dies ist eine wichtige Erkenntnis: Wir haben keine Daten oder Beobachtungswerte geändert, sondern lediglich die Organisation der Datenpunkte neu strukturiert.\nWie hat pivot_longer() das gemacht? Hier ist eine Aufschlüsselung der Argumente, die pivot_longer() benötigt (die Sie auch durch Ausführen von ?pivot_longer in der Konsole untersuchen können):\n\ncol = gibt an, welche Spalten gepivotet werden müssen (sollte eine kategorische Variable sein)\n\nnimmt die gleiche Syntax wie select(), also könnten wir z.B. starts_with(\"\") verwenden\n\nnames_to = benennt die Variable, die in den aktuellen Spaltennamen gespeichert ist, hier ist es response\nvalues_to = benennt die in den Zellwerten gespeicherte Variable, die wir time nennen\nN.B., wir mussten response und time in Anführungszeichen setzen, weil sie noch keine Variablennamen sind.\n\n\n9.5.1.1 Plotten unserer ‘tidy’ Daten\nDa wir nun die response-Daten in einer Variable und die time-Daten in einer anderen Variable haben, wollen wir versuchen, ein Diagramm zu erstellen, in dem wir age_subject auf der x-Achse, time auf der y-Achse und response auf der y-Achse haben.\n\n\n\n\n\n\n\n\nAbbildung 9.4: Response times per age group for the lexical decision task vs. naming task\n\n\n\n\n\n\n\n\n\n\n\nAufgabe 9.1: Tidy data\n\n\n\n\nBeispiel 9.2  \n\nAbbildung 9.4 neu erstellen.",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#verbreiterung-der-daten-df_eng",
    "href": "mats/10-wrangling_2.html#verbreiterung-der-daten-df_eng",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "9.6 Verbreiterung der Daten: df_eng",
    "text": "9.6 Verbreiterung der Daten: df_eng\nDie tidyr-Funktion pivot_wider() macht Datensätze breiter, indem sie Spalten vergrößert und Zeilen verkleinert. Dies ist hilfreich, wenn eine Beobachtung über mehrere Zeilen verteilt ist. Obwohl diese Art von Daten in der freien Wildbahn nicht sehr häufig vorkommt, ist sie zum Beispiel bei Regierungsdaten ziemlich verbreitet.\nWir können wieder mit df_eng beginnen, um die Daten zu erweitern. Zum Beispiel könnten wir eine einzelne Zeile pro Wort haben, die eine einzelne Variable für die Antwort des “jungen” Probanden und die Antwort des “alten” Probanden enthält.\n\n9.6.1 pivot_wider()\nPivot wider nimmt ähnliche Argumente wie pivot_longer(), mit einigen leichten Unterschieden (z.B. ?pivot_wider):\n\nid_cols: identifizierende Spalten (welche Spalten identifizieren jede Beobachtung eindeutig?)\nnames_from: wie soll die neue Spalte heißen, die die vorherigen Spaltennamen enthält (muss eine kategorische Variable sein)?\nnames_prefix: Präfix für die neuen Spaltennamen (optional)\nWerte_von`: neue Spaltenwerte\n\nErstellen wir zwei neue Variablen, die ihre Namen von age_subject und ihre Werte von rt_lexdec übernehmen. Das Ergebnis sollte wie ?tbl-eng_wider aussehen.\n\n\nCode\ndf_eng_wide &lt;-\n  df_eng %&gt;%  \n  select(-rt_naming) |&gt;\n  pivot_wider(\n    names_from = age_subject,\n    values_from = rt_lexdec,\n    names_prefix = \"lexdec_\"\n  )\n\n\n\n\n\n\nTabelle 9.6: Wider df_eng data\n\n\n\n\n\n\n\nword\nlength_in_letters\nwritten_frequency\nword_category\nlexdec_young\nlexdec_old\n\n\n\n\nace\n3\n4.219508\nN\n623.61\n775.67\n\n\nact\n3\n8.118207\nV\n617.10\n715.52\n\n\nadd\n3\n7.319203\nV\n575.70\n742.19\n\n\nage\n3\n8.397959\nN\n592.42\n748.37\n\n\naid\n3\n6.927558\nV\n541.67\n824.76\n\n\naide\n4\n4.615120\nN\n693.50\n895.29\n\n\n\n\n\n\n\n\n\n\n\nTabelle 9.7 zeigt wieder die ersten 6 Zeilen des Originaldatensatzes. Wie werden die Daten aus Tabelle 9.6 in Tabelle 9.7 dargestellt?\n\n\n\n\nTabelle 9.7: head(df_eng, n = 6)\n\n\n\n\n\n\n\nage_subject\nword\nlength_in_letters\nwritten_frequency\nword_category\nrt_lexdec\nrt_naming\n\n\n\n\nyoung\nace\n3\n4.219508\nN\n623.61\n456.3\n\n\nold\nace\n3\n4.219508\nN\n775.67\n607.8\n\n\nyoung\nact\n3\n8.118207\nV\n617.10\n445.8\n\n\nold\nact\n3\n8.118207\nV\n715.52\n639.7\n\n\nyoung\nadd\n3\n7.319203\nV\n575.70\n467.8\n\n\nold\nadd\n3\n7.319203\nV\n742.19\n605.4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarnung\n\n\n\n\n\n\nWo ist rt_naming geblieben? Wir haben es entfernt, weil es ebenfalls einen einzigen Wert pro Wort und Altersgruppe hat. Wenn wir es nicht entfernen, bedeutet das, dass wir die Länge unseres Datensatzes nicht ändern (immer noch eine Zeile pro Wort und Altersgruppe), sondern nur die Breite und die Einführung von NA-Werten für lexdec_young für alte Probanden und NA-Werten für lexdec_old für junge Probanden. Hätten wir sie nicht entfernt, sähen unsere ersten 6 Zeilen wie Tabelle 9.8 aus. Vergleichen Sie dies mit der Ausgabe in Tabelle 9.6, sehen Sie den Unterschied?\n\n\n\n\nTabelle 9.8: Wider data with missing values\n\n\n\n\n\n\n\nword\nlength_in_letters\nwritten_frequency\nword_category\nrt_naming\nlexdec_young\nlexdec_old\n\n\n\n\nace\n3\n4.219508\nN\n456.3\n623.61\nNA\n\n\nace\n3\n4.219508\nN\n607.8\nNA\n775.67\n\n\nact\n3\n8.118207\nV\n445.8\n617.10\nNA\n\n\nact\n3\n8.118207\nV\n639.7\nNA\n715.52\n\n\nadd\n3\n7.319203\nV\n467.8\n575.70\nNA\n\n\nadd\n3\n7.319203\nV\n605.4\nNA\n742.19",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#lernziele-1",
    "href": "mats/10-wrangling_2.html#lernziele-1",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nIn diesem Kapitel haben wir gelernt…\n\nüber breite versus lange Daten ✅\nwie man breite Daten länger macht ✅\nwie man lange Daten breiter macht ✅",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#weitere-übungen",
    "href": "mats/10-wrangling_2.html#weitere-übungen",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.9",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/10-wrangling_2.html#session-info",
    "href": "mats/10-wrangling_2.html#session-info",
    "title": "9  Data Wrangling 2: Tidying",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] janitor_2.2.0   here_1.0.1      lubridate_1.9.3 forcats_1.0.0  \n [5] stringr_1.5.1   dplyr_1.1.4     purrr_1.0.2     readr_2.1.5    \n [9] tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.1   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        xml2_1.3.6       \n [5] stringi_1.8.3     hms_1.1.3         digest_0.6.35     magrittr_2.0.3   \n [9] evaluate_0.23     grid_4.4.0        timechange_0.3.0  fastmap_1.1.1    \n[13] rprojroot_2.0.4   jsonlite_1.8.8    fansi_1.0.6       viridisLite_0.4.2\n[17] scales_1.3.0      cli_3.6.2         rlang_1.1.3       crayon_1.5.2     \n[21] bit64_4.0.5       munsell_0.5.1     withr_3.0.0       yaml_2.3.8       \n[25] tools_4.4.0       parallel_4.4.0    tzdb_0.4.0        colorspace_2.1-0 \n[29] pacman_0.5.1      kableExtra_1.4.0  vctrs_0.6.5       R6_2.5.1         \n[33] magick_2.8.3      lifecycle_1.0.4   snakecase_0.11.1  htmlwidgets_1.6.4\n[37] bit_4.0.5         vroom_1.6.5       pkgconfig_2.0.3   pillar_1.9.0     \n[41] gtable_0.3.5      Rcpp_1.0.12       glue_1.7.0        systemfonts_1.0.6\n[45] highr_0.10        xfun_0.43         tidyselect_1.2.1  rstudioapi_0.16.0\n[49] knitr_1.46        farver_2.1.1      htmltools_0.5.8.1 labeling_0.4.3   \n[53] svglite_2.1.3     rmarkdown_2.26    compiler_4.4.0   \n\n\n\n\n\n\n\n\nNordmann, E., & DeBruine, L. (2022). Applied Data Skills. Zenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Nächste Stufe",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Data Wrangling 2: Tidying</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html",
    "href": "mats/12-baseR.html",
    "title": "10  Base R",
    "section": "",
    "text": "Lesungen\nDie Pflichtlektüre zur Vorbereitung auf dieses Thema ist Kapital 27 (A field guide to Base R) in Wickham et al. (2023).",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#lernziele",
    "href": "mats/12-baseR.html#lernziele",
    "title": "10  Base R",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Kapitel werden wir…\n\nlernen, was Base R ist\nBase R und Tidyverse vergleichen\ndie Base-R-Äquivalente der Tidyverse-Verben kennenlernen",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#base-r",
    "href": "mats/12-baseR.html#base-r",
    "title": "10  Base R",
    "section": "10.1 Base R",
    "text": "10.1 Base R\nDie Basissoftware, die die Programmiersprache R enthält, heißt base-R oder natives R. Dieses Basissystem enthält das Paket base, das zum Ausführen von R erforderlich ist. Ähnlich wie tidyverse enthält das Basissystem auch einige Pakete wie utils und stats (unter anderem). Um zu sehen, welche Pakete enthalten sind, gehen Sie einfach auf die Registerkarte Pakete unten rechts in Ihrer RStudio-Sitzung. Unter der Annahme, dass Sie mit einer sauberen Arbeitsumgebung beginnen, sollten nur die Pakete geladen werden, die zum R-Basissystem gehören. Alle diese Pakete werden bei der Installation von R installiert. Mit dieser Sammlung von Paketen können die meisten (wenn nicht alle) der gleichen Ziele wie mit tidyverse erreicht werden, auch wenn beide für bestimmte Ziele vorzuziehen oder besser zu rationalisieren sind.\nWie wir bereits gelernt haben, ist das Tidyverse (Wickham et al., 2019a) eine Familie von R-Paketen, die das Bereinigen und Verwalten von Daten erleichtern sollen. Der Hauptentwickler von Tidyverse ist Hadley Wickham, der Chefwissenschaftler von Posit (ehemals RStudio), dem Softwareunternehmen, das die integrierte Entwicklungsumgebung (IDE) RStudio entwickelt hat. Alle Pakete in Tidyverse “teilen eine High-Level-Design-Philosophie und Low-Level-Grammatik und Datenstrukturen, so dass das Erlernen eines Pakets es einfacher macht, das nächste zu erlernen” (Wickham et al., 2019b). Allerdings wurde das Tidyverse in der Programmiersprache R geschrieben, sodass die beiden nicht vollständig voneinander getrennt sind.\nSowohl Base R als auch tidyverse sind Open-Source-Sprachen, die für die Datenwissenschaft geschrieben wurden. Ein Hauptziel von Base R ist die Stabilität, d. h. der Code sollte über viele Jahre hinweg stabil sein. Tidyverse hingegen fügt ständig Funktionen und Argumente hinzu, aktualisiert sie und ändert sie mit neuen Paketversionen im Hinblick auf die Optimierung. Dies bedeutet, dass Tidyverse-Code anfällig für “Brüche” ist: Tidyverse-Code, der heute läuft, läuft vielleicht in ein paar Jahren nicht mehr, wenn einige Funktionen oder Argumente “veraltet” sind. Deshalb ist es so wichtig, dass Sie immer Ihre sessionInfo() mit einem Bericht mitschicken, sie dokumentiert, welche Pakete und deren Versionen Sie verwendet haben.\nIn der Debatte zwischen Base R und Tidyverse gibt es in der Regel drei Lager: die starken Befürworter von Base R, die starken Befürworter von Tidyverse und die Agnostiker. In Bezug auf den R-Unterricht gibt es mehrere Arbeiten, in denen die potenziellen Vorteile des Unterrichts von Base R oder des Tidyverse bzw. einer Kombination aus beidem untersucht werden. Einige argumentieren, dass das Lehren der Tidyverse für Schüler intuitiver ist, während andere behaupten, dass Base R der “einzige” Weg ist, um echte R-Kenntnisse zu erlangen. Base R ist z.B. einfacher, wenn es darum geht, eine einzelne Variable zu extrahieren, aber selbst unter standhaften Base R-Nutzern wird das Paket ggplot2 oft bevorzugt, um Diagramme zu erstellen. Unten sehen wir einen Tweet von Prof. Christopher Zorn (Penn State), der vorschlägt, dass die Kenntnis des “tidyverse” nicht bedeutet, dass man R kennt, mit einer Antwort von Prof. Bodo Winter (University of Birmingham) zur Unterstützung des tidyverse. Viele andere Antworten wiesen auf die verschiedenen Vorteile des Tidyverse hin, von der Lehre von R bis zur Arbeit in der Industrie. Wichtig (und für Sie als Linguistikstudenten relevant) ist, dass Bodo Winter der Autor von ‘Statistics for Linguists: An Introduction Using R’ (Winter, 2019), das ebenfalls tidyverse verwendet. Sein Buch sowie die Tutorien, die er als Doktorand geschrieben hat (Winter, 2013, 2014), sind in einer verständlichen Sprache verfasst, die sie für Studierende zugänglich macht. Es ist also kein Wunder, dass er ein Befürworter von tidyverse ist, das auch für Nicht-Programmierer zugänglich sein soll.\n\n\n\nWhat a thing to say when modern R is pretty much synonymous with the tidyverse for many in the community!I was a Base R masochist once too.. but there's no need for statements like this when the tidyverse has helped so many of us be more productive and write more readable code.\n\n— Bodo Winter ((BodoWinter?)) January 10, 2023\n\n\n\nOffensichtlich halte ich das Erlernen des Tidyversums für wichtig, denn ich habe mich entschieden, diesen Kurs auf Tidyversum-Pakete zu stützen. Das liegt daran, dass das Tidyverse den Menschen in den Mittelpunkt stellt, und dieser Kurs ist nicht für Programmierer oder Informatiker gedacht. Wie wir im obigen Tweet sehen, stimmt nicht jeder mit mir überein, aber es gibt auch viele Leute, die das tun.\n\n10.1.1 Warum beides lernen?\nIch persönlich lernte Base R Jahre bevor ich Tidyverse lernte. Ich habe nie zurückgeblickt, und mein Code ist seit der Einführung von tidyverse und den dahinter stehenden Philosophien viel sauberer und besser lesbar geworden. Trotzdem gibt es immer noch bestimmte Aufgaben, für die ich Base R verwende, z. B. für einen schnellen Blick auf eine einzelne Variable oder wenn ich mit Listen oder verschachtelten Datenstrukturen arbeite (die wir in diesem Kurs nicht behandeln werden).\nAuch wenn ich persönlich mit ähnlichen Ansichten wie im ursprünglichen Tweet oben nicht einverstanden bin (wie viele andere auch), ist die Kenntnis von Base R eine wichtige Fähigkeit, um Ihre R-Horizonte zu erweitern. Sie werden mit Sicherheit auf Base R-Code stoßen, wenn Sie nach Lösungen für Probleme suchen oder sich den Code von anderen ansehen. Unabhängig davon, ob jemand eine starke Vorliebe für Base R oder Tidyverse hat, ist es eine gute Idee, mit beiden Optionen vertraut zu sein, um das Beste aus der R-Community herauszuholen. Es ist wichtig zu verstehen, dass es so etwas wie perfekten Code nicht gibt, und dass es fast immer mehrere Möglichkeiten gibt, das gleiche Ziel zu erreichen, sogar innerhalb von Base R oder Tidyverse. Was wir heute lernen werden, ist im Wesentlichen, wie wir den Tidyverse-Code, mit dem wir vertraut sind, in Base R übersetzen können.",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#sec-baseR_setup",
    "href": "mats/12-baseR.html#sec-baseR_setup",
    "title": "10  Base R",
    "section": "10.2 Einrichten {.unnumbered}",
    "text": "10.2 Einrichten {.unnumbered}\nWir werden heute ziemlich minimalistisch arbeiten. Alles was wir brauchen sind die Pakete tidyverse und here.\n\npacman::p_load(\n  tidyverse,\n  here\n)\n\n\n10.2.1 Einlesen\nWir werden den Datensatz languageR_english.csv einlesen, der sich bereits in Ihrem daten-Ordner befinden sollte. Dieser Datensatz enthält Daten aus einer Benennungs- und lexikalischen Entscheidungsaufgabe in Englisch.\n\n\n10.2.2 CSV\nWir haben bereits gesehen, wie man die read_() Familie von Funktionen (read_csv(), read_csv2(), read_delim(), etc.) aus dem readr Paket aus dem tidyverse benutzt.\n\n\n\ntidyverse\n\ndf_tidy &lt;-\n  read_csv(\n    here(\"daten\", \"languageR_english.csv\")\n  )\n\n\nUm einen Datensatz mit kommagetrennten Werten (CSV) einzulesen, können wir die Funktion read.csv() verwenden, die eine Version der umfassenderen Funktion read.table() aus dem Paket utils ist. Das utils-Paket ist ein Standard-Installationspaket in R, so wie einige Anwendungen bereits installiert sind, wenn man ein neues Telefon kauft.\n\n\n\nBase R\n\ndf_base &lt;-\n  read.csv(\n    here(\"daten\", \"languageR_english.csv\")\n  )\n\n\nDas erste, was Ihnen vielleicht auffällt, ist, dass wir beim Ausführen von read_csv() eine Meldung erhalten haben, die uns die Anzahl der Zeilen und Spalten in den Daten, das verwendete Trennzeichen (bei read_csv() immer ein Komma) und den Datentyp, zu dem unsere Variablen gehören, mitteilt. Hier haben wir gesehen, dass wir drei Zeichenvariablen (chr) und vier numerische Variablen (dbl für “double”) haben. Bei der Verwendung von read.csv() erhalten wir keine derartige Meldung. Im Allgemeinen ist Tidyverse ein besserer Gesprächspartner als Base R. Sie erhalten mehr Meldungen, und die Warn- oder Fehlermeldungen sind anschaulicher.\nEin weiterer Unterschied zwischen diesen beiden Funktionen ist die Art und Weise, wie sie read und csv trennen: tidyverse verwendet typischerweise _, um Wörter zu trennen, während Base R dazu neigt, eine Mischung aus . und _ zu verwenden. Dies geht auf die Prinzipien von tidyverse zurück, in denen versucht wird, konsistente Konventionen beizubehalten, um sauberen Code und saubere Daten zu fördern. Dazu gehört auch die konsequente Verwendung von `_” in Funktions- und Variablennamen.\nSchauen wir uns nun die beiden Objekte an, die wir jetzt haben. Wie viele Spalten haben sie?\n\nlength(df_tidy)\n\n[1] 7\n\n\n\nlength(df_base)\n\n[1] 7\n\n\nBeide haben 7 Spalten. Wie lauten die Namen dieser Spalten?\n\nnames(df_base)\n\n[1] \"AgeSubject\"       \"Word\"             \"LengthInLetters\"  \"WrittenFrequency\"\n[5] \"WordCategory\"     \"RTlexdec\"         \"RTnaming\"        \n\n\n\nnames(df_tidy)\n\n[1] \"AgeSubject\"       \"Word\"             \"LengthInLetters\"  \"WrittenFrequency\"\n[5] \"WordCategory\"     \"RTlexdec\"         \"RTnaming\"        \n\n\nSie haben auch die gleichen Namen, so weit, so gut. Wie viele Zeilen gibt es in jedem?\n\nnrow(df_tidy)\n\n[1] 4568\n\n\n\nnrow(df_base)\n\n[1] 4568\n\n\nBeide haben 4568 Zeilen. Die Datenstruktur ist also identisch.\n\n\n10.2.3 Andere Begrenzungszeichen\nErinnern Sie sich, dass wir mit dem tidyverse-Paket readr read_delim(delim = \"\") verwenden können, um das Trennzeichen explizit zu definieren. Hier verwenden wir delim = \",\", weil wir immer noch eine kommagetrennte Wertedatei verwenden.\n\n\n\ntidyverse\n\ndf_tidy &lt;-\n  read_delim(\n    here(\"daten\", \"languageR_english.csv\"),\n    delim = \",\"\n  )\n\n\nWir können dies mit read.table(sep = \"\") aus dem Paket utils tun.\n\n\n\nBase R\n\ndf_base &lt;-read.table(\n    here(\"daten\", \"languageR_english.csv\"),\n    sep = \",\",\n    header = TRUE\n  )\n\n\n\n\n\n\n\n\nBegrenzungszeichen und Trennzeichen\n\n\n\nVersuchen Sie, das Trennzeichen in den obigen Code-Blöcken durch ein Semikolon (;) zu ersetzen. Was ändert sich, und warum? Ändern Sie es wieder in ein Komma und führen Sie es erneut aus, bevor Sie fortfahren.\n\n\n\n\n10.2.4 Datenrahmen versus Tibbles\nDaten, die mit tidyverse eingelesen werden, werden als Tibble gespeichert, das als eine aufgeräumtere Version eines Datenrahmens gilt. Wichtig ist, dass die Struktur eines Tibbles und die darin enthaltenen Informationen mit denen eines Datenrahmens identisch sind. Im Folgenden werden wir einige Unterschiede zwischen Tibbles und Datenrahmen sehen.",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#umgang-mit-spalten-und-zeilen",
    "href": "mats/12-baseR.html#umgang-mit-spalten-und-zeilen",
    "title": "10  Base R",
    "section": "10.3 Umgang mit Spalten und Zeilen",
    "text": "10.3 Umgang mit Spalten und Zeilen\nWir sind bereits mit einer Reihe von dplyr-Verben vertraut, die zum Manipulieren, Filtern und Extrahieren von Zeilen und Spalten verwendet werden. Jetzt sehen wir uns alternative Wege an, um die gleichen Ergebnisse mit Base R zu erzielen.\n\n10.3.1 Variablen extrahieren\nWir sind bereits vertraut mit select() aus dplyr:\n\n\n\ntidyverse\n\ndf_tidy |&gt; \n  select(AgeSubject)\n\n\n\n\n# A tibble: 10 × 1\n   AgeSubject\n   &lt;chr&gt;     \n 1 young     \n 2 young     \n 3 young     \n 4 young     \n 5 young     \n 6 young     \n 7 young     \n 8 young     \n 9 young     \n10 young     \n\n\nIn Base R können wir ein Dollarzeichen ($) verwenden, um eine Spalte aus einem Datenrahmen (oder Tibble) zu extrahieren. Dadurch erhalten wir einen Vektor, während dplyr::select() die Datenrahmen-/Tibble-Attribute der Spalte beibehält.\n\n\n\nBase R\n\ndf_base$AgeSubject\n\n\n\n\n [1] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n[10] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n\n\nAlternativ kann man auch dataframe[row,column] verwenden, um Zeilen und Spalten zu definieren. Wir können den Namen einer Spalte in Anführungszeichen verwenden oder den Index der Spalte angeben, wobei 1 für die erste Spalte steht, 2 für die zweite Spalte usw. Wir konzentrieren uns zunächst auf die Spalten, geben also nicht an, welche Zeile wir wollen, sondern geben alle Zeilen dieser Spalte aus.\n\n\n\nBase R\n\n# using variable name\ndf_base[,\"AgeSubject\"]\n\n\n\n\n [1] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n[10] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n\n\n\n\n\nBase R\n\n# using variable index\ndf_base[,1]\n\n\n\n\n [1] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n[10] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n\n\nEin Hauptunterschied zwischen der Verwendung von tidyverse und Base R zum Extrahieren einer einzelnen Variablen besteht darin, dass Base R einen Vektor extrahiert, während das tidyverse-Verb select() die Variable als Tibble behält. Beachten Sie, dass es auch möglich ist, mehrere Variablen mit der Funktion select() auszuwählen. Sie können dies auch mit Base R tun, aber Sie müssen die Funktion c() verwenden.\n\n\n\ntidyverse\n\ndf_tidy |&gt; \n  select(AgeSubject, RTlexdec)\n\n\n\n\n# A tibble: 10 × 2\n   AgeSubject RTlexdec\n   &lt;chr&gt;         &lt;dbl&gt;\n 1 young          695.\n 2 young          600.\n 3 young          547.\n 4 young          617.\n 5 young          633.\n 6 young          687.\n 7 young          584.\n 8 young          527.\n 9 young          741.\n10 young          536.\n\n\n\n\n\nBase R\n\n# using variable name\ndf_base[,c(\"AgeSubject\", \"RTlexdec\")]\n\n\n\n\n   AgeSubject RTlexdec\n1       young   694.89\n2       young   600.40\n3       young   547.27\n4       young   616.60\n5       young   633.08\n6       young   686.75\n7       young   584.40\n8       young   526.82\n9       young   741.48\n10      young   536.38\n\n\n\n\n\nBase R\n\n# using variable index\ndf_base[,c(1, 6)]\n\n\n\n\n   AgeSubject RTlexdec\n1       young   694.89\n2       young   600.40\n3       young   547.27\n4       young   616.60\n5       young   633.08\n6       young   686.75\n7       young   584.40\n8       young   526.82\n9       young   741.48\n10      young   536.38\n\n\n\n10.3.1.1 Mischen von Tibbles und Datenrahmen\nDie Ausgabe dieser Operationen hängt nicht nur davon ab, ob Sie eine Tidyverse- oder eine R-Basisfunktion verwenden. Es macht auch einen Unterschied, ob die Daten ein Datenrahmen oder ein Tibble sind. Versuchen wir, die Funktion select() von tidyverse auf einen Datenrahmen anzuwenden:\n\n\n\ntidyverse\n\ndf_base |&gt; \n  select(AgeSubject)\n\n\n\n\n# A tibble: 10 × 1\n   AgeSubject\n   &lt;chr&gt;     \n 1 young     \n 2 young     \n 3 young     \n 4 young     \n 5 young     \n 6 young     \n 7 young     \n 8 young     \n 9 young     \n10 young     \n\n\nBase R behandelt Tibbles jedoch genauso wie Datenrahmen und gibt einen Vektor mit allen Werten einer einzelnen Spalte aus.\n\n\n\nBase R\n\ndf_tidy$AgeSubject\n\n\n\n\n [1] \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\" \"young\"\n[10] \"young\"\n\n\nDies sollte keine Folgen haben, aber es ist wichtig, die innere Struktur Ihrer Daten zu verstehen, damit Sie entsprechend damit arbeiten können.\n\n\n\n10.3.2 Beobachtungen extrahieren/filtern\nWir haben bereits die Funktion filter() von dplyr gesehen, die Zeilen extrahiert, die logischen Bedingungen entsprechen.\n\n\n\ntidyverse\n\ndf_tidy |&gt; \n  filter(RTlexdec &gt; 600 & RTnaming &lt; 480)\n\n\n# A tibble: 856 × 7\n   AgeSubject Word  LengthInLetters WrittenFrequency WordCategory RTlexdec\n   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 young      doe                 3             3.91 N                695.\n 2 young      pork                4             5.02 N                617.\n 3 young      prop                4             4.77 N                687.\n 4 young      arc                 3             4.89 N                741.\n 5 young      tile                4             4.08 N                647.\n 6 young      slope               5             5.80 N                633.\n 7 young      pith                4             2.48 N                696.\n 8 young      blitz               5             4.19 N                672.\n 9 young      port                4             6.08 N                683.\n10 young      plan                4             7.46 N                636.\n# ℹ 846 more rows\n# ℹ 1 more variable: RTnaming &lt;dbl&gt;\n\n\nWir können diese bedingten Anweisungen in [,] einfügen, wobei zu beachten ist, dass die Zeilen vor dem Komma und die Spalten nach dem Komma angegeben werden. Wir lassen die Spaltenangabe leer, d. h. wir wollen alle Spalten ausgeben. Wichtig ist, dass wir in den bedingten Anweisungen den Namen des Datenrahmens mit dem Dollarzeichen vor dem Spaltennamen angeben.\n\n\n\nBase R\n\ndf_base[df_base$RTlexdec &gt; 600 & df_base$RTnaming &lt; 480,]\n\n\n\n\n   AgeSubject  Word LengthInLetters WrittenFrequency WordCategory RTlexdec\n1       young   doe               3         3.912023            N   694.89\n4       young  pork               4         5.017280            N   616.60\n6       young  prop               4         4.770685            N   686.75\n9       young   arc               3         4.890349            N   741.48\n17      young  tile               4         4.077537            N   647.07\n18      young slope               5         5.802118            N   632.54\n22      young  pith               4         2.484907            N   695.86\n26      young blitz               5         4.189655            N   671.59\n29      young  port               4         6.084499            N   683.36\n34      young  plan               4         7.462789            N   636.10\n   RTnaming\n1     466.4\n4     460.3\n6     477.1\n9     453.8\n17    459.3\n18    476.2\n22    473.3\n26    469.5\n29    459.3\n34    470.4\n\n\n\n\n10.3.3 Einzelne Datenpunkte auswählen\nWir können bestimmte Zeilen und bestimmte Spalten auf einmal extrahieren. Wenn wir zum Beispiel die relevanten Zeilen wie oben ausgeben wollen, aber nur die Spalten AgeSubject und RTlexdec, können wir dies mit filter() und select() tun (was wir bereits zuvor getan haben).\n\n\n\ntidyverse\n\ndf_tidy |&gt; \n  filter(RTlexdec &gt; 600, RTnaming &lt; 480) |&gt; \n  select(AgeSubject, RTlexdec)\n\n\n\n\n# A tibble: 10 × 2\n   AgeSubject RTlexdec\n   &lt;chr&gt;         &lt;dbl&gt;\n 1 young          695.\n 2 young          617.\n 3 young          687.\n 4 young          741.\n 5 young          647.\n 6 young          633.\n 7 young          696.\n 8 young          672.\n 9 young          683.\n10 young          636.\n\n\nIn Base R würden wir dies einfach in [,] einfügen. Dadurch erhalten wir keinen Vektor mehr, sondern die Datenrahmenstruktur bleibt erhalten. Nicht, dass wir auch die Zeilennummern erhalten.\n\n\n\nBase R\n\ndf_base[df_base$RTlexdec &gt; 600 & df_base$RTnaming &lt; 480,c(\"AgeSubject\", \"RTlexdec\")]\n\n\n\n\n   AgeSubject RTlexdec\n1       young   694.89\n4       young   616.60\n6       young   686.75\n9       young   741.48\n17      young   647.07\n18      young   632.54\n22      young   695.86\n26      young   671.59\n29      young   683.36\n34      young   636.10\n\n\nAuch hier können Sie die Spaltennamen durch den Indexwert ersetzen.\n\n\n\nBase R\n\ndf_base[df_base$RTlexdec &gt; 600 & df_base$RTnaming &lt; 480,c(1, 6)]\n\n\n\n\n   AgeSubject RTlexdec\n1       young   694.89\n4       young   616.60\n6       young   686.75\n9       young   741.48\n17      young   647.07\n18      young   632.54\n22      young   695.86\n26      young   671.59\n29      young   683.36\n34      young   636.10\n\n\n\n\n10.3.4 Neue Variablen erstellen\nWir haben gelernt, wie man mit der Funktion mutate(), die ebenfalls aus dplyr stammt, neue Variablen erstellt oder bestehende Variablen ändert.\n\n\n\ntidyverse\n\ndf_tidy |&gt; \n  mutate(rt_lexdec_s = RTlexdec/1000)\n\n\n# A tibble: 4,568 × 8\n   AgeSubject Word   LengthInLetters WrittenFrequency WordCategory RTlexdec\n   &lt;chr&gt;      &lt;chr&gt;            &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 young      doe                  3             3.91 N                695.\n 2 young      whore                5             4.52 N                600.\n 3 young      stress               6             6.51 N                547.\n 4 young      pork                 4             5.02 N                617.\n 5 young      plug                 4             4.89 N                633.\n 6 young      prop                 4             4.77 N                687.\n 7 young      dawn                 4             6.38 N                584.\n 8 young      dog                  3             7.16 N                527.\n 9 young      arc                  3             4.89 N                741.\n10 young      skirt                5             5.93 N                536.\n# ℹ 4,558 more rows\n# ℹ 2 more variables: RTnaming &lt;dbl&gt;, rt_lexdec_s &lt;dbl&gt;\n\n\nIn Base R geschieht dies, indem wir den Namen der neuen Variablen definieren und ihr mit dem Zuweisungsoperator &lt;- einen Wert zuweisen.\n\n\n\nBase R\n\ndf_base$rt_lexdec_s &lt;- df_base$RTlexdec/1000\n\n\n\n\n10.3.5 Zusammenfassen\nAls Letztes wollen wir lernen, wie man in Base R zusammenfasst. Das ist nicht einfach, wenn man eine Gruppe hat, deshalb werden wir das nicht behandeln.\n\n\n\ntidyverse\n\n  df_tidy |&gt; \n  summarise(\n    mean_lexdec = mean(RTlexdec),\n    sd_lexdec = sd(RTlexdec),\n    mean_naming = mean(RTnaming, na.rm = T),\n    sd_naming = sd(RTnaming, na.rm = T)\n  )\n\n\n# A tibble: 1 × 4\n  mean_lexdec sd_lexdec mean_naming sd_naming\n        &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1        708.      115.        566.      101.\n\n\nIn Base R müssen wir neue Objekte erstellen, die den Wert jeder Operation enthalten, und sie mit der Funktion “data.frame()” zu einem Datenrahmen zusammenfassen.\n\n\n\nBase R\n\ndata.frame(mean_lexdec = mean(df_base$RTlexdec),\n           sd_lexdec = sd(df_base$RTlexdec),\n           mean_naming = mean(df_base$RTnaming, na.rm = T),\n           sd_naming = sd(df_base$RTnaming, na.rm = T))\n\n\n  mean_lexdec sd_lexdec mean_naming sd_naming\n1    708.1336  114.8599    565.9233  100.8153",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#pipes",
    "href": "mats/12-baseR.html#pipes",
    "title": "10  Base R",
    "section": "10.4 Pipes",
    "text": "10.4 Pipes\nLange Zeit waren Pipes ein Feature des Tidyverse, mit der %&gt;% Pipe aus dem magrittr Paket. Seit 2023 bietet R eine native Pipe |&gt;. Sie haben vielleicht schon beide Versionen gesehen (ich tendiere dazu, |&gt; zu benutzen). Für unsere Zwecke sind sie austauschbar, aber es gibt wichtige Unterschiede für komplexere Fälle, die wir nicht behandeln werden.\n\n\n\ntidyverse\n\ndf_base$RTlexdec |&gt; \n  mean()\n\n\n[1] 708.1336\n\n\n\n\n\nBase R\n\ndf_base$RTlexdec %&gt;%\n  mean()\n\n\n[1] 708.1336",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#plots",
    "href": "mats/12-baseR.html#plots",
    "title": "10  Base R",
    "section": "10.5 Plots",
    "text": "10.5 Plots\nggplot2 ist auch bei Leuten beliebt, die sonst nicht die tidyverse-Paketfamilie nutzen. Das liegt daran, dass es einige nützliche Funktionen und ein sauberes Aussehen hat.\nDas Plotten mit Base R kann auch sehr praktisch sein, wenn man einfache Diagramme erstellen will, um einen ersten Blick auf die Daten zu bekommen. Die nützlichsten Funktionen sind hist() und plot(), die jeweils Histogramme und Streudiagramme erzeugen. Beachten Sie, dass diese Funktionen mit Vektoren arbeiten, weswegen wir $ verwenden müssen, um die Spalten aus dem Datenrahmen zu extrahieren.\n\n\n\n\n\n\n\n\nBase R\n\n# left\nhist(df_base$RTlexdec)\n# right\nplot(df_base$RTlexdec, df_base$RTnaming) \n\n\n\n\n\n\n\n\n\nAbbildung 10.1: Histogram and scatterplot with Base R\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.2: Histogram and scatterplot with Base R\n\n\n\n\n\n\nTo achieve the same thing with the tidyverse:\n\n\n\ntidyverse\n\n# histogram\ndf_base |&gt; \n  ggplot() +\n  aes(x = RTlexdec) +\n  geom_histogram()\n\n# scatter plot\n  df_base |&gt; \n  ggplot() +\n  aes(x = RTlexdec, y = RTnaming) +\n  geom_point() \n\n\n\n\n\n\n\n\n\n\nAbbildung 10.3: Histogram and scatterplot with ggplot2",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#lernziele-1",
    "href": "mats/12-baseR.html#lernziele-1",
    "title": "10  Base R",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nIn diesem Kapitel werden wir…\n\nlernen, was Base R ist ✅\nBase R und Tidyverse vergleichen ✅\ndie Base-R-Äquivalente der Tidyverse-Verben kennenlernen ✅",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#weitere-übungen",
    "href": "mats/12-baseR.html#weitere-übungen",
    "title": "10  Base R",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.10",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/12-baseR.html#session-info",
    "href": "mats/12-baseR.html#session-info",
    "title": "10  Base R",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nprint(sessionInfo(),locale = F)\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] patchwork_1.2.0 janitor_2.2.0   here_1.0.1      lubridate_1.9.3\n [5] forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4     purrr_1.0.2    \n [9] readr_2.1.5     tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.1  \n[13] tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        stringi_1.8.3    \n [5] hms_1.1.3         digest_0.6.35     magrittr_2.0.3    evaluate_0.23    \n [9] grid_4.4.0        timechange_0.3.0  fastmap_1.1.1     rprojroot_2.0.4  \n[13] jsonlite_1.8.8    fansi_1.0.6       scales_1.3.0      cli_3.6.2        \n[17] crayon_1.5.2      rlang_1.1.3       bit64_4.0.5       munsell_0.5.1    \n[21] withr_3.0.0       yaml_2.3.8        parallel_4.4.0    tools_4.4.0      \n[25] tzdb_0.4.0        colorspace_2.1-0  pacman_0.5.1      vctrs_0.6.5      \n[29] R6_2.5.1          lifecycle_1.0.4   snakecase_0.11.1  htmlwidgets_1.6.4\n[33] bit_4.0.5         vroom_1.6.5       pkgconfig_2.0.3   pillar_1.9.0     \n[37] gtable_0.3.5      glue_1.7.0        xfun_0.43         tidyselect_1.2.1 \n[41] rstudioapi_0.16.0 knitr_1.46        farver_2.1.1      htmltools_0.5.8.1\n[45] labeling_0.4.3    rmarkdown_2.26    compiler_4.4.0   \n\n\n\n\n\n\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., … Yutani, H. (2019a). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T., Miller, E., Bache, S., Müller, K., Ooms, J., Robinson, D., Seidel, D., Spinu, V., … Yutani, H. (2019b). Welcome to the Tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).\n\n\nWinter, B. (2013). Linear Models and Linear Mixed Effects Models in R: Tutorial 1 (Nr. arXiv:1308.5499).\n\n\nWinter, B. (2014). A Very Basic Tutorial for Performing Linear Mixed Effects Analyses (Tutorial 2) (Nr. arXiv:1308.5499).\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. In Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Base R</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html",
    "href": "mats/13-dataviz_4.html",
    "title": "11  Datenvisualisierung 4",
    "section": "",
    "text": "Lesungen\nFür weitere Lektüre und Übungen zu diesem Thema empfehle ich die Lektüre von Abschnitt 11.5 (Kommunikation: Themen) in Wickham et al. (2023) und Kapitel 4 (Darstellung von zusammenfassenden Statistiken) in Nordmann et al. (2022).",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#lernziele",
    "href": "mats/13-dataviz_4.html#lernziele",
    "title": "11  Datenvisualisierung 4",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Abschnitt werden wir lernen\n\nmehrteilige Diagramme zu erstellen\ndie Position von Geomen anzupassen\nunsere Diagramme für eine bessere Datenkommunikation anzupassen",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#sec-dataviz4_setup",
    "href": "mats/13-dataviz_4.html#sec-dataviz4_setup",
    "title": "11  Datenvisualisierung 4",
    "section": "11.1 Einrichten {.unnumbered}",
    "text": "11.1 Einrichten {.unnumbered}\n\nPakete\nHeute laden wir unsere relevanten tidyverse-Pakete direkt: dplyr und ggplot. Dies sind die einzigen Pakete, die uns beim Laden unserer Daten helfen. Wir laden auch das here-Paket und das janitor-Paket, das für das Aufräumen unserer Daten nützlich ist (z.B. die Funktion clean_names()). Um unsere Diagramme anzupassen, verwenden wir auch die Pakete ggthemes und patchwork. Ersteres hilft uns bei der Erstellung von farbenblindenfreundlichen Plots, während letzteres uns erlaubt, mehrere Plots zusammen zu drucken. Wir brauchen auch ein neues Paket: gghalves.\n\npacman::p_load(tidyverse,\n               here,\n               janitor,\n               ggthemes,\n               patchwork,\n               gghalves\n               )\n\n\n\nDaten\nWir arbeiten wieder mit unserer leicht veränderten Version des english-Datensatzes aus dem Paket languageR.\n\ndf_eng &lt;- read_csv(\n  here(\n    \"daten\",\n    \"languageR_english.csv\"\n  )\n) |&gt; \n  clean_names() |&gt; \n  rename(\n    rt_lexdec = r_tlexdec,\n    rt_naming = r_tnaming\n  )",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#ausweichende-dichteplots",
    "href": "mats/13-dataviz_4.html#ausweichende-dichteplots",
    "title": "11  Datenvisualisierung 4",
    "section": "11.2 Ausweichende Dichteplots",
    "text": "11.2 Ausweichende Dichteplots\nWir können Dichteplots entlang einer katgorischen Variable erstellen, indem wir geom_half_violin() aus dem Paket gghalves verwenden.\n\ndf_eng %&gt;% \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec) +\n  geom_half_violin(alpha = .8)\n\n\n\n\n\n\n\nAbbildung 11.1: Dodged density plots with gghalves::geom_half_violin()\n\n\n\n\n\n\n11.2.1 Hinzufügen eines Boxplots\nWir können auch ein weiteres Geom hinzufügen, um dem Diagramm weitere Informationen hinzuzufügen. Fügen wir einen Boxplot hinzu.\n\ndf_eng %&gt;% \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec) +\n  geom_half_violin(alpha = .8) +\n  geom_boxplot()\n\n\n\n\n\n\n\nAbbildung 11.2: Boxplot on top of our dodged density plot\n\n\n\n\n\n\n\n11.2.2 position_nudge()\nVielleicht wollen wir den Boxplot so verschieben, dass er nicht über den Dichteplots liegt und nicht ganz so breit ist. Wir können dies tun, indem wir position auf position_nudge() und width auf einen Wert kleiner als .75 setzen, was die Standardbreite ist.\n\ndf_eng %&gt;% \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec) +\n  geom_half_violin(alpha = .8) +\n  geom_boxplot(width = .3, # make less wide\n               position = position_nudge(x=0.2)\n               )\n\n\n\n\n\n\n\nAbbildung 11.3: Boxplot on top of our dodged density plot\n\n\n\n\n\n\n\n11.2.3 position_jitter() für Scatterplots\nDies gehört zu einer Familie von Optionen, mit denen man die Position von Geomen verändern kann. Zum Beispiel zeigen Abbildung 11.4 A und B beide genau die gleichen Daten, aber Abbildung 11.4 B enthält position = position_jitter(0.2), um überlappende Punkte zu verschieben. Auf diese Weise erhalten wir eine gute Vorstellung davon, wie viele Beobachtungen es über die Reaktionszeiten hinweg gab (y-Achse).\n\n\nCode\ndf_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec) +\n  geom_point() +\n  labs(title = \"geom_point()\") +\ndf_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec) +\n  geom_point(position = position_jitter(0.2),\n             alpha = 0.2)+\n  labs(title = \"geom_point(position = position_jitter(0.2))\") +\n  \n  plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\n\n\nAbbildung 11.4: Plotting points along a categorical variable without (A) and with (B) position = position_jitter(0.2). Plot B also includes alpha = 0.2\n\n\n\n\n\n\n\n11.2.4 Kombiniert alle drei\nWenn wir alle diese Diagramme zusammenfügen, erhalten wir eine Abbildung 11.5.\n\n\nCode\nfig_no_colour &lt;-\n  df_eng %&gt;% \n  ggplot() +\n  aes(x = age_subject, y = rt_lexdec) +\n  geom_point(position = position_jitter(0.2),\n             alpha = 0.2) +\n  geom_half_violin() +\n  geom_boxplot(\n    outlier.shape = NA,\n               width = .3, \n               position = position_nudge(x=0.2)) \n\n\n\n\n\n\n\n\n\n\nAbbildung 11.5: Density, boxplot, scatterplot",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#positionierung-von-fehlerbalkenplots",
    "href": "mats/13-dataviz_4.html#positionierung-von-fehlerbalkenplots",
    "title": "11  Datenvisualisierung 4",
    "section": "11.3 Positionierung von Fehlerbalkenplots",
    "text": "11.3 Positionierung von Fehlerbalkenplots\nIm zweiten Bericht haben Sie Fehlerbalkenplots erstellt, aber die Fehlerbalken haben sich überschnitten.\n\n\n\n\n\n\n\n\nAbbildung 11.6: Overlapping errorbars\n\n\n\n\n\n\n11.3.1 pivot_longer() |&gt; summarise()\nLassen Sie uns etwas Ähnliches mit dem Datensatz “Englisch” nachstellen. Zuerst werden wir pivot_longer() verwenden, um unsere Daten zu verlängern, dann erstellen wir eine Zusammenfassung der Reaktionszeiten für die lexikalische Entscheidungsaufgabe und die Benennungsaufgabe pro Altersgruppe.\n\nsum_eng &lt;-\n  df_eng |&gt; \n  pivot_longer(\n    cols = c(rt_lexdec, rt_naming),\n    names_to = \"task\",\n    values_to = \"rt\"\n  ) |&gt; \n  summarise(\n    mean = mean(rt, na.rm = T),\n    sd = sd(rt, na.rm = T),\n    .by = c(age_subject, task)\n  ) |&gt; \n  mutate(age_subject = factor(age_subject, levels = c(\"young\", \"old\"))) \n\n\n\n11.3.2 Überlappende Fehlerbalken\nWenn wir für diese Daten ein Fehlerbalken-Diagramm erstellen, erhalten wir Abbildung 11.7.\n\nsum_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean, colour = task, shape = task) +\n  geom_point() +\n  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd))\n\n\n\n\n\n\n\nAbbildung 11.7: Overlapping errorbar plot\n\n\n\n\n\n\n\n11.3.3 position_dodge()\nWir können position = position_dodge(0.2) hinzufügen, damit sich die Fehlerbalken nicht überlappen. Wir werden auch ihre width anpassen, damit sie nicht so breit sind (jeder Wert unter 0.75).\n\nsum_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean, colour = task, shape = task) +\n  geom_point() +\n  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),\n                position = position_dodge(0.2),\n                width = 0.2)\n\n\n\n\n\n\n\nAbbildung 11.8: Overlapping errorbar plot\n\n\n\n\n\n\n\n11.3.4 Ausweichen vor allen relevanten Geomen\nAber jetzt haben wir die Punkte hinter uns gelassen. Wir müssen auch den Punkten ausweichen, also fügen wir position_dodge() zu geom_point() hinzu und stellen sicher, dass wir den gleichen Wert wie bei geom_errorbar() verwenden.\n\nsum_eng |&gt; \n  ggplot() +\n  aes(x = age_subject, y = mean, colour = task, shape = task) +\n  geom_point(position = position_dodge(0.2)) +\n  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),\n                position = position_dodge(0.2),\n                width = 0.2)\n\n\n\n\n\n\n\nAbbildung 11.9: Overlapping errorbar plot",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#anpassungen",
    "href": "mats/13-dataviz_4.html#anpassungen",
    "title": "11  Datenvisualisierung 4",
    "section": "11.4 Anpassungen",
    "text": "11.4 Anpassungen\nWelche Anpassungen sehen Sie in den Diagrammen in Abbildung 11.10?\n\n\nCode\nfig_dens_colour &lt;-\n  df_eng %&gt;% \n  ggplot(aes(x = age_subject, y = rt_lexdec, )) +\n  geom_point(\n    color = \"grey\",\n    position = position_jitter(0.2),\n                 alpha = 0.2) +\n  geom_half_violin(\n    aes(fill = age_subject)) +\n  geom_boxplot(\n    outlier.shape = NA,\n    aes(color = age_subject),\n               width = .3, \n               position = position_nudge(x=0.2)) +\n  labs(title = \"Distribution of reaction times\",\n       x = \"Age group\",\n       y = \"LDT reaction time (ms)\",\n    fill = \"Age group\") +\n  scale_color_colorblind() +\n  scale_fill_colorblind() +\n  theme_minimal() +\n  theme(legend.position = \"none\") \n\nfig_point_colour &lt;-\n  df_eng %&gt;% \n  ggplot(aes(x = age_subject, y = rt_lexdec, )) +\n  geom_point(\n    aes(color = age_subject),\n    position = position_jitter(0.2),\n                 alpha = 0.2) +\n  geom_half_violin() +\n  geom_boxplot(\n    outlier.shape = NA,\n    # aes(color = age_subject),\n               width = .3, \n               position = position_nudge(x=0.2)) +\n  labs(title = \"Distribution of reaction times\",\n       x = \"Age group\",\n       y = \"LDT reaction time (ms)\",\n    fill = \"Age group\") +\n  scale_color_colorblind() +\n  scale_fill_colorblind() +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n\nfig_default &lt;-\n  sum_eng %&gt;% \n  ggplot(aes(x = age_subject, y = mean, \n             colour = task, shape = task)) +\n  geom_point() +\n  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd)) \n\nfig_custom &lt;-\nsum_eng %&gt;%\n  mutate(task = fct_recode(task,\n                           \"LDT\" = \"rt_lexdec\",\n                           \"Naming\" = \"rt_naming\"),\n  age_subject = fct_recode(age_subject,\n                           \"Young\" = \"young\",\n                           \"Old\" = \"old\")) |&gt; \n  ggplot(aes(x = age_subject, y = mean, \n             colour = task, shape = task)) +\n  geom_point(position = position_dodge(0.3),\n             size = 3) +\n  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd),\n                position = position_dodge(0.3), \n                width = .3) +\n  geom_line(aes(group = task,\n                linetype = task),\n                position = position_dodge(0.3)) +\n  theme_minimal() +\n  labs(\n    title = \"Reaction times per group and task\",\n    x = \"Age group\",\n    y = \"Reaction time (ms)\",\n    colour = \"Task\",\n    shape = \"Task\",\n    linetype = \"Task\"\n  ) +\n  theme(axis.title = element_text(size = 12,\n                                  face = \"bold\"),\n        plot.title = element_text(size = 14),\n        legend.title = element_text(face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\nAbbildung 11.10: Customised plots to facilitation data communication.\n\n\n\n\n\n\n11.4.1 Standardthemen\nZunächst wurde theme_minimal() zu jedem Plot hinzugefügt, um das allgemeine Aussehen anzupassen. Es gibt eine Vielzahl von benutzerdefinierten Themen, wie theme_bw() oder theme_classic(). Probieren Sie sie aus.\n\n\n\n\n\n\n\n\nAbbildung 11.11: Preset themes\n\n\n\n\n\n\n\n11.4.2 theme()\nWir können auch einzelne Komponenten des Themas steuern, indem wir Anpassungen mit theme() hinzufügen. Zum Beispiel sehen wir in Abbildung 11.10 A, dass die Achsentitel fett gedruckt sind. Dies wurde durch Hinzufügen von theme(axis.title = element_text(face = \"bold)) erreicht, wobei axis.title = anzeigt, dass wir eine Änderung an den Achsentiteln vornehmen wollen, element_text() zeigt an, dass es ihr Text ist, den wir ändern wollen, und face = \"bold\" zeigt an, dass wir den Text fett machen wollen. Dasselbe wurde für legend.title = gemacht, um den Titel der Legende fett zu machen.\n\n# italicize axis titles\nfig_no_colour + theme_minimal() + \n  theme(\n    axis.title = element_text(face = \"italic\")\n    )\n\n\n\n\n\n\n\nAbbildung 11.12: Using theme()",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#heutige-ziele",
    "href": "mats/13-dataviz_4.html#heutige-ziele",
    "title": "11  Datenvisualisierung 4",
    "section": "Heutige Ziele 🏁",
    "text": "Heutige Ziele 🏁\nWir haben gelernt, wie man…\n\nmehrteilige Plots erstellen ✅\ndie Position von Geomen anzupassen ✅\nunsere Plots für eine bessere Datenkommunikation anpassen ✅",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#weitere-übungen",
    "href": "mats/13-dataviz_4.html#weitere-übungen",
    "title": "11  Datenvisualisierung 4",
    "section": "Weitere Übungen",
    "text": "Weitere Übungen\nWeitere Übungen zu diesem Kapitel finden Sie in Kapitel A.11",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/13-dataviz_4.html#session-info",
    "href": "mats/13-dataviz_4.html#session-info",
    "title": "11  Datenvisualisierung 4",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.3.0.386 (Cherry Blossom).\n\nprint(sessionInfo(),locale = F)\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] magick_2.8.3    gghalves_0.1.4  patchwork_1.2.0 ggthemes_5.1.0 \n [5] janitor_2.2.0   here_1.0.1      lubridate_1.9.3 forcats_1.0.0  \n [9] stringr_1.5.1   dplyr_1.1.4     purrr_1.0.2     readr_2.1.5    \n[13] tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.1   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4        generics_0.1.3    renv_1.0.7        stringi_1.8.3    \n [5] hms_1.1.3         digest_0.6.35     magrittr_2.0.3    evaluate_0.23    \n [9] grid_4.4.0        timechange_0.3.0  fastmap_1.1.1     rprojroot_2.0.4  \n[13] jsonlite_1.8.8    fansi_1.0.6       scales_1.3.0      cli_3.6.2        \n[17] crayon_1.5.2      rlang_1.1.3       bit64_4.0.5       munsell_0.5.1    \n[21] withr_3.0.0       yaml_2.3.8        parallel_4.4.0    tools_4.4.0      \n[25] tzdb_0.4.0        colorspace_2.1-0  pacman_0.5.1      vctrs_0.6.5      \n[29] R6_2.5.1          lifecycle_1.0.4   snakecase_0.11.1  bit_4.0.5        \n[33] htmlwidgets_1.6.4 vroom_1.6.5       pkgconfig_2.0.3   pillar_1.9.0     \n[37] gtable_0.3.5      glue_1.7.0        Rcpp_1.0.12       xfun_0.43        \n[41] tidyselect_1.2.1  rstudioapi_0.16.0 knitr_1.46        farver_2.1.1     \n[45] htmltools_0.5.8.1 labeling_0.4.3    rmarkdown_2.26    compiler_4.4.0   \n\n\n\n\n\n\n\n\nNordmann, E., McAleer, P., Toivo, W., Paterson, H., & DeBruine, L. M. (2022). Data Visualization Using R for Researchers Who Do Not Use R. Advances in Methods and Practices in Psychological Science, 5(2), 251524592210746. https://doi.org/10.1177/25152459221074654\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2. Aufl.).",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Datenvisualisierung 4</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html",
    "href": "mats/16-troubleshooting.html",
    "title": "12  Troubleshooting",
    "section": "",
    "text": "12.1 Ressourcen\nDie Ressourcen, die ich für dieses Kapitel verwendet habe, waren Abschnitt 3.6 “Troublshooting Error Messages” aus dem Webbuch R for Graduate Students von Wendy Huynh (2019), und Perkel (2023).",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#lernziele",
    "href": "mats/16-troubleshooting.html#lernziele",
    "title": "12  Troubleshooting",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Kapitel werden wir lernen…\n\nwie man mit allgemeinen Warnungen und Fehlermeldungen umgeht\nwie man Fehler beim Rendern von Quarto-Skripten behebt\nwo man Hilfe findet, wenn man mit fehlerhaftem Code nicht weiterkommt",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#einrichten",
    "href": "mats/16-troubleshooting.html#einrichten",
    "title": "12  Troubleshooting",
    "section": "12.2 Einrichten",
    "text": "12.2 Einrichten\nDas folgende Code-Stück gibt uns den ersten Fehler:\n\np_load(tidyverse,\n       janitor,\n       here)\n\nError in p_load(tidyverse, janitor, here): could not find function \"p_load\"\n\n\nWas ist das Problem mit dem obigen Code? Die Funktion p_load() konnte nicht gefunden werden, weil sie aus dem Paket pacman stammt, aber wir haben dieses Paket noch nicht geladen. Das ist der Grund, warum wir pacman::p_load() schreiben, wenn wir unsere Pakete einladen.\n\n\n\nTabelle 12.1: List of common messages, the source of the problem, and typical solutions\n\n\n\n\n\n\nUm die Funktion p_load() zu benutzen, müssen wir angeben, dass sie aus dem Paket pacman stammt, wie wir es in diesem Buch immer getan haben (oder wir könnten dieser Zeile library(pacman) voranstellen).\n\npacman::p_load(tidyverse,\n               janitor,\n               here,\n               languageR)",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#fehlermeldungen",
    "href": "mats/16-troubleshooting.html#fehlermeldungen",
    "title": "12  Troubleshooting",
    "section": "12.3 Fehlermeldungen",
    "text": "12.3 Fehlermeldungen\nFehler- oder Warnmeldungen sind bei der Programmierung im Allgemeinen sehr häufig. Programmiersprachen sind sehr wortgetreu, sie versuchen normalerweise nicht zu erraten, was Sie wollen. Das bedeutet, dass selbst der kleinste Fehler Ihren Code zerstören kann. Es kann extrem frustrierend und demotivierend sein, wenn man solche Fehlermeldungen erhält. Es mag ein gewisser Trost sein zu wissen, dass jeder Fehler macht, sogar Profis. Mit zunehmender Erfahrung werden Sie lernen, Codefehler effizienter zu erkennen und zu beheben. Heute lernen wir einige Ressourcen kennen, die Ihnen auf diesem Weg helfen können.\n\n\n\n\n\n\n\n\nAbbildung 12.1: Kunstwerke von Alison Horst\n\n\n\n\n\n\n12.3.1 RStudio-Syntax-Checker\nRStudio erkennt in der Regel Syntaxfehler und teilt Ihnen vor der Ausführung Ihres Codes mit, ob Sie etwas übersehen haben. Das folgende Code-Stück gibt zum Beispiel eine Fehlermeldung aus.\n\nlexdec[c(\"Subject\", \"RT\" \"Correct\")]\n\nError: &lt;text&gt;:1:26: unexpected string constant\n1: lexdec[c(\"Subject\", \"RT\" \"Correct\"\n                             ^\n\n\nRStudio erkennt diesen Syntaxfehler und visualisiert ihn für Sie, wie in Abbildung 12.2. Wir sehen ein rotes “X” neben der Zeilennummer (42) sowie eine rote Unterstreichung für den problematischen oder unerwarteten Code.\n\n\n\n\n\n\n\n\nAbbildung 12.2: RStudio-Syntaxfehler-Warnung\n\n\n\n\n\nDie Syntax von \"Correct\" selbst ist nicht falsch, aber sie ist unerwartet, weil ein Komma nach der vorherigen Zeichenkette fehlt. Erinnern Sie sich, dass c() eine Liste von Argumenten zu einem Vektor kombiniert, und diese Argumente müssen durch ein Komma getrennt werden. Fehlende Kommas sind ein sehr häufiger Grund für fehlerhaften Code, also halten Sie die Augen offen!\n\n\n\n\n\n\n\n\nAbbildung 12.3: Kunstwerke von Alison Horst\n\n\n\n\n\n\n\n12.3.2 Syntaxfehler\nSyntaxfehler sind sehr häufig und treten auf, wenn Sie ein Komma oder eine Klammer ausgelassen haben, ein Objekt, eine Variable oder einen Funktionsnamen falsch geschrieben haben oder sogar eine Funktion aufgerufen haben, ohne vorher das entsprechende Paket zu laden (wie wir es oben mit p_load() getan haben).\nIm Folgenden erhalten wir eine informative Fehlermeldung, die uns sagt, dass eine unerwartete schließende eckige Klammer vorhanden ist.\n\nlexdec[c(\"Subject\", \"RT\", \"Correct\"]\n\nError: &lt;text&gt;:1:36: unexpected ']'\n1: lexdec[c(\"Subject\", \"RT\", \"Correct\"]\n                                       ^\n\n\n\nlexdec[c(\"Subject\", \"rt\", \"Correct\")]\n\nError in `[.data.frame`(lexdec, c(\"Subject\", \"rt\", \"Correct\")): undefined columns selected\n\n\n\nlexdec[c(\"Subject\", \"RT\", \"Correct\"])\n\nError: &lt;text&gt;:1:36: unexpected ']'\n1: lexdec[c(\"Subject\", \"RT\", \"Correct\"]\n                                       ^\n\n\nWenn wir im Tidyverse arbeiten, erhalten wir etwas andere (und manchmal informativere) Fehlermeldungen.\n\nlexdec |&gt; \n  select(\"Subjct\", \"RT\", \"Correct\")\n\nError in `select()`:\n! Can't select columns that don't exist.\n✖ Column `Subjct` doesn't exist.\n\n\nHier wird uns genau gesagt, wo das Problem liegt: Wir haben keine Variable namens Subjct. Dies ist eindeutig ein Tippfehler. Unten erhalten wir einen ähnlichen Fehler.\n\nlexdec |&gt; \n  select(\"subject\", \"RT\", \"Correct\")\n\nError in `select()`:\n! Can't select columns that don't exist.\n✖ Column `subject` doesn't exist.\n\n\nDieses Mal ist der Tippfehler auf die Groß- und Kleinschreibung zurückzuführen, denn unsere Variable “Subjekt” beginnt mit einem großen “S”.\nEinige häufige Syntaxfehler sind:\n\nfalsche Großschreibung (z.B. Lexdec$Subject statt lexdec$Subject)\nTippfehler (z. B. Länge(lexdec) statt Länge(lexdec))\nschließende Interpunktion, wie z. B. ein schließendes Anführungszeichen, eine Klammer oder eine eckige Klammer\nfortgesetzte Interpunktion, typischerweise fehlt ein Komma oder eine Pipe\n\n\n\n\n\n\n\n\n\nAbbildung 12.4: Kunstwerke von Alison Horst",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#rendering-fehler",
    "href": "mats/16-troubleshooting.html#rendering-fehler",
    "title": "12  Troubleshooting",
    "section": "12.4 Rendering-Fehler",
    "text": "12.4 Rendering-Fehler\nDas Rendern eines Quarto-Dokuments kann auch Fehlerwarnungen ausgeben, wenn Ihr Code ausgeführt wurde. Vielleicht lief Ihr Code perfekt, wenn Sie ihn direkt im Skript abgearbeitet haben, aber er funktioniert nicht, wenn er gerendert wird. Diese Fehlerwarnungen sind oft darauf zurückzuführen, dass Ihr Code nicht linear geschrieben wurde (d.h. jeder Codeabschnitt sollte vor dem nächsten ausgeführt werden), oder dass Codeabschnitt-Optionen die Ausführung eines erforderlichen Codeabschnitts blockieren (z.B. durch die Einstellung eval: false). Glücklicherweise enthalten die Fehlerwarnungen Informationen darüber, welcher Codechunk problematisch ist. Manchmal ist der Fehler auf einen Fehler in diesem Codechunk zurückzuführen oder darauf, dass ein vorheriger Codechunk nicht ausgeführt wird, z.B. wenn Quarto ein erforderliches Paket nicht lädt oder Daten nicht lädt oder ein neues Objekt erzeugt. Ein solches Beispiel sehen wir in Abbildung 12.5.\n\n\n\n\n\n\n\n\nAbbildung 12.5: Kunstwerke von Alison Horst\n\n\n\n\n\nSehen Sie sich zunächst die Codeabschnitte in Abbildung 12.5 an. Der erste Codeabschnitt enthält die Option eval: false, und wird daher beim Rendern des Skripts nicht ausgeführt. Das bedeutet, dass das Paket languageR nicht geladen wird. Der zweite Codeabschnitt versucht dann, die ersten 6 Zeilen des Datensatzes lexdec zu drucken, der Teil des Pakets languageR ist, aber da dieses Paket beim Rendern nicht geladen wurde, erhalten wir die Warnung: Objekt 'lexdec' nicht gefunden. Dies ist insofern informativ, als es uns sagt, dass es ein Problem beim Finden von lexdec gibt, aber es sagt uns nicht explizit, dass es daran liegt, dass wir das Paket nicht geladen haben. Bei solchen Fehlern müssen wir manchmal nachforschen, indem wir unseren Code untersuchen.\nSchauen wir uns auch die Fehlerwarnung genauer an. In diesem kurzen Skript können wir leicht erkennen, wo das problematische lexdec ist, aber vielleicht haben wir ein sehr langes Skript geschrieben und es ist nicht klar, wo die Quelle des Problems liegt, wenn wir nur den Fehlertext betrachten. Wir erhalten auch Informationen darüber, wo Quarto auf ein Problem gestoßen ist: Qutting from lines 11-12 [unnamed-chunk-2] (Untitled.qmd). Wir erhalten die Zeilennummer und die Nummer des Codeabschnitts. Dies ist eine sehr nützliche Information, wenn wir ein längeres Skript mit vielen Codeabschnitten haben.\n\n12.4.1 RProjects\nEin häufiger Fehler beim Laden von Daten ist auf einen falschen Dateipfad zurückzuführen. Da wir in diesem Kurs innerhalb eines RProjekts arbeiten, ist dies häufig darauf zurückzuführen, dass wir nicht innerhalb unseres RProjekts arbeiten. Erinnern Sie sich, dass wir das here-Paket verwenden, weil es das Arbeitsverzeichnis relativ zu dem Ordner setzt, der unser RProjekt enthält. Wenn Sie nicht in einem RProjekt arbeiten oder sich in einem falschen RProjekt befinden, ist der Dateipfad nicht korrekt. In einem solchen Fall kann es zu einer Warnung wie in Abbildung 12.6 kommen, wo wir die Warnung \"Users/danielapalleschi/daten/langaugeR_english.csv\" existiert nicht erhalten. Diese Aussage ist richtig, da dieser Dateipfad auf meinem Rechner tatsächlich nicht existiert. Beachten Sie, dass oben in der Mitte des Bildes “RStudio” steht und rechts daneben “Project: (None)”. Beides bedeutet, dass Sie nicht innerhalb eines RProjekts arbeiten, d. h. Ihr Arbeitsverzeichnis ist nicht relativ zu dem Ordner, der Ihr RProjekt enthält. Wenn Sie feststellen, dass Sie in einem falschen oder gar keinem RProjekt arbeiten, können Sie das richtige RProjekt öffnen, indem Sie auf die Stelle klicken, an der “Project: (None)” steht, wo die letzten RProjekte angezeigt werden.\n\n\n\n\n\n\n\n\nAbbildung 12.6: Kunstwerke von Alison Horst\n\n\n\n\n\nVergleichen Sie dies mit Abbildung 12.7. Das gleiche Skript wird ohne Warnung ausgeführt, und Sie können sehen, dass wir innerhalb eines RProjekts mit dem Namen r4ling arbeiten (Sie können das main ignorieren, das hängt mit dem Projekt zusammen, das Git verwendet), und die csv-Datei wird ohne Warnung geladen.\n\n\n\n\n\n\n\n\nAbbildung 12.7: Kunstwerke von Alison Horst\n\n\n\n\n\n\n\n12.4.2 Behebung von Rendering-Fehlern\nWenn Sie auf Rendering-Probleme stoßen, empfehle ich Ihnen, die folgenden Schritte zu befolgen:\n\nPrüfen Sie, ob die Fehlerwarnung mit einer Datei zusammenhängt, die “nicht existiert”.\n\nStellen Sie sicher, dass Sie im richtigen RProjekt arbeiten.\nVergewissern Sie sich, dass die Datei tatsächlich existiert (folgen Sie z. B. dem in der Fehlermeldung angegebenen Dateipfad auf Ihrem Computer, um sicherzustellen, dass die Datei tatsächlich in diesem Verzeichnis existiert; achten Sie auf Tippfehler in Ordner- oder Dateinamen).\n\nSchauen Sie sich an, wo das Problem aufgetreten ist (welche Zeile/Codechunk), und gehen Sie zu dem Codechunk.\nInterpretieren Sie den Fehlertext und den Code: Ist sofort klar, wo das Problem liegt?\n\nJa: gut, beheben Sie es!\nNein: weiter\n\nPrüfen Sie die obigen Code-Chunk-Optionen, gibt es irgendetwas mit eval: false, das ausgeführt werden muss?\n\nJa: prima, beheben Sie es!\nNein: weiter\n\nLöschen Sie Ihre R-Sitzung (Session &gt; Restart R)\n\nAlternativ können Sie die R-Sitzung löschen und dann auf die Schaltfläche “Run &gt; Run All Chunks Above” (Ausführen &gt; Alle Chunks oben ausführen) in der rechten oberen Ecke des Editorfensters klicken (in Abbildung 12.5, “Run”). Dieser Schritt befolgt die Code-Chunk-Optionen. Dies sollte zu demselben Fehler führen. Wenn dies nicht der Fall ist, versuchen Sie, R zu schließen und erneut zu öffnen. Wenn der gleiche Fehler auftritt, Sie aber immer noch nicht wissen, was er bedeutet, fahren Sie fort.\n\nLöschen Sie Ihre R-Sitzung (Session &gt; Restart R) und führen Sie jeden Codechunk vom Anfang Ihres Skripts bis zum problematischen Codechunk aus, wobei Sie genau auf die Codechunk-Optionen achten. Sehen Sie, was das Problem ist?\n\nJa: beheben\nNein: weiter\n\n\nWenn Sie nach diesen Schritten nicht in der Lage sind, den Fehler zu lokalisieren und zu beheben, würde ich Sie weiterhin um Hilfe bitten. Wir werden uns nun einige Stellen ansehen, an denen Sie Antworten auf Fehler finden können, die Sie nicht ohne weiteres selbst lösen können.",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#um-hilfe-bitten",
    "href": "mats/16-troubleshooting.html#um-hilfe-bitten",
    "title": "12  Troubleshooting",
    "section": "12.5 Um Hilfe bitten",
    "text": "12.5 Um Hilfe bitten\nFür manche Probleme ist es schwierig, eine Lösung zu finden. Glücklicherweise gibt es eine sehr aktive R-Gemeinschaft im Internet. Es gibt viele Quellen für Hilfe, aber wir werden uns hier die häufigsten und hilfreichsten ansehen.\n\n12.5.1 Google\nIm Zweifelsfall: Google! Wenn Sie die Fehlermeldung, die Sie erhalten, in Google eingeben, erhalten Sie in der Regel eine Vielzahl von Antworten. Je nachdem, wie häufig dieser Fehler auftritt und wie technisch die Erklärung ist, die Sie finden, können diese Antworten hilfreich sein oder auch nicht. Möglicherweise finden Sie einige Blogbeiträge oder Forenbeiträge, in denen das Problem und mögliche Lösungen diskutiert werden. Dies ist ein guter erster Schritt, um das Problem zu lösen.\n\n\n12.5.2 Stackoverflow\nStack Overflow ist eine Online-Community für Entwickler mit vielen Forenbeiträgen zu R-Programmierproblemen. In der Regel finden Sie einen Thread, in dem jemand das gleiche Problem hatte wie Sie, und mehrere andere antworten mit möglichen Lösungen. Dies kann eine großartige Möglichkeit sein, zu lernen und Lösungen zu finden, und wenn Sie ein Problem googeln, werden Sie normalerweise zu einem Stack Overflow-Thread geführt. Wenn Sie wirklich nicht weiterkommen, können Sie sogar Ihre eigene Frage stellen! Dazu müssen Sie ein Konto erstellen.\n\n\n12.5.3 Dokumentation\nDenken Sie daran, dass es eine Fülle von Dokumentationen für Pakete (und Funktionen) gibt. Wenn Sie bemerken, dass ein Code-Stück einen Fehler auslöst, versuchen Sie, die Hilfeseite für das entsprechende Paket oder die Funktion (?Paket oder ?Funktion in der Konsole) aufzurufen. Alternativ können Sie auch den Namen des Pakets oder der Funktion in Google eingeben, um die Online-Dokumentation zu finden, die Ihnen helfen könnte, besser zu verstehen, was die Funktion erwartet, und dies mit dem zu vergleichen, was Sie ihr gegeben haben.\n\n\n12.5.4 ChatGPT\n\nChatbots work best for small, discrete programming tasks, such as loading data, performing basic data manipulations and creating visualizations and websites.\n— Perkel (2023)\n\nObwohl ich ChatGPT selbst nicht oft benutze, habe ich von weniger erfahrenen R-Benutzern gehört, dass es beim Auffinden von Syntaxfehlern ein Lebensretter sein kann. Ich schlage ChatGPT erst zum Schluss vor, denn obwohl es bei Syntaxfehlern sehr effizient ist, kann man seinen Code am besten verbessern, wenn man lernt, einfache Fehler schnell zu erkennen und zu lokalisieren, ohne sich auf die KI verlassen zu müssen. Es kann jedoch von großem Vorteil sein, Zeit zu sparen, wenn Sie das Problem in Ihrem Code einfach nicht erkennen können, und ChatGPT liefert detaillierte Beschreibungen dessen, was es für das Problem hält und wie der vorgeschlagene Code das Problem behebt. Dies kann ein wertvolles Lernmittel sein.\nDas Kopieren und Einfügen von Code ist sehr üblich (Sie werden in der Regel nicht ein ganzes Skript von Grund auf neu schreiben). Wichtig ist, dass Sie Ihren Code verstehen, denn das ist der beste Weg, um ihn schnell zu reparieren, wenn etwas schief läuft, und ChatGPT, Google, Stackflow und dergleichen werden Ihnen nicht immer helfen können. ChatGPT wird Ihnen zum Beispiel nicht sagen können, dass Sie einen Variablennamen mit Kamelhülsen geschrieben haben (cameCaseLooksLikeThis), wenn Ihre Variablen mit Schlangenhülsen benannt sind (snake_case_looks_like_this), oder wenn es einen anderen Tippfehler gibt, der nichts mit der Syntax zu tun hat. Wenn Sie in der Lage sind, Fehler-/Warnmeldungen zu interpretieren und die Ursache des Problems ausfindig zu machen, ist das der schnellste Weg zur Lösung.\nDennoch können Syntaxfehler für neue Programmierer schwierig zu erkennen sein. Wenn man nicht weiterkommt, kann es hilfreich sein, ChatGPT zu benutzen, um nicht nur eine Lösung zu erhalten, sondern auch eine detaillierte Beschreibung der Fehlerquelle und -lösung. Um ChatGPT auszuprobieren, müssen Sie ein Konto haben.\n\n\n\nThe temptation to copy and paste code snippets from ChatGPT or Stackoverflow is real, but true mastery lies in comprehension. I've copied and pasted a lot of code. But as a programmer, it's your duty to understand. And to do so, you'll eventually end up in documentation 😉. pic.twitter.com/HWi09tPz6O\n\n— Travis Oliphant ((teoliphant?)) October 20, 2023\n\n\n\nEs ist wichtig zu wissen, dass ChatGPT ein Tausendsassa ist, der nichts beherrscht. Das bedeutet, dass es sich mit vielen Themen auskennt, aber kein Experte in einem dieser Themen ist. Der beste Ratschlag in Bezug auf die Verwendung von ChatGPT für Programmierzwecke, den ich gefunden habe, lautet: “Vertrauen, aber überprüfen” (Perkel, 2023). Vertrauen Sie nicht blind auf das, was die KI Ihnen sagt: Sie ist nur so gut wie die Daten, auf denen sie trainiert wurde, und kann überheblich sein und überzeugend klingen. Denken Sie daran, dass “‘[i]m Falle, dass Sie nicht genug wissen, um den Unterschied zwischen etwas Richtigem und etwas, das eigentlich Unsinn ist, zu erkennen, Sie sich in Schwierigkeiten bringen könnten’” (Zitat der Linguistin Emily Morgan von der UC Davis in Perkel, 2023).\nSeien Sie also skeptisch gegenüber den Lösungen, die ChatGPT Ihnen anbietet, vor allem, wenn Ihre Probleme komplexer werden. Testen Sie immer, ob der vorgeschlagene Code nicht nur ohne eine weitere Warnung oder Fehlermeldung läuft, sondern ob er auch das erreicht, was Sie erwarten. Nur weil Sie keine Warnung erhalten, heißt das nicht, dass der Code auch das tut, was Sie wollen!\n\n\n\n\n\n\nDisclaimer\n\n\n\nChatGPT und Datenschutz: Alles, was Sie in ChatGPT eingeben, wird an die Server von OpenAI gesendet und kann für Trainingszwecke verwendet werden. Geben Sie niemals sensible Informationen in ChatGPT ein.\nChatGPT und akademische Integrität: Denken Sie daran, dass der Einsatz von künstlicher Intelligenz im akademischen Umfeld derzeit eine Grauzone ist. Ich empfehle die Verwendung von ChatGPT zur Fehlersuche in bereits fehlerhaftem Code oder zur Unterstützung bei der Lösung komplexer Programmieraufgaben. Schauen Sie sich unbedingt die Empfehlungen für das Umgehen mit Künstlicher Intelligenz in Prüfungen der Humboldt-Universität an .\nDarüber hinaus werden LLM (Large Language Models) auf Daten trainiert, die aktuell sein können oder auch nicht. Zum Beispiel wird ChatGPT vielleicht nicht auf der neuesten Version eines Pakets trainiert und ist sich daher möglicherweise der Probleme mit einem veralteten Argument nicht bewusst.\nEin weiteres, allgemeineres Problem bei der Verwendung von ChatGPT oder einem anderen LMM (Large Language Model) ist die Frage, ob es ethisch vertretbar ist, sich zu sehr auf künstliche Intelligenz zu verlassen, bei der wiederholt festgestellt wurde, dass sie rassische und geschlechtsspezifische Vorurteile hat (was sich nicht auf Ihren Code auswirken sollte, aber eine größere Frage bezüglich der Fütterung des Modells ist).",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#lernziele-1",
    "href": "mats/16-troubleshooting.html#lernziele-1",
    "title": "12  Troubleshooting",
    "section": "Lernziele 🏁",
    "text": "Lernziele 🏁\nIn diesem Kapitel haben wir gelernt…\n\nwie man mit allgemeinen Warnungen und Fehlermeldungen umgeht ✅\nwie man Fehler beim Rendern von Quarto-Skripten behebt ✅\nwo man Hilfe findet, wenn man mit fehlerhaftem Code nicht weiterkommt ✅",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "mats/16-troubleshooting.html#session-info",
    "href": "mats/16-troubleshooting.html#session-info",
    "title": "12  Troubleshooting",
    "section": "Session Info",
    "text": "Session Info\nHergestellt mit R version 4.4.0 (2024-04-24) (Puppy Cup) und RStudioversion 2023.9.0.463 (Desert Sunflower).\n\nprint(sessionInfo(),locale = F)\n\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] languageR_1.5.0 here_1.0.1      janitor_2.2.0   lubridate_1.9.3\n [5] forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4     purrr_1.0.2    \n [9] readr_2.1.5     tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.1  \n[13] tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5      jsonlite_1.8.8    compiler_4.4.0    renv_1.0.7       \n [5] tidyselect_1.2.1  snakecase_0.11.1  scales_1.3.0      yaml_2.3.8       \n [9] fastmap_1.1.1     R6_2.5.1          generics_0.1.3    knitr_1.46       \n[13] htmlwidgets_1.6.4 rprojroot_2.0.4   munsell_0.5.1     pillar_1.9.0     \n[17] tzdb_0.4.0        rlang_1.1.3       utf8_1.2.4        stringi_1.8.3    \n[21] xfun_0.43         timechange_0.3.0  cli_3.6.2         withr_3.0.0      \n[25] magrittr_2.0.3    digest_0.6.35     grid_4.4.0        rstudioapi_0.16.0\n[29] hms_1.1.3         lifecycle_1.0.4   vctrs_0.6.5       evaluate_0.23    \n[33] glue_1.7.0        fansi_1.0.6       colorspace_2.1-0  pacman_0.5.1     \n[37] rmarkdown_2.26    tools_4.4.0       pkgconfig_2.0.3   htmltools_0.5.8.1\n\n\n\n\n\n\n\n\nPerkel, J. M. (2023). Six Tips for Better Coding with ChatGPT. Nature, 618(7964), 422–423. https://doi.org/10.1038/d41586-023-01833-0",
    "crumbs": [
      "Fortgeschrittene Themen",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Troubleshooting</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 1/bericht_1_DE.html",
    "href": "berichte/bericht 1/bericht_1_DE.html",
    "title": "13  Bericht 1",
    "section": "",
    "text": "13.1 Beschreibung\nDieser Bericht dient als Rückblick auf die Fähigkeiten, die in Kapitel 1 bis Kapitel 5 Ihre Aufgaben umfassen das Laden von Paketen und Daten sowie eine leichte Datenverarbeitung (Kapitel 13.3). Außerdem werden Sie 4 Diagramme erstellen (Kapitel 13.4) und eine kurze Interpretation zu einem der Diagramme schreiben (Kapitel 13.5).\nEin Tipp: Ich empfehle Ihnen, Ihr Dokument häufig zu rendern, um eventuelle Fehler frühzeitig zu erkennen.",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Bericht 1</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 1/bericht_1_DE.html#einrichtung",
    "href": "berichte/bericht 1/bericht_1_DE.html#einrichtung",
    "title": "13  Bericht 1",
    "section": "13.2 Einrichtung",
    "text": "13.2 Einrichtung\n\n13.2.1 Quarto\nÖffnen Sie ein neues Quarto-Skript und speichern Sie es als nachname_vorname_bericht1.qmd. Ändern Sie das YAML so, dass es einen:\n\neinen aussagekräftigen Titel\nIhren Namen als Autor\nein Inhaltsverzeichnis\n\nAchten Sie darauf, Code Chunks, Prosa und Überschriften zu verwenden, um Ihre Aufgaben angemessen zu dokumentieren. Eine gute Faustregel ist, für jede (Unter-)Überschrift in diesem Dokument eine Überschrift hinzuzufügen.\n\n\n13.2.2 Pakete\nLaden Sie die Pakete tidyverse und languageR ein.\n\n\n13.2.3 Daten\nDer Datensatz durationsGe aus dem languageR-Paket (Baayen & Shafaei-Bajestan, 2019) enthält Dauermessungen zur niederländischen Vorsilbe ge. Eine Beschreibung aller Variablen des Datensatzes findet sich in Tabelle 13.1. Ihre Aufgabe ist es:\n\nSpeichern Sie den Datensatz als Objekt df_ge in Ihrer Umgebung (dies kann auf die gleiche Weise geschehen wie bei allen Datensätzen, die wir bisher verwendet haben)\nDrucken Sie die ersten 10 Zeilen des Datensatzes mit der Funktion “head()” aus.\n\n\n\n\n\nTabelle 13.1: ‘Data dictionary’ für ‘durationsGe’ aus dem languageR-Paket\n\n\n\n\n\n\n\n\n\n\nVariable\nBeschreibung\n\n\n\n\nWord\nein Faktor mit den Wörtern als Ebenen\n\n\nFrequency\nein numerischer Vektor mit der absoluten Häufigkeit des Wortes im Spoken Dutch Corpus\n\n\nSpeaker\nein numerischer Vektor mit der absoluten Häufigkeit des Wortes im Spoken Dutch Corpus\n\n\nSex\nein Faktor mit den Lautsprechern als Ebenen\n\n\nYearOfBirth\nein numerischer Vektor mit Geburtsjahren\n\n\nDurationOfPrefix\nein numerischer Vektor mit der Dauer des Präfixes -ge in Sekunden.\n\n\nSpeechRate\nein numerischer Vektor, der die Sprechgeschwindigkeit in Anzahl der Silben pro Sekunde kodiert\n\n\nNumberSegmentsOnset\nein numerischer Vektor, der die Sprechgeschwindigkeit in Anzahl der Silben pro Sekunde kodiert",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Bericht 1</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 1/bericht_1_DE.html#sec-bericht1_wrangle",
    "href": "berichte/bericht 1/bericht_1_DE.html#sec-bericht1_wrangle",
    "title": "13  Bericht 1",
    "section": "13.3 Data wrangling",
    "text": "13.3 Data wrangling\nHier werden Sie die dplyr-Verben aus Woche 4 verwenden. Denken Sie daran, dass Sie den Zuweisungsoperator (&lt;-) nur verwenden müssen, wenn Sie die Änderungen, die Sie vornehmen, als Objekt in der Umgebung speichern wollen. Wenn Sie diese Änderungen nur ausdrucken wollen, brauchen Sie den Zuweisungsoperator nicht.\n\n13.3.1 filter()\nDrucken (aber nicht in Ihrer Umgebung speichern) Sie die Zeilen von df_ge, in denen SpeechRate über 9 liegt, nur mit den Spalten word, speaker und SpeechRate. Es sollten 5 Zeilen sein.\n\n\n13.3.2 mutate()\nFügen Sie eine neue Variable hinzu, duration_ms, die DauerVonPräfix multipliziert mit 1000 (DurationOfPrefix*1000) entspricht. Dies entspricht der Dauer von ge in Millisekunden, statt in Sekunden. Stellen Sie sicher, dass Sie diese neue Variable in Ihrem Datenrahmen speichern (Hinweis: Sie müssen den Zuweisungsoperator &lt;- und das dplyr-Verb mutate() verwenden).\n\n\n13.3.3 Fehlersuche\nWarum läuft dieser Code nicht? Es gibt zwei Probleme mit dem Code, identifizieren und beheben Sie sie.\n\n# Troubleshooting\ndf_ge  |&gt; \n  filter(YearOfBirth == 1978) +\n  select(Frequency, word)",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Bericht 1</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 1/bericht_1_DE.html#sec-bericht1_dataviz",
    "href": "berichte/bericht 1/bericht_1_DE.html#sec-bericht1_dataviz",
    "title": "13  Bericht 1",
    "section": "13.4 Datenvisualisierung",
    "text": "13.4 Datenvisualisierung\nVerwenden Sie für alle Diagramme labs(title = \"...\"), um entsprechende Diagrammtitel hinzuzufügen.\nOptional: Ändern Sie die x und y Achsenbeschriftungen, wenn Sie wollen, mit labs(x = \"...\", y = \"...\"). Vielleicht möchten Sie auch ein Thema hinzufügen (z.B. theme_minimal()).\n\n13.4.1 Scatterplot\nErstellen Sie ein Streudiagramm mit SpeechRate (x-Achse) und DurationOfPrefix (y-Achse), mit YearOfBirth als Farbe (colour). Ändern Sie die Einstellungen für den Codechunk so, dass das Diagramm beim Rendern des Skripts nicht gedruckt wird, der Code aber schon. Tipp: Sie müssen #| eval: verwenden.\n\n\n13.4.2 Facetten\nFügen Sie Facetten für Sex hinzu (denken Sie daran, die Tilde ~ einzufügen). Ändern Sie die Code-Chunk-Einstellungen so, dass die Darstellung gedruckt wird, wenn das Skript gerendert wird, aber der Code nicht (Sie benötigen echo anstelle von eval).\n\n\n13.4.3 Reproduzieren eines Plots\nReproduzieren Sie die Abbildung 13.1 (es muss keine exakte Kopie sein, aber kommen Sie ihr so nahe wie möglich). Stellen Sie sicher, dass sowohl der Code als auch die Darstellung beim Rendern gedruckt werden. Hinweis: Sie müssen filter() sowohl für Frequency als auch für Sex verwenden. Ich würde mich darauf konzentrieren, zuerst das Diagramm zu erstellen und dann zu versuchen, die Daten zu filtern.\n\n\n\n\n\n\n\n\nAbbildung 13.1: A figure to be reproduced",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Bericht 1</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 1/bericht_1_DE.html#sec-bericht1_interpret",
    "href": "berichte/bericht 1/bericht_1_DE.html#sec-bericht1_interpret",
    "title": "13  Bericht 1",
    "section": "13.5 Interpretation",
    "text": "13.5 Interpretation\nBeschreiben Sie die Beziehung zwischen den beiden Variablen, die Sie in Abbildung 13.1 sehen.\n\n\n\n\nBaayen, R. H., & Shafaei-Bajestan, E. (2019). languageR: Analyzing Linguistic Data: A Practical Introduction to Statistics. https://CRAN.R-project.org/package=languageR",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Bericht 1</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html",
    "href": "berichte/bericht 2/bericht_2.html",
    "title": "14  Bericht 2",
    "section": "",
    "text": "Beschreibung des Datensatzes\nDiese Beschreibung soll einen gewissen Kontext zu dem Datensatz liefern. Der Zweck dieses Berichts ist es jedoch, Ihre Fähigkeit zu demonstrieren, die Daten zu laden, zu verarbeiten, zusammenzufassen und darzustellen. Auch wenn Ihnen die Konzepte, die für den Datensatz relevant sind, nicht klar sind, werden Sie in der Lage sein, die Aufgaben zu lösen.\nDer Datensatz enthält Eye-Tracking-Lesezeiten über Satzregionen hinweg für spanische Sätze mit einem zukunfts- oder vergangenheitsbezogenen temporalen Adverb (z.B., gestern* oder morgen* auf Deutsch) am Satzanfang und einem Verb in der Vergangenheits- oder Zukunftsform am Ende des Satzes. Eine entscheidende Manipulation war, ob die Zeitform des Verbs mit dem vorangehenden temporalen Adverb übereinstimmte oder nicht. Tabelle 14.1 enthält einige Beispielstimuli.\nTabelle 14.1: Example stimuli\n\n\n\n\n\n\n\nSatz\nAdverb\nVerb\nGrammatikalität\n\n\n\n\nA la salida del trabajo, ayer las chicas compraron pan en la tienda. (DE:) Nach der Arbeitgestern kauften die Mädchen Brot im Laden\npast\npast\ngramm\n\n\nA la salida del trabajo, ayer las chicas *comprarán pan en la tienda. (DE:) Nach der Arbeitgestern *werden die Mädchen im Laden Brotkaufen\npast\nfuture\nungramm\n\n\nA la salida del trabajo, mañana las chicas comprarán pan en la tienda. (DE:) Nach der Arbeitmorgen die Mädchenwerden Brot im Ladenkaufen\nfuture\nfuture\ngramm\n\n\nA la salida del trabajo, mañana las chicas *compraron pan en la tienda. (DE:) Nach der Arbeitmorgen die Mädchen *kauften Brot im Laden*\nfuture\npast\nungramm\nFür die Zwecke dieses Berichts sind folgende Variablen von Interesse:\nLängere Eye-Tracking-Lesezeiten sind in der Regel mit Schwierigkeiten beim Sprachverständnis verbunden. Es hat sich beispielsweise gezeigt, dass syntaktisch komplexe Sätze (im Gegensatz zu einfachen Sätzen) oder Wörter, die im vorangegangenen Kontext ungrammatisch sind (im Gegensatz zu grammatikalischen Wörtern), längere Lesezeiten hervorrufen. Aus diesem Grund würden wir erwarten, dass die Lesezeiten unter ungrammatischen Bedingungen länger sind als unter grammatikalischen Bedingungen. Eine weitere Forschungsfrage von Biondo et al. (2022) war, ob es Unterschiede in der Verarbeitung (d. h. in den Lesezeiten) zwischen den Zeitformen Vergangenheit und Zukunft gibt.\nDurch die Untersuchung dieses Datensatzes sind wir an folgenden Fragen interessiert:\nSie werden Diagramme und zusammenfassende Statistiken erstellen, um diese Fragen zu beantworten.",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html#einrichten",
    "href": "berichte/bericht 2/bericht_2.html#einrichten",
    "title": "14  Bericht 2",
    "section": "14.1 Einrichten",
    "text": "14.1 Einrichten\nFühren Sie den folgenden Code aus, um Ihre Umgebung für die folgenden Aufgaben einzurichten.\n\nPackages\nFühren Sie den folgenden Code aus, um die erforderlichen Pakete zu laden: tidyverse, here, janitor, und patchwork.\n\npacman::p_load(\n  tidyverse,\n  here,\n  janitor,\n  patchwork\n)\n\n\n\nDaten laden\nNachfolgend finden Sie einen Code, der einen Datensatz von Biondo et al. (2022) lädt, eine Studie zur Beobachtung von Augenbewegungen beim Lesen. Es gibt einen Kommentar, in dem beschrieben wird, was die einzelnen Zeilen bewirken, falls Sie daran interessiert sind. Dieser Datensatz muss zuerst heruntergeladen und in Ihrem Daten-Ordner gespeichert werden.\n\ndf_biondo &lt;-\n  read_csv(here(\"daten\", \"Biondo.Soilemezidi.Mancini_dataset_ET.csv\"),\n           \n1           locale = locale(encoding = \"Latin1\")) |&gt;\n2  clean_names() |&gt;\n3  mutate(gramm = ifelse(gramm == 0, \"ungramm\", \"gramm\")) |&gt;\n4  filter(adv_type == \"Deic\",\n         roi %in% c(2,4)) \n\n\n1\n\nspezielle Formatierung für spanische Zeichen\n\n2\n\ntidy Variablennamen\n\n3\n\nGrammatikalität umschlüsseln\n\n4\n\nnur Beobachtungen von deiktischen Adverbien behalten und die Satzregionen Adverb (2) und Verb (4)\n\n\n\n\n\n\nDatenumwandlung 1: Transformation\nFügen Sie unter Verwendung von Pipes (|&gt;) dem obigen Code-Stück eine Zeile hinzu:\n\neine Zeile, in der Sie die Variable verb_t in tense umbenennen\neine Zeile, in der Sie nur die Variablen roi, label, tense, gramm, fp, und tt auswählen\n\nSie sollten dann einen Datenrahmen mit 7680 Beobachtungen und 6 Variablen haben. Die ersten sechs Zeilen sollten wie folgt aussehen:\n\n\n# A tibble: 6 × 6\n    roi label            tense  gramm    fp    tt\n  &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     2 ayer temprano    Past   gramm   474   474\n2     4 encargaron       Past   gramm  1027  1027\n3     2 el próximo año   Future gramm   593  1356\n4     4 coleccionarán    Future gramm   562  1337\n5     2 el verano pasado Past   gramm  1185  1185\n6     4 esquilaron       Past   gramm   293  1141",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html#plot-interpretation-verteilung",
    "href": "berichte/bericht 2/bericht_2.html#plot-interpretation-verteilung",
    "title": "14  Bericht 2",
    "section": "14.2 Plot-Interpretation: Verteilung",
    "text": "14.2 Plot-Interpretation: Verteilung\nBetrachten Sie Abbildung 14.1 A und B und beschreiben Sie die Diagramme. Beide enthalten nur Daten aus der Verbregion eines Satzes (roi == 4). Geben Sie den ungefähren Modus sowie die Minimal- und Maximalwerte für den gesamten Datensatz (Abbildung 14.1 A) und den Median, den Minimal- und den Maximalwert pro Bedingung (Abbildung 14.1 B) an.\n\n\n\n\n\n\n\n\nAbbildung 14.1: Zu interpretierende Plots",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html#data-wrangling-2-aufräumen",
    "href": "berichte/bericht 2/bericht_2.html#data-wrangling-2-aufräumen",
    "title": "14  Bericht 2",
    "section": "14.3 Data wrangling 2: Aufräumen",
    "text": "14.3 Data wrangling 2: Aufräumen\nVerwenden Sie die Funktion pivot_longer(), um den Datensatz zu verlängern, wobei die Spalten (cols =) fp und tt zu einer Spalte (names_to =) namens measure werden und ihre Werte in einer Spalte (values_to =) namens time gespeichert werden. Speichern Sie das Ergebnis als df_longer. Es sollte 15360 Beobachtungen und 6 Spalten enthalten.\n\ndf_longer &lt;-",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html#zusammenfassende-statistik",
    "href": "berichte/bericht 2/bericht_2.html#zusammenfassende-statistik",
    "title": "14  Bericht 2",
    "section": "14.4 Zusammenfassende Statistik",
    "text": "14.4 Zusammenfassende Statistik\nVerwenden Sie die Funktion summarise(), um den Mittelwert und die Standardabweichung von time zu ermitteln. Gruppieren Sie die Ergebnisse nach measure, tense, gramm und roi (entweder mit .by = oder group_by()).\n\nsum_et &lt;-\n\nDrucken Sie die Zusammenfassung.",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html#visualisierung-zusammenfassender-statistiken",
    "href": "berichte/bericht 2/bericht_2.html#visualisierung-zusammenfassender-statistiken",
    "title": "14  Bericht 2",
    "section": "14.5 Visualisierung zusammenfassender Statistiken",
    "text": "14.5 Visualisierung zusammenfassender Statistiken\nIn dieser Aufgabe erstellen Sie zwei Fehlerdiagramme und drucken sie nebeneinander aus.\n\nAdverb-Region\nErzeugen Sie ein Fehlerdiagramm namens fig_adverb für die Region adverb (roi == 2) der soeben erstellten Zusammenfassung mit folgender Ästhetik: + Grammatikalität auf der x-Achse + Mittelwert auf der y-Achse + Zeitform als Farbe und Form + Fehlerbalken mit +/- 1 Standardabweichung + Facetten für die Messung + ein geeigneter Titel für die Darstellung und Beschriftungen der x- und y-Achse\n\nfig_adverb &lt;-\n\n\n\nVerb-Region\nErzeugen Sie die gleiche Darstellung für die Region verb (roi == 4) mit dem Namen fig_verb.\nTipp: Sie können einfach den Code aus der Darstellung der Adverbregion kopieren und die Region (roi) in das Verb ändern!\n\nfig_verb &lt;-\n\n\n\nPlots drucken\nStellen Sie Ihre beiden Fehlerbalken nebeneinander dar, indem Sie das Paket patchwork verwenden",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "berichte/bericht 2/bericht_2.html#plot-interpretation-zusammenfassende-statistiken",
    "href": "berichte/bericht 2/bericht_2.html#plot-interpretation-zusammenfassende-statistiken",
    "title": "14  Bericht 2",
    "section": "14.6 Plot-Interpretation: zusammenfassende Statistiken",
    "text": "14.6 Plot-Interpretation: zusammenfassende Statistiken\nBeschreiben Sie etwaige Unterschiede zwischen den Bedingungen und Regionen auf der Grundlage der von Ihnen erstellten Zusammenfassung und der aus der Zusammenfassung generierten Diagramme.\n\n\n\n\nBiondo, N., Soilemezidi, M., & Mancini, S. (2022). Yesterday Is History, Tomorrow Is a Mystery: An Eye-Tracking Investigation of the Processing of Past and Future Time Reference during Sentence Reading. Journal of Experimental Psychology: Learning, Memory, and Cognition, 48(7), 1001–1018. https://doi.org/10.1037/xlm0001053",
    "crumbs": [
      "Berichte",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bericht 2</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Baayen, R. H. (2008). Analyzing Linguistic Data:\nA Practical Introduction to Statistics using\nR.\n\n\nBaayen, R. H., & Shafaei-Bajestan, E. (2019). languageR:\nAnalyzing linguistic data: A practical introduction to statistics.\nhttps://CRAN.R-project.org/package=languageR\n\n\nBiondo, N., Soilemezidi, M., & Mancini, S. (2022). Yesterday is\nhistory, tomorrow is a mystery: An eye-tracking\ninvestigation of the processing of past and future time reference during\nsentence reading. Journal of Experimental Psychology: Learning,\nMemory, and Cognition, 48(7), 1001–1018. https://doi.org/10.1037/xlm0001053\n\n\nDavies, R., Locke, S., & D’Agostino McGowan, L. (2022).\ndatasauRus: Datasets from the datasaurus dozen. https://CRAN.R-project.org/package=datasauRus\n\n\nMüller, K. (2020). Here: A simpler way to find your files. https://CRAN.R-project.org/package=here\n\n\nNordmann, E., & DeBruine, L. (2022). Applied data skills.\nZenodo. https://doi.org/10.5281/zenodo.6365078\n\n\nNordmann, E., McAleer, P., Toivo, W., Paterson, H., & DeBruine, L.\nM. (2022). Data Visualization Using R for Researchers\nWho Do Not Use R. Advances in Methods and Practices in\nPsychological Science, 5(2), 251524592210746. https://doi.org/10.1177/25152459221074654\n\n\nPerkel, J. M. (2023). Six tips for better coding with\nChatGPT. Nature, 618(7964), 422–423. https://doi.org/10.1038/d41586-023-01833-0\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D.,\nFrançois, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M.,\nPedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J.,\nRobinson, D., Seidel, D. P., Spinu, V., … Yutani, H. (2019a). Welcome to\nthe tidyverse. Journal of Open Source\nSoftware, 4(43), 1686. https://doi.org/10.21105/joss.01686\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L., François,\nR., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen,\nT., Miller, E., Bache, S., Müller, K., Ooms, J., Robinson, D., Seidel,\nD., Spinu, V., … Yutani, H. (2019b). Welcome to the\nTidyverse. Journal of Open Source Software,\n4(43), 1686. https://doi.org/10.21105/joss.01686\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science (2nd ed.).\n\n\nWinter, B. (2013). Linear models and linear mixed effects models in\nR: Tutorial 1 (No. arXiv:1308.5499).\n\n\nWinter, B. (2014). A very basic tutorial for performing linear mixed\neffects analyses (Tutorial 2) (No. arXiv:1308.5499).\n\n\nWinter, B. (2019). Statistics for Linguists: An\nIntroduction Using R. In Statistics for Linguists: An\nIntroduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n\n\nXie, Y. (2019). TinyTeX: A lightweight, cross-platform, and\neasy-to-maintain LaTeX distribution based on TeX live. TUGboat,\n40(1), 30–32. https://tug.org/TUGboat/Contents/contents40-1.html\n\n\nXie, Y. (2023). Tinytex: Helper functions to install and maintain\nTeX live, and compile LaTeX documents. https://github.com/rstudio/tinytex",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html",
    "href": "appendices/00-aufgaben.html",
    "title": "Anhang A — Aufgaben",
    "section": "",
    "text": "A.1 Einführung in R und RStudio\nDiese Übungen finden sich auch in Kapitel 1.",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#einführung-in-r-und-rstudio",
    "href": "appendices/00-aufgaben.html#einführung-in-r-und-rstudio",
    "title": "Anhang A — Aufgaben",
    "section": "",
    "text": "A.1.1 Neue R-Skript\n\nÖffnen Sie ein neues R-Skript (File &gt; New File &gt; R Script)\n\nwenn sich oben links ein neues Fenster öffnet: “Datei &gt; Speichern unter…”.\n\nspeichern Sie es in Ihrem ‘notizen’ Ordner\n\nschreiben Sie oben in das Skript: # Angewandte Datenverarbeitung und Visualisierung - Woche 1 (17.04.2023)\n\n\n\n\nA.1.2 Paket-Installation\n\nInstallieren Sie das here-Paket (in der Konsole).\nFühren Sie die Funktion here() (in Ihre R-Skript mit Strg+/Cmd+Eingabe). Was geschieht in der Konsole?\n\n\n\nA.1.3 Rechnen in R\n\nVersuchen Sie, die folgenden Berechnungen in der Konsole auszuführen:\n\n\n# Addition\n16+32\n\n[1] 48\n\n\n\n# Multiplikation\n16*32\n\n[1] 512\n\n\n\n# Subtraktion\n16-32\n\n[1] -16\n\n\n\n# Division\n16/32\n\n[1] 0.5\n\n\n\nSchreiben Sie diese Berechnungen in Ihr Skript, und drücken Sie Cmd/Strg-Eingabe, um sie auszuführen. Was passiert?\n\n\n\nA.1.4 Rechnen mit Objekte und Funktionen\n\nSpeichern Sie die Werte 16 und 32 als Objekte namens x bzw. y.\nVersuchen Sie, die Funktion mean() mit Ihren gespeicherten Variablen (x und y) als “verkettete” Argumente auszuführen (d.h., mit c()).\nMachen Sie dasselbe mit der Funktion sum(). Was passiert, wenn Sie c() nicht verwenden?\n\n\n\nA.1.5 Vektoren\n\nErstelle einen Vektor namens vec1, der die Werte 12, 183, 56, 25 und 18 enthält\nErstellen Sie einen Vektor namens vec2, der die Werte 8, 5, 1, 6 und 8 enthält\nCreate a vector called vec3 that contains the values 28, 54, 10, 13, 2, and 81\nFinde die Summe von vec1.\nFinde die Summe von vec1 plus vec2. Wie unterscheidet sich das Ergebnis von dem, das Sie für vec1 allein erhalten haben?\nWas passiert, wenn du versuchst, die Summe von vec1 und vec3 zu finden?",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_data_viz1",
    "href": "appendices/00-aufgaben.html#sec-app_data_viz1",
    "title": "Anhang A — Aufgaben",
    "section": "A.2 Datenvisualierung 1",
    "text": "A.2 Datenvisualierung 1\nDiese Übungen finden sich auch in Kapitel 2.\n\nA.2.1 Kombination von Plots mit Patchwork\n\nReproduzieren Sie unser Histogramm als Dichte-Diagramm, indem Sie geom_histogram() durch geom_density() ersetzen.\n\nWas zeigt diese Art der Darstellung?\n\nErstellen Sie ein Balkendiagramm, das die Anzahl der Beobachtungen pro Wortklasse zeigt (Hinweis: Sie benötigen die Variable Class aus unserem Datensatz).\nDrucken Sie Ihren Dichteplot und Ihren Klassen-Balkenplot übereinander mit Hilfe des patchwork Pakets\n\n\n\nA.2.2 Reproduzieren eines Plots\n\nReproduzieren Sie die folgenden Diagramme so genau wie möglich (Hinweis: Sie benötigen das Argument position = \"dodge\"):\n\n\n\n\n\n\n\n\n\nAbbildung A.1: zu reproduzierende Abbildung",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_quarto",
    "href": "appendices/00-aufgaben.html#sec-app_quarto",
    "title": "Anhang A — Aufgaben",
    "section": "A.3 Quarto",
    "text": "A.3 Quarto\nDiese Übungen finden sich auch in Kapitel 3.\n\nA.3.1 Schreiben und Formatieren eines Quarto-Dokuments\n\nFühren den folgenden Code in der Konsole aus: RStudio.Version()$version\n\nwenn die ausgegebene Version 2022.07 oder höher ist, können Sie Quarto benutzen\nwenn nicht, aktualisieren Sie RStudio: Help &gt; Check for updates\n\nErstellen Sie in Ihrem R-Projekt-Ordner, in dem ihr Ihre Kursunterlagen/Notizen aufbewahren, einen neuen Ordner für Woche 3\nFile &gt; New Document &gt; Quarto Document\n\nGeben Sie ihm einen Titel wie “Quarto - Woche 3”\nDeaktivieren Sie die Option “open with Visual Editor”.\n\nSchauen das neue Skript an, um mehr über Quarto zu erfahren.\nKlicken Sie auf die Schaltfläche “Render” am oberen Rand des Dokuments\n\nSpeichern Sie das Dokument in dem Ordner für Woche 3, den Sie gerade erstellt haben.\nWas geschiehen? Vergleichen die Ausgabe mit dem Quellcode des Dokuments.\n\nGehen Sie zurück zu Ihrem neuen Ordner 03-quarto\n\nWas hat sich geändert?\n\n\nin der YAML…\n\nÄndern Sie den Titel, wenn Sie das tun möchten.\nRaten Sie, wie man einen “Untertitel” (EN: subtitle) hinzufügen könnte (Hinweis: es ist ähnlich wie beim Hinzufügen eines title)\nFügen Sie einen Autor hinzu, Autor: \"vorname nachname\" (siehe Beispiel unten)\nFüge ein Inhaltsverzeichnis hinzu (EN: Table of Contents, toc), indem du format so änderst, dass es wie folgt aussieht:\n\n\n---\ntitle: \"Quarto - Woche 3\"\nauthor: \"Vorname Nachname\"\nformat:\n  html:\n    toc: true\n---\n\n\nRendern nun das Dokument. Sehen Sie Ihre Änderungen?\nFügen Sie Ihrem Dokument einige Überschriften und Texte hinzu, die das Format und die Struktur von Quarto-Dokumenten beschreiben. Fügen Sie beispielsweise eine Überschrift mit dem Titel “YAML” ein, die kurz beschreibt, wie YAML formatiert ist.\nFügen Ihrem .qmd Dokumententext eine Textformatierung hinzu.\nFügen eine Aufzählungsliste hinzu\nFügen eine nummerierte Liste hinzu\nRendern Sie das Dokument. Hat es geklappt?\n\n\n\nA.3.2 Kodierung in einem Quarto-Dokument\n\nA.3.2.1 Code chunks\n\nFügen Sie einen Code Chunk zu deiner .qmd Datei hinzu\n\nFügen Sie einige mathematische Operationen ein (Addition, Subtraktion, etc)\nFügen Sie informative Anmerkungen zu Ihrem Code hinzu (z.B. ## Addition)\n\nFügen Sie einen Text unter deinem Code-Chunk hinzu, der beschreibt, was der obige Code erreicht hat.\nRendern Sie das Dokument. Hat es geklappt?\n\n\n\nA.3.2.2 Concatenate\nErinnern Sie sich, dass wir letzte Woche die Funktion c() (EN: concatenate) gesehen haben, die mehrere Werte kombiniert (z.B. mean(c(3,4,25)) ergibt den Mittelwert von 3,4 und 25)\n\nIn einem Code-Stück: Erstellen sie ein Objekt, das eine Liste von Zahlen enthält (z.B. Objektname &lt;- c(...))\nBerechnen Sie den Mittelwert dieser Zahlen, indem Sie nur den Objektnamen verwendt.\nSpeichern Sie den Mittelwert dieser Zahlen als ein Objekt\nRendern Sie das Dokument und seht sich den Abschnitt mit Ihrem Code-Chunk an.\n\nÄndern Sie nun im Quellcode die Chunk-Einstellungen auf echo: false und rendern das Dokument. Was ändert sich?\nSetzen Sie nun echo: true, aber eval: false. Rendern das Dokument. Was ändert sich?\n\n\n\n\n\nA.3.3 Plots in Quarto\n\nEinen neuen Codeabschnitt erstellen und das Balkendiagramm von letzter Woche erzeugen, aber als Objekt speichern\n\nstellen Sie sicher, dass Sie alle erforderlichen Pakete oder Datensätze laden\n\nIn einem separaten Codechunk nur den Objektnamen dieses Diagramms angeben\nRendern Sie das Dokument, um zu sehen, wo die Abbildung gedruckt wurde.\n\n\n\nA.3.4 Ausgabeformate\n\nErsetzen Sie html in der YAML durch revealjs. Rendert das Dokument.\n\nSchauen Sie den Ordner für die Notizen dieser Woche an. Welche Dateien seht?\n\nSetzen Sie nun format auf pdf. Rendert das Dokument.\n\nLäuft es?\nVersuchen Sie, pdf durch den Buchstaben l zu ersetzen. R schlägt eine Vervollständigung vor, welche ist es? Wähle sie aus und rendere das Dokument.\n\nSetzen Sie das Format wieder auf html. Rendert das Dokument.\nGehen Sie zurück zu Ihrem Ordner mit den Notizen dieser Woche. Welche Dateien seht?\n\nIst die Ausgabe von revealjs dort?\n\nFügen Sie eine “Session Info” Abschnitt am Ende des Dokuments hin.",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_wrangling1",
    "href": "appendices/00-aufgaben.html#sec-app_wrangling1",
    "title": "Anhang A — Aufgaben",
    "section": "A.4 Data Wrangling 1: Transformation",
    "text": "A.4 Data Wrangling 1: Transformation\nDiese Übungen finden sich auch in Kapitel 4. Befolgen Sie die Einrichtung aus diesem Kapitel, um diese Übungen zu bearbeiten Kapitel 4.1.\n\nA.4.1 Pipes und Zeilen\n\nin einer einzigen Pipeline df_lexdec für Zeilen drucken, die jede der folgenden Bedingungen erfüllen:\n\n\ndie Reaktionszeiten (RT) waren größer als 500ms und kleiner als 550ms\naus den Wörtern (Word) pear, elephant oder tortoise stammen\nund ordnen Sie sie in der Reihenfolge der Reaktionszeiten (RT) (kleinste bis größte)\n\n\nSortiere (arrange()) df_lexdec in absteigender Reihenfolge (desc()), um die Versuche mit den längsten Reaktionszeiten zu finden.\n\n\n\nA.4.2 Spalten\n\nSpeichern Sie in einer einzigen Pipeline ein neues Objekt namens df_rz, das df_lexdec enthält, und dann (|&gt;):\n\nErstellen Sie nochmal eine neue Variable (mit mutate()) namens rz_s (siehe ex. 4.4: RT durch 1000 dividieren), und dann (|&gt;)\nSelektieren (mit select()) Sie die Variablen Subject, NativeLanguage, Word, rz_s, Length, und Frequency, und dann (|&gt;)\nErstelle eine neue Variable rz_s_laenge (mit mutate()), die rz_s geteilt durch Length ist, und dann (|&gt;)\n\nund wird vor Length gesetzt (mit relocate()), und dann (|&gt;)\n\nBenennen (mit rename()`) Sie diese Variablen in Englisch um, so dass sie in Deutsch (und mit Kleinbuchstaben) sind\n\n\n\nDie ersten 6 Zeilen von df_rz ausgeben (Tipp: head() verwenden).",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_dataviz2",
    "href": "appendices/00-aufgaben.html#sec-app_dataviz2",
    "title": "Anhang A — Aufgaben",
    "section": "A.5 Datavisualisierung 2: Beziehungen",
    "text": "A.5 Datavisualisierung 2: Beziehungen\nDiese Übungen finden sich auch in Kapitel 5. Befolgen Sie die Einrichtung aus diesem Kapitel, um diese Übungen zu bearbeiten Kapitel 5.1.\n\nA.5.1 Visualisierung von Beziehungen\n\n\nZeichnen Sie abweichende Balkenplots von AgeSubject (x-Achse) nach CV (Facetten).\nÄndern Sie Ihre Code-Chunk-Optionen für den letzten Plot so, dass der Code, aber nicht der Plot, in der Ausgabe gedruckt wird.\n\n\n\nFiltern Sie die Daten, um nur ältere Teilnehmer einzuschließen, und stellen Sie RTlexdec (x-Achse) durch RTnaming (y-Achse) dar. Übertragen Sie CV auf Farbe (colour) und Form (shape). Fügen Sie geeignete Beschriftungen hinzu.\n\nÄndern Sie die Code-Chunk-Optionen für den letzten Plot so, dass der Plot, aber nicht der Code, in der Ausgabe gedruckt wird.\n\n\n\n\nA.5.2 ggsave()\n\nSpeichern Sie den letzten Plot lokal und stellen Sie den Code Chunk so ein, dass er beim Rendern nicht ausgeführt wird.",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_dateneinlesung",
    "href": "appendices/00-aufgaben.html#sec-app_dateneinlesung",
    "title": "Anhang A — Aufgaben",
    "section": "A.6 Dateneinlesung",
    "text": "A.6 Dateneinlesung\nDiese Übungen finden sich auch in Kapitel 6 Befolgen Sie die Einrichtung aus diesem Kapitel, um diese Übungen zu bearbeiten Kapitel 6.1.\nNun wollen wir üben, das Paket readr zu benutzen und mit unseren Daten zu arbeiten.\n\nreadr Funktionen\n\nWelche Funktion würdest du benutzen, um eine Datei zu lesen, in der die Felder mit “|” getrennt sind?\nWelche Argumente haben read_csv() und read_tsv() gemeinsam?\nWelche Funktion(en) könnten Sie verwenden, um einen Datensatz mit einem Semikolon (;) als Trennzeichen einzulesen?\n\n\n\nData wrangling\nLaden Sie die Datei groesse_geburtstag.csv erneut. Benutzen Sie Pipes, um auch die Funktion clean_names zu benutzen, und um die folgenden Änderungen im Objekt df_groesse vorzunehmen.\n\nUmwandlung der Variablen l1 in einen Faktor.\nUmbenennen von\n\n\ngrosse in groesse\nwas_fur_ein_haustier in haustierart\n\n\n\nPlots\n\nErstelle ein Streudiagramm mit unserem df_groesse-Datensatz, das die Beziehung zwischen unserem Geburtsmonat und unseren Größe visualisiert (es macht keinen Sinn, dies zu vergleichen, aber es ist nur eine Übung). Suchen Sie Ihren Geburtstag in der Grafik. Stellen Sie die Farbe und die Form so ein, dass sie “L1” entsprechen. Fügen Sie einen Titel für die Grafik hinzu.\n\n\nEin Balkendiagramm erstellen, das die Häufigkeit der verschiedenen Haustierarten zeigt. Auf der x-Achse wollen wir haustierart. Um die Visualisierung zu erleichtern, fügen Sie haustierart auch als fill in die Ästhetik ein. Geben Sie geeignete Diagramm- und Achsentitel mit lab(...) an. What is the most frequent pet type?",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_desc_stats",
    "href": "appendices/00-aufgaben.html#sec-app_desc_stats",
    "title": "Anhang A — Aufgaben",
    "section": "A.7 Deskriptive Statistik",
    "text": "A.7 Deskriptive Statistik\nDiese Übungen begleiten Kapitel 7. Um diese Aufgaben zu erledigen, müssen Sie die Pakete tidyverse, janitor und here laden, sowie den Datensatz languageR_english.csv, wie es in Kapitel 7.1.\n\nA.7.1 Standardabweichung\n\nBerechnen Sie die Standardabweichung der Werte 152, 19, 1398, 67, 2111, ohne die Funktion sd() zu benutzen.\n\nzeige deine Arbeit. Die folgende R-Syntax könnte nützlich sein (je nachdem, wie Sie es machen wollen):\n\nc()\nmean()\nx^2 berechnet das Quadrat eines Wertes (hier, x)\nsqrt() berechnet die Quadratwurzel\nlength() liefert die Anzahl der Beobachtungen in einem Vektor\n\n\n\n\nBenutze die Funktion sd(), um die Standardabweichung der obigen Werte zu drucken. Haben Sie es richtig gemacht?\n\n\n\nA.7.2 summary()\n\nBenutze summarise, um den Mittelwert, die Standardabweichung und die Anzahl der Beobachtungen für rt_naming im df_eng Datenrahmen zu drucken.\n\nHinweis: Müssen Sie fehlende Werte (NA) entfernen?\n\n\n\nMachen Sie dasselbe, aber fügen Sie das Argument .by() hinzu, um die mittlere Reaktionszeit der Benennungsaufgabe (rt_naming) pro word_category zu ermitteln\n\nOrdnen Sie die Ausgabe nach der mittleren Antwortzeit für die Namensgebung an.",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_data_viz3",
    "href": "appendices/00-aufgaben.html#sec-app_data_viz3",
    "title": "Anhang A — Aufgaben",
    "section": "A.8 Datenvisualisierung 3",
    "text": "A.8 Datenvisualisierung 3\nDiese Übungen begleiten Kapitel 8. Um diese Aufgaben zu erledigen, müssen Sie die Pakete tidyverse, janitor und here laden, sowie den Datensatz languageR_english.csv, wie es in Kapitel 8.1.\n\nA.8.1 Boxplot mit Facette\n\nErzeugen Sie einen Plot namens fig_boxplot, der ein Boxplot der df_eng Daten ist, mit:\n\nage_subject auf der x-Achse\nrt_naming auf der y-Achse\nage_subject als colour oder fill (wähle eine, es gibt keine falsche Wahl)\nword_category in zwei Facetten mit facet_wrap() aufgetragen\ndie von Ihnen gewählte theme_-Einstellung (z.B. theme_bw(); für weitere Optionen siehe hier)\n\n\n\n\nA.8.2 Errorbar plot\n\nVersuchen Sie, Abbildung A.2 zu reproduzieren. Hinweis: Sie werden die Variable rt_naming aus df_eng verwenden.\n\n\n\n\n\n\n\n\n\nAbbildung A.2: Plot to be reproduced\n\n\n\n\n\n\n\nA.8.3 Patchwork\n\nVerwenden Sie das Paket patchwork, um Ihren Boxplot und Ihre Fehlerbalkenplots nebeneinander darzustellen. Es sollte ungefähr so aussehen wie Abbildung A.3. Hinweis: Wenn Sie die “tag-level” (“A” und “B”) zu den Plots hinzufügen möchten, müssen Sie + plot_annotation(tag_level = \"A\") aus patchwork hinzufügen.\n\n\n\n\n\n\n\n\n\nAbbildung A.3: Combined plots with patchwork",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_wrangling2",
    "href": "appendices/00-aufgaben.html#sec-app_wrangling2",
    "title": "Anhang A — Aufgaben",
    "section": "A.9 Data Wrangling 2",
    "text": "A.9 Data Wrangling 2\nDiese Übungen begleiten Kapitel 9. Um diese Aufgaben zu erledigen, müssen Sie die Pakete tidyverse, janitor und here laden, sowie den Datensatz languageR_english.csv (df_eng), wie es in Kapitel 9.1.\n\nA.9.1 pivot_longer() |&gt; summarise()\n\nErstellen Sie df_eng_long (wie in Kapitel 9.5.1). Verwenden Sie dann die Funktion summarise(), um die folgenden zusammenfassenden Statistiken zu erstellen:\n\n\n\n# A tibble: 2 × 3\n  response   mean    sd\n  &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 rt_lexdec  708.  115.\n2 rt_naming  566.  101.\n\n\nHinweis: Müssen Sie NA entfernen (wir haben im letzten Kapital gesehen, wie man das macht)?\n\n\nA.9.2 pivot_wider()\n\nVerwenden Sie pivot_wider, um mit rt_naming neue Variablen zu erstellen: naming_old und naming_young, die die Reaktionszeiten beim Benennen für alte bzw. junge Teilnehmer enthalten. Hinweis: Sie müssen rt_lexdec entfernen. Speichern Sie den Datenrahmen als df_eng_wider als Objekt. Der resultierende Datenrahmen sollte 2284 Beobachtungen und 6 Variablen enthalten.\n\n\nErstellen Sie Abbildung A.4 mit df_eng_wider.\n\n\n\n\n\n\n\n\n\nAbbildung A.4: Scatterplot of naming task reaction times per word for old versus young participants\n\n\n\n\n\n\nWarum brauchen wir unseren df_eng_wide-Datensatz, um Abbildung A.4 zu erstellen? Mit anderen Worten, warum ist df_eng_wide die geeignete Struktur, aber nicht df_eng_long für ein solches Streudiagramm?",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_baseR",
    "href": "appendices/00-aufgaben.html#sec-app_baseR",
    "title": "Anhang A — Aufgaben",
    "section": "A.10 base R",
    "text": "A.10 base R\nDiese Übungen begleiten Kapitel 10. Sie brauchen keine Pakete zu laden, da diese Übungen die Verwendung von Basis-R voraussetzen. Sie sollten jedoch tidyverse laden, wenn Sie den Beispielcode ausführen wollen.\n\nA.10.1 tidyverse zur base R\nKonvertieren Sie den folgenden tidyverse-Code in Base R. Wir werden wieder den Datensatz languageR_english.csv verwenden.\n\nEinlesung\n\ndf_eng &lt;- \n  readr::read_csv(here::here(\"daten\", \"languageR_english.csv\"))\n\n\n\nAuswahl der Spalten\n\ndf_eng |&gt; \n  select(Word, WrittenFrequency)\n\n\n\n# A tibble: 10 × 2\n   Word   WrittenFrequency\n   &lt;chr&gt;             &lt;dbl&gt;\n 1 doe                3.91\n 2 whore              4.52\n 3 stress             6.51\n 4 pork               5.02\n 5 plug               4.89\n 6 prop               4.77\n 7 dawn               6.38\n 8 dog                7.16\n 9 arc                4.89\n10 skirt              5.93\n\n\n\n\nZeilen filtern\n\ndf_eng |&gt; \n  filter(WrittenFrequency &gt; 5.6)\n\n\n\n# A tibble: 10 × 7\n   AgeSubject Word   LengthInLetters WrittenFrequency WordCategory RTlexdec\n   &lt;chr&gt;      &lt;chr&gt;            &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 young      stress               6             6.51 N                547.\n 2 young      dawn                 4             6.38 N                584.\n 3 young      dog                  3             7.16 N                527.\n 4 young      skirt                5             5.93 N                536.\n 5 young      are                  3            11.3  N                611.\n 6 young      pipe                 4             6.00 N                563.\n 7 young      guard                5             6.59 N                559.\n 8 young      slope                5             5.80 N                633.\n 9 young      pile                 4             6.16 N                595.\n10 young      tide                 4             6.08 N                598.\n# ℹ 1 more variable: RTnaming &lt;dbl&gt;\n\n\n\n\nAuswahl von Zeilen und Spalten\n\ndf_eng |&gt; \n  filter(WrittenFrequency &gt; 5.6 & AgeSubject == \"old\") |&gt; \n  select(AgeSubject, Word, WrittenFrequency) \n\n\n\n# A tibble: 10 × 3\n   AgeSubject Word   WrittenFrequency\n   &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt;\n 1 old        stress             6.51\n 2 old        dawn               6.38\n 3 old        dog                7.16\n 4 old        skirt              5.93\n 5 old        are               11.3 \n 6 old        pipe               6.00\n 7 old        guard              6.59\n 8 old        slope              5.80\n 9 old        pile               6.16\n10 old        tide               6.08\n\n\n\n\nStreudiagramm\n\ndf_eng |&gt; \n  ggplot() +\n  aes(x = WrittenFrequency, y = RTlexdec) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\nTidyverse versus Base R\nWie ist Ihr Eindruck von Base R im Vergleich zu Tidyverse? Würden Sie, basierend auf dem, was Sie gesehen haben, das eine dem anderen vorziehen, oder würden Sie das eine nur in bestimmten Fällen vorziehen? Hier gibt es keine richtige Antwort.",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  },
  {
    "objectID": "appendices/00-aufgaben.html#sec-app_dataviz4",
    "href": "appendices/00-aufgaben.html#sec-app_dataviz4",
    "title": "Anhang A — Aufgaben",
    "section": "A.11 Datenvisualisierung 4",
    "text": "A.11 Datenvisualisierung 4\nDiese Übungen begleiten Kapitel 11. Um diese Aufgaben zu erledigen, müssen Sie die Pakete tidyverse, janitor, here, und patchwork laden, sowie den Datensatz languageR_english.csv (df_eng), wie es in Kapitel 11.1.\n\nA.11.1 Mehrteilige Darstellung\n\nErzeugen von Abbildung 11.9 und Abbildung 11.5 für rt_naming (anstelle von rt_lexdec). Drucken der Plots nebeneinander mit patchwork.\n\n\n\nA.11.2 Beschriftungen\n\nBenutzen Sie labs(), um Beschriftungen für den Titel, die x- und y-Achse und für die von Ihnen verwendete Ästhetik (Form, Farbe, etc.) hinzuzufügen, die in einer Legende resultieren. Dies sollte damit enden, dass der Titel der Legende auch einen eigenen Namen erhält.\n\n\n\nA.11.3 Anpassungen\n\nFügen Sie den beiden Diagrammen Anpassungen hinzu, indem Sie ein Standardthema wählen, gefolgt von theme() mit Anpassungen für die Achsentitel, den Legendentitel und den Diagrammtitel. Sie können face, size, colour, family (d.h. Schriftart) ändern. Sie können ?theme in der Konsole eingeben oder googeln, um einige Ideen zu bekommen. Wenn Sie sich nicht kreativ fühlen, versuchen Sie einfach, eine der Anpassungen zu replizieren, die Sie in Abbildung 11.10 sehen",
    "crumbs": [
      "Anhang",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Aufgaben</span>"
    ]
  }
]