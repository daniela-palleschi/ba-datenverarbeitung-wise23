---
title: "Base R"
subtitle: "Ein Vergleich mit tidyverse"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 13 - Base R" 
date: "01/24/2024"
date-format: "ddd [den] DD.MM.YYYY"
date-modified: last-modified
shift-heading-level-by: +1
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, ## evaluate chunks
                      echo = T, ## 'print code chunk?'
                      message = F, ## 'print messages (e.g., warnings)?'
                      error = T, ## continueeven when error encountered
                      warning = F) ## don't print warnings
```

# Lesungen {.unnumbered .unlisted}

Die **Pflichtlekt√ºre** zur Vorbereitung auf dieses Thema ist [Kapital 27 (A field guide to Base R)](https://r4ds.hadley.nz/base-r) in @wickham_r_2023.

# Lernziele {.unnumbered .unlisted}

In diesem Kapitel werden wir...

- lernen, was Base R ist
- Base R und Tidyverse vergleichen
- die Base-R-√Ñquivalente der Tidyverse-Verben kennenlernen

# Base R

Die Basissoftware, die die Programmiersprache R enth√§lt, hei√üt base-R oder natives R. Dieses Basissystem enth√§lt das Paket `base`, das zum Ausf√ºhren von R erforderlich ist. √Ñhnlich wie tidyverse enth√§lt das Basissystem auch einige Pakete wie `utils` und `stats` (unter anderem). Um zu sehen, welche Pakete enthalten sind, gehen Sie einfach auf die Registerkarte `Pakete` unten rechts in Ihrer RStudio-Sitzung. Unter der Annahme, dass Sie mit einer sauberen Arbeitsumgebung beginnen, sollten nur die Pakete geladen werden, die zum R-Basissystem geh√∂ren. Alle diese Pakete werden bei der Installation von R installiert. Mit dieser Sammlung von Paketen k√∂nnen die meisten (wenn nicht alle) der gleichen Ziele wie mit tidyverse erreicht werden, auch wenn beide f√ºr bestimmte Ziele vorzuziehen oder besser zu rationalisieren sind.

Wie wir bereits gelernt haben, ist das [Tidyverse](https://www.tidyverse.org/) [@tidyverse-package] eine Familie von R-Paketen, die das Bereinigen und Verwalten von Daten erleichtern sollen. Der Hauptentwickler von Tidyverse ist Hadley Wickham, der Chefwissenschaftler von Posit (ehemals RStudio), dem Softwareunternehmen, das die integrierte Entwicklungsumgebung (IDE) RStudio entwickelt hat. Alle Pakete in Tidyverse "teilen eine High-Level-Design-Philosophie und Low-Level-Grammatik und Datenstrukturen, so dass das Erlernen eines Pakets es einfacher macht, das n√§chste zu erlernen" [@wickham_welcome_2019]. Allerdings wurde das Tidyverse in der Programmiersprache R geschrieben, sodass die beiden nicht vollst√§ndig voneinander getrennt sind. 

Sowohl Base R als auch tidyverse sind Open-Source-Sprachen, die f√ºr die Datenwissenschaft geschrieben wurden. Ein Hauptziel von Base R ist die Stabilit√§t, d. h. der Code sollte √ºber viele Jahre hinweg stabil sein. Tidyverse hingegen f√ºgt st√§ndig Funktionen und Argumente hinzu, aktualisiert sie und √§ndert sie mit neuen Paketversionen im Hinblick auf die Optimierung. Dies bedeutet, dass Tidyverse-Code anf√§llig f√ºr "Br√ºche" ist: Tidyverse-Code, der heute l√§uft, l√§uft vielleicht in ein paar Jahren nicht mehr, wenn einige Funktionen oder Argumente "veraltet" sind. Deshalb ist es so wichtig, dass Sie immer Ihre `sessionInfo()` mit einem Bericht mitschicken, sie dokumentiert, welche Pakete und deren Versionen Sie verwendet haben.

In der Debatte zwischen Base R und Tidyverse gibt es in der Regel drei Lager: die starken Bef√ºrworter von Base R, die starken Bef√ºrworter von Tidyverse und die Agnostiker. In Bezug auf den R-Unterricht gibt es mehrere Arbeiten, in denen die potenziellen Vorteile des Unterrichts von Base R oder des Tidyverse bzw. einer Kombination aus beidem untersucht werden. Einige argumentieren, dass das Lehren der Tidyverse f√ºr Sch√ºler intuitiver ist, w√§hrend andere behaupten, dass Base R der "einzige" Weg ist, um echte R-Kenntnisse zu erlangen. Base R ist z.B. einfacher, wenn es darum geht, eine einzelne Variable zu extrahieren, aber selbst unter standhaften Base R-Nutzern wird das Paket `ggplot2` oft bevorzugt, um Diagramme zu erstellen. Unten sehen wir einen Tweet von Prof. Christopher Zorn (Penn State), der vorschl√§gt, dass die Kenntnis des "tidyverse" nicht bedeutet, dass man R kennt, mit einer Antwort von Prof. Bodo Winter (University of Birmingham) zur Unterst√ºtzung des tidyverse. Viele andere Antworten wiesen auf die verschiedenen Vorteile des Tidyverse hin, von der Lehre von R bis zur Arbeit in der Industrie. Wichtig (und f√ºr Sie als Linguistikstudenten relevant) ist, dass Bodo Winter der Autor von '*Statistics for Linguists: An Introduction Using R*' [@winter_statistics_2019], das ebenfalls tidyverse verwendet. Sein Buch sowie die Tutorien, die er als Doktorand geschrieben hat [@winter_linear_2013; @winter_very_2014], sind in einer verst√§ndlichen Sprache verfasst, die sie f√ºr Studierende zug√§nglich macht. Es ist also kein Wunder, dass er ein Bef√ºrworter von tidyverse ist, das auch f√ºr Nicht-Programmierer zug√§nglich sein soll.

::: {.content-visible when-format="html"}

<center>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">What a thing to say when modern R is pretty much synonymous with the tidyverse for many in the community!<br><br>I was a Base R masochist once too.. but there&#39;s no need for statements like this when the tidyverse has helped so many of us be more productive and write more readable code.</p>&mdash; Bodo Winter (@BodoWinter) <a href="https://twitter.com/BodoWinter/status/1612882152483586049?ref_src=twsrc%5Etfw">January 10, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

:::

::: {.content-visible when-format="pdf"}
```{r}
#| echo: false
#| label: fig-twitter-white
#| fig-cap: A tweet exchange about base R versus the tidyverse (original tweet above, with reply below). [Click here to view tweet.](https://x.com/BodoWinter/status/1612882152483586049?s=20)
#| out-width: "70%"
knitr::include_graphics(
  here::here("media", "twitter_baser_tidyverse_white.png")
)  
```
:::

```{r}
#| eval: false
#| echo: false
#| label: fig-twitter
#| fig-cap: A tweet (A) with a reply in support of the tidyverse, with two other replies pointing out the benefits of the tidyverse (B) and its use in industry (C)
#| fig-height: 8

library(ggpubr)
library(grid)
library(png)


tweet_bodo <- readPNG(
  here::here("media", "twitter_baser_tidyverse.png")
)  

tweet_cleaner <- readPNG(
  here::here("media", "twitter_cleaner.png")
)

tweet_industry <- readPNG(
  here::here("media", "twitter_industry.png")
)

ggarrange(rasterGrob(tweet_bodo, width = .65),
          rasterGrob(tweet_cleaner, width = .65),
          rasterGrob(tweet_industry, width = .65), 
          ncol = 1,
          labels = c("A","B","C"),
          heights = c(0.5, 1/4,1/4))
```

Offensichtlich halte ich das Erlernen des Tidyversums f√ºr wichtig, denn ich habe mich entschieden, diesen Kurs auf Tidyversum-Pakete zu st√ºtzen. Das liegt daran, dass das Tidyverse den Menschen in den Mittelpunkt stellt, und dieser Kurs ist nicht f√ºr Programmierer oder Informatiker gedacht. Wie wir im obigen Tweet sehen, stimmt nicht jeder mit mir √ºberein, aber es gibt auch viele Leute, die das tun.


## Warum beides lernen?

Ich pers√∂nlich lernte Base R Jahre bevor ich Tidyverse lernte. Ich habe nie zur√ºckgeblickt, und mein Code ist seit der Einf√ºhrung von tidyverse und den dahinter stehenden Philosophien viel sauberer und besser lesbar geworden. Trotzdem gibt es immer noch bestimmte Aufgaben, f√ºr die ich Base R verwende, z. B. f√ºr einen schnellen Blick auf eine einzelne Variable oder wenn ich mit Listen oder verschachtelten Datenstrukturen arbeite (die wir in diesem Kurs nicht behandeln werden). 

Auch wenn ich pers√∂nlich mit √§hnlichen Ansichten wie im urspr√ºnglichen Tweet oben nicht einverstanden bin (wie viele andere auch), ist die Kenntnis von Base R eine wichtige F√§higkeit, um Ihre R-Horizonte zu erweitern. Sie werden mit Sicherheit auf Base R-Code sto√üen, wenn Sie nach L√∂sungen f√ºr Probleme suchen oder sich den Code von anderen ansehen. Unabh√§ngig davon, ob jemand eine starke Vorliebe f√ºr Base R oder Tidyverse hat, ist es eine gute Idee, mit beiden Optionen vertraut zu sein, um das Beste aus der R-Community herauszuholen. Es ist wichtig zu verstehen, dass es so etwas wie perfekten Code nicht gibt, und dass es fast immer mehrere M√∂glichkeiten gibt, das gleiche Ziel zu erreichen, sogar innerhalb von Base R oder Tidyverse. Was wir heute lernen werden, ist im Wesentlichen, wie wir den Tidyverse-Code, mit dem wir vertraut sind, in Base R √ºbersetzen k√∂nnen.

# Einrichten

Wir werden heute ziemlich minimalistisch arbeiten. Alles was wir brauchen sind die Pakete `tidyverse` und `here`.

```{r}
pacman::p_load(
  tidyverse,
  here
)
```

```{r}
#| echo: false
pacman::p_load(janitor,
               patchwork)
```


## Einlesen

Wir werden den Datensatz `languageR_english.csv` einlesen, der sich bereits in Ihrem `daten`-Ordner befinden sollte. Dieser Datensatz enth√§lt Daten aus einer Benennungs- und lexikalischen Entscheidungsaufgabe in Englisch.

## CSV

Wir haben bereits gesehen, wie man die `read_()` Familie von Funktionen (`read_csv()`, `read_csv2()`, `read_delim()`, etc.) aus dem `readr` Paket aus dem `tidyverse` benutzt.

```{r filename = "tidyverse"}
df_tidy <-
  read_csv(
    here("daten", "languageR_english.csv")
  )
```

Um einen Datensatz mit kommagetrennten Werten (CSV) einzulesen, k√∂nnen wir die Funktion `read.csv()` verwenden, die eine Version der umfassenderen Funktion `read.table()` aus dem Paket `utils` ist. Das `utils`-Paket ist ein Standard-Installationspaket in R, so wie einige Anwendungen bereits installiert sind, wenn man ein neues Telefon kauft.

```{r filename = "Base R"}
df_base <-
  read.csv(
    here("daten", "languageR_english.csv")
  )
```

Das erste, was Ihnen vielleicht auff√§llt, ist, dass wir beim Ausf√ºhren von `read_csv()` eine Meldung erhalten haben, die uns die Anzahl der Zeilen und Spalten in den Daten, das verwendete Trennzeichen (bei `read_csv()` immer ein Komma) und den Datentyp, zu dem unsere Variablen geh√∂ren, mitteilt. Hier haben wir gesehen, dass wir drei Zeichenvariablen (`chr`) und vier numerische Variablen (`dbl` f√ºr "double") haben. Bei der Verwendung von `read.csv()` erhalten wir keine derartige Meldung. Im Allgemeinen ist Tidyverse ein besserer Gespr√§chspartner als Base R. Sie erhalten mehr Meldungen, und die Warn- oder Fehlermeldungen sind anschaulicher.

Ein weiterer Unterschied zwischen diesen beiden Funktionen ist die Art und Weise, wie sie `read` und `csv` trennen: tidyverse verwendet typischerweise `_`, um W√∂rter zu trennen, w√§hrend Base R dazu neigt, eine Mischung aus `.` und `_` zu verwenden. Dies geht auf die Prinzipien von tidyverse zur√ºck, in denen versucht wird, konsistente Konventionen beizubehalten, um sauberen Code und saubere Daten zu f√∂rdern. Dazu geh√∂rt auch die konsequente Verwendung von `_" in Funktions- und Variablennamen.

Schauen wir uns nun die beiden Objekte an, die wir jetzt haben. Wie viele Spalten haben sie?

```{r}
length(df_tidy)
```

```{r}
length(df_base)
```

Beide haben `r length(df_base)` Spalten. Wie lauten die Namen dieser Spalten?

```{r}
names(df_base)
```

```{r}
names(df_tidy)
```

Sie haben auch die gleichen Namen, so weit, so gut. Wie viele Zeilen gibt es in jedem?

```{r}
nrow(df_tidy)
```

```{r}
nrow(df_base)
```

Beide haben `r nrow(df_base)` Zeilen. Die Datenstruktur ist also identisch.

## Andere Begrenzungszeichen

Erinnern Sie sich, dass wir mit dem tidyverse-Paket `readr` `read_delim(delim = "")` verwenden k√∂nnen, um das Trennzeichen explizit zu definieren. Hier verwenden wir `delim = ","`, weil wir immer noch eine kommagetrennte Wertedatei verwenden. 

```{r filename = "tidyverse"}
df_tidy <-
  read_delim(
    here("daten", "languageR_english.csv"),
    delim = ","
  )
```

Wir k√∂nnen dies mit `read.table(sep = "")` aus dem Paket `utils` tun.

```{r filename = "Base R"}
df_base <-read.table(
    here("daten", "languageR_english.csv"),
    sep = ",",
    header = TRUE
  )
```

::: {.callout-tip}

## Begrenzungszeichen und Trennzeichen

Versuchen Sie, das Trennzeichen in den obigen Code-Bl√∂cken durch ein Semikolon (`;`) zu ersetzen. Was √§ndert sich, und warum? √Ñndern Sie es wieder in ein Komma und f√ºhren Sie es erneut aus, bevor Sie fortfahren.

:::

## Datenrahmen versus Tibbles

Daten, die mit tidyverse eingelesen werden, werden als Tibble gespeichert, das als eine aufger√§umtere Version eines Datenrahmens gilt. Wichtig ist, dass die Struktur eines Tibbles und die darin enthaltenen Informationen mit denen eines Datenrahmens identisch sind. Im Folgenden werden wir einige Unterschiede zwischen Tibbles und Datenrahmen sehen. 


# Umgang mit Spalten und Zeilen

Wir sind bereits mit einer Reihe von `dplyr`-Verben vertraut, die zum Manipulieren, Filtern und Extrahieren von Zeilen und Spalten verwendet werden. Jetzt sehen wir uns alternative Wege an, um die gleichen Ergebnisse mit Base R zu erzielen.

## Variablen extrahieren

Wir sind bereits vertraut mit `select()` aus `dplyr`:

```{r filename = "tidyverse"}
#| eval: false
df_tidy |> 
  select(AgeSubject)
```

```{r filename = "tidyverse"}
#| echo: false
df_tidy |> 
  select(AgeSubject) |> 
  head(10)
```

In Base R k√∂nnen wir ein Dollarzeichen (`$`) verwenden, um eine Spalte aus einem Datenrahmen (oder Tibble) zu extrahieren. Dadurch erhalten wir einen Vektor, w√§hrend `dplyr::select()` die Datenrahmen-/Tibble-Attribute der Spalte beibeh√§lt.

```{r filename = "Base R"}
#| eval: false
df_base$AgeSubject
```

```{r filename = "Base R"}
#| echo: false
head(df_base$AgeSubject,18)
```

Alternativ kann man auch `dataframe[row,column]` verwenden, um Zeilen und Spalten zu definieren. Wir k√∂nnen den Namen einer Spalte in Anf√ºhrungszeichen verwenden oder den Index der Spalte angeben, wobei 1 f√ºr die erste Spalte steht, 2 f√ºr die zweite Spalte usw. Wir konzentrieren uns zun√§chst auf die Spalten, geben also nicht an, welche Zeile wir wollen, sondern geben alle Zeilen dieser Spalte aus.

```{r filename = "Base R"}
#| eval: false
# using variable name
df_base[,"AgeSubject"]
```

```{r}
#| echo: false
# using variable name
head(df_base[,"AgeSubject"],18)
```

```{r filename = "Base R"}
#| eval: false
# using variable index
df_base[,1]
```

```{r}
#| echo: false
# using variable index
head(df_base[,1],18)
```

Ein Hauptunterschied zwischen der Verwendung von tidyverse und Base R zum Extrahieren einer einzelnen Variablen besteht darin, dass Base R einen Vektor extrahiert, w√§hrend das tidyverse-Verb `select()` die Variable als Tibble beh√§lt. Beachten Sie, dass es auch m√∂glich ist, mehrere Variablen mit der Funktion `select()` auszuw√§hlen. Sie k√∂nnen dies auch mit Base R tun, aber Sie m√ºssen die Funktion `c()` verwenden.

```{r filename = "tidyverse"}
#| eval: false
df_tidy |> 
  select(AgeSubject, RTlexdec)
```

```{r}
#| echo: false
df_tidy |> 
  select(AgeSubject, RTlexdec) |> 
  head(10)
```

```{r filename = "Base R"}
#| eval: false
# using variable name
df_base[,c("AgeSubject", "RTlexdec")]
```

```{r}
#| echo: false
# using variable name
df_base[,c("AgeSubject", "RTlexdec")] |> 
  head(10)
```


```{r filename = "Base R"}
#| eval: false
# using variable index
df_base[,c(1, 6)]
```

```{r}
#| echo: false
# using variable index
df_base[,c(1, 6)] |>  head(10)
```

### Mischen von Tibbles und Datenrahmen

Die Ausgabe dieser Operationen h√§ngt nicht nur davon ab, ob Sie eine Tidyverse- oder eine R-Basisfunktion verwenden. Es macht auch einen Unterschied, ob die Daten ein Datenrahmen oder ein Tibble sind. Versuchen wir, die Funktion `select()` von tidyverse auf einen Datenrahmen anzuwenden:

```{r filename = "tidyverse"}
#| eval: false
df_base |> 
  select(AgeSubject)
```

```{r}
#| echo: false
df_tidy |> 
  select(AgeSubject) |> 
  head(10)
```

Base R behandelt Tibbles jedoch genauso wie Datenrahmen und gibt einen Vektor mit allen Werten einer einzelnen Spalte aus.

```{r filename = "Base R"}
#| eval: false
df_tidy$AgeSubject
```

```{r}
#| echo: false
head(df_tidy$AgeSubject, 10)
```

Dies sollte keine Folgen haben, aber es ist wichtig, die innere Struktur Ihrer Daten zu verstehen, damit Sie entsprechend damit arbeiten k√∂nnen.

## Beobachtungen extrahieren/filtern

Wir haben bereits die Funktion `filter()` von `dplyr` gesehen, die Zeilen extrahiert, die logischen Bedingungen entsprechen.

```{r filename = "tidyverse"}
df_tidy |> 
  filter(RTlexdec > 600 & RTnaming < 480)
```

Wir k√∂nnen diese bedingten Anweisungen in `[,]` einf√ºgen, wobei zu beachten ist, dass die Zeilen vor dem Komma und die Spalten nach dem Komma angegeben werden. Wir lassen die Spaltenangabe leer, d. h. wir wollen alle Spalten ausgeben. Wichtig ist, dass wir in den bedingten Anweisungen den Namen des Datenrahmens mit dem Dollarzeichen vor dem Spaltennamen angeben.

```{r filename = "Base R"}
#| eval: false
df_base[df_base$RTlexdec > 600 & df_base$RTnaming < 480,]
```

```{r}
#| echo: false
df_base[df_base$RTlexdec > 600 & df_base$RTnaming < 480,] |> 
  head(10)
```


## Einzelne Datenpunkte ausw√§hlen

Wir k√∂nnen bestimmte Zeilen und bestimmte Spalten auf einmal extrahieren. Wenn wir zum Beispiel die relevanten Zeilen wie oben ausgeben wollen, aber nur die Spalten `AgeSubject` und `RTlexdec`, k√∂nnen wir dies mit `filter()` und `select()` tun (was wir bereits zuvor getan haben).

```{r filename = "tidyverse"}
#| eval: false
df_tidy |> 
  filter(RTlexdec > 600, RTnaming < 480) |> 
  select(AgeSubject, RTlexdec)
```

```{r}
#| echo: false
df_tidy |> 
  filter(RTlexdec > 600, RTnaming < 480) |> 
  select(AgeSubject, RTlexdec) |> 
  head(10)
```

In Base R w√ºrden wir dies einfach in `[,]` einf√ºgen. Dadurch erhalten wir keinen Vektor mehr, sondern die Datenrahmenstruktur bleibt erhalten. Nicht, dass wir auch die Zeilennummern erhalten.

```{r filename = "Base R"}
#| eval: false
df_base[df_base$RTlexdec > 600 & df_base$RTnaming < 480,c("AgeSubject", "RTlexdec")]
```

```{r}
#| echo: false
df_base[df_base$RTlexdec > 600 & df_base$RTnaming < 480,c("AgeSubject", "RTlexdec")] |> 
  head(10)
```

Auch hier k√∂nnen Sie die Spaltennamen durch den Indexwert ersetzen.

```{r filename = "Base R"}
#| eval: false
df_base[df_base$RTlexdec > 600 & df_base$RTnaming < 480,c(1, 6)]
```

```{r}
#| echo: false
df_base[df_base$RTlexdec > 600 & df_base$RTnaming < 480,c(1, 6)] |> 
  head(10)
```

## Neue Variablen erstellen

Wir haben gelernt, wie man mit der Funktion `mutate()`, die ebenfalls aus `dplyr` stammt, neue Variablen erstellt oder bestehende Variablen √§ndert.

```{r filename = "tidyverse"}
df_tidy |> 
  mutate(rt_lexdec_s = RTlexdec/1000)
```

In Base R geschieht dies, indem wir den Namen der neuen Variablen definieren und ihr mit dem Zuweisungsoperator `<-` einen Wert zuweisen.

```{r filename = "Base R"}
df_base$rt_lexdec_s <- df_base$RTlexdec/1000
```

## Zusammenfassen

Als Letztes wollen wir lernen, wie man in Base R zusammenfasst. Das ist nicht einfach, wenn man eine Gruppe hat, deshalb werden wir das nicht behandeln. 

```{r, filename = "tidyverse"}
  df_tidy |> 
  summarise(
    mean_lexdec = mean(RTlexdec),
    sd_lexdec = sd(RTlexdec),
    mean_naming = mean(RTnaming, na.rm = T),
    sd_naming = sd(RTnaming, na.rm = T)
  )
```

In Base R m√ºssen wir neue Objekte erstellen, die den Wert jeder Operation enthalten, und sie mit der Funktion "data.frame()" zu einem Datenrahmen zusammenfassen.

```{r, filename = "Base R"}
data.frame(mean_lexdec = mean(df_base$RTlexdec),
           sd_lexdec = sd(df_base$RTlexdec),
           mean_naming = mean(df_base$RTnaming, na.rm = T),
           sd_naming = sd(df_base$RTnaming, na.rm = T))
```

# Pipes

Lange Zeit waren Pipes ein Feature des Tidyverse, mit der `%>%` Pipe aus dem `magrittr` Paket. Seit 2023 bietet R eine native Pipe `|>`. Sie haben vielleicht schon beide Versionen gesehen (ich tendiere dazu, `|>` zu benutzen). F√ºr unsere Zwecke sind sie austauschbar, aber es gibt wichtige Unterschiede f√ºr komplexere F√§lle, die wir nicht behandeln werden.


```{r filename = "tidyverse"}
df_base$RTlexdec |> 
  mean()
```

```{r filename = "Base R"}
df_base$RTlexdec %>%
  mean()
```

# Plots

`ggplot2` ist auch bei Leuten beliebt, die sonst nicht die tidyverse-Paketfamilie nutzen. Das liegt daran, dass es einige n√ºtzliche Funktionen und ein sauberes Aussehen hat. 

Das Plotten mit Base R kann auch sehr praktisch sein, wenn man einfache Diagramme erstellen will, um einen ersten Blick auf die Daten zu bekommen. Die n√ºtzlichsten Funktionen sind `hist()` und `plot()`, die jeweils Histogramme und Streudiagramme erzeugen. Beachten Sie, dass diese Funktionen mit Vektoren arbeiten, weswegen wir `$` verwenden m√ºssen, um die Spalten aus dem Datenrahmen zu extrahieren.

::: {.content-visible when-format="html"}

```{r, filename = "Base R"}
#| fig-width: 4
#| fig-asp: 1
#| dev: png
#| layout-ncol: 2
#| label: fig-baser
#| fig-cap: Histogram and scatterplot with Base R

# left
hist(df_base$RTlexdec)
# right
plot(df_base$RTlexdec, df_base$RTnaming) 
```
:::

::: {.content-visible when-format="pdf"}
```{r, filename = "Base R histogram"}
#| fig-width: 4
#| fig-asp: 1.1
#| label: fig-baser-hist
#| fig-cap: Histogram with Base R

# histogram
hist(df_base$RTlexdec)
```

```{r, filename = "Base R histogram"}
#| fig-width: 4
#| fig-asp: 1.1
#| label: fig-baser-scatter
#| fig-cap: Scatterplot with Base R

# scatterplot
plot(df_base$RTlexdec, df_base$RTnaming)
```


:::

To achieve the same thing with the tidyverse:

```{r, filename = "tidyverse"}
#| eval: false

# histogram
df_base |> 
  ggplot() +
  aes(x = RTlexdec) +
  geom_histogram()

# scatter plot
  df_base |> 
  ggplot() +
  aes(x = RTlexdec, y = RTnaming) +
  geom_point() 
```

```{r}
#| fig-width: 8
#| fig-asp: .5
#| dev: png
#| label: fig-ggplot
#| fig-cap: Histogram and scatterplot with ggplot2
#| echo: false
# histogram
df_base |> 
  ggplot() +
  aes(x = RTlexdec) +
  geom_histogram() +
# scatter plot
  df_base |> 
  ggplot() +
  aes(x = RTlexdec, y = RTnaming) +
  geom_point() +
  plot_annotation(tag_levels = "A")
```




# Lernziele üèÅ {.unnumbered .unlisted}

In diesem Kapitel werden wir...

- lernen, was Base R ist ‚úÖ
- Base R und Tidyverse vergleichen ‚úÖ
- die Base-R-√Ñquivalente der Tidyverse-Verben kennenlernen ‚úÖ

# Aufgaben

Konvertieren Sie den folgenden tidyverse-Code in Base R. Wir werden wieder den Datensatz "languageR_english.csv" verwenden.

## Read-in

```{r}
df_eng <- 
  read_csv(here("daten", "languageR_english.csv"))
```

## Auswahl der Spalten

```{r}
#| eval: false
df_eng |> 
  select(Word, WrittenFrequency)
```

```{r}
#| echo: false
df_eng |> 
  select(Word, WrittenFrequency) |> 
  head(10)
```

## Zeilen filtern

```{r}
#| eval: false
df_eng |> 
  filter(WrittenFrequency > 5.6)
```

```{r}
#| echo: false
df_eng |> 
  filter(WrittenFrequency > 5.6) |> 
  head(10)
```

## Auswahl von Zeilen und Spalten

```{r}
#| eval: false
df_eng |> 
  filter(WrittenFrequency > 5.6 & AgeSubject == "old") |> 
  select(AgeSubject, Word, WrittenFrequency) 
```

```{r}
#| echo: false
df_eng |> 
  filter(WrittenFrequency > 5.6 & AgeSubject == "old") |> 
  select(AgeSubject, Word, WrittenFrequency) |> 
  head(10)
```

## Streudiagramm

```{r}
df_eng |> 
  ggplot() +
  aes(x = WrittenFrequency, y = RTlexdec) +
  geom_point()
```

## Tidyverse versus Base R

Wie ist Ihr Eindruck von Base R im Vergleich zu Tidyverse? W√ºrden Sie, basierend auf dem, was Sie gesehen haben, das eine dem anderen vorziehen, oder w√ºrden Sie das eine nur in bestimmten F√§llen vorziehen? Hier gibt es keine richtige Antwort.


# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.9.0.463 (Desert Sunflower).

```{r}
print(sessionInfo(),locale = F)
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::










