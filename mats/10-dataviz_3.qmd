---
title: "Datenvisualisierung 3"
subtitle: "Darstellung der zusammenfassenden Statistik"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 10 - Data Viz 3" 
date: "12/20/2023"
date-format: "ddd [den] DD.MM.YYYY"
date-modified: last-modified
## shift-heading-level-by: +1
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, ### evaluate chunks
                      echo = T, ### 'print code chunk?'
                      message = F, ### 'print messages (e.g., warnings)?'
                      error = T, ### continueeven when error encountered
                      warning = F) ### don't print warnings
```

## Lernziele {.unnumbered}

In diesem Kapital lernen wir wie man...

- Boxplots zu erstellen und zu interpretieren
- Mittelwerte und Standardabweichungen zu visualisieren

## Ressourcen {.unnumbered}

F√ºr weitere Lekt√ºre und √úbungen zu diesem Thema empfehle ich die Lekt√ºre von [Abschnitt 2.5 (Visualisierung von Relationen)](https://r4ds.hadley.nz/data-visualize#visualizing-relationships) in @wickham_r_2023, [Kapitel 4 (Darstellung von zusammenfassenden Statistiken)](https://psyteachr.github.io/introdataviz/representing-summary-statistics.html) in @nordmann_data_2022 und die Abschnitte 3.5-3.9 in @winter_statistics_2019.

## Einrichten {.unnumbered}

### Pakete {.unnumbered}

Wie √ºblich laden wir die `tidyverse` Familie von Paketen. Um uns beim Laden unserer Daten zu helfen, laden wir auch das `here`-Paket und das `janitor`-Paket, das n√ºtzlich ist, um unsere Daten aufzur√§umen (z.B. die `clean_names()`-Funktion). Um unsere Diagramme anzupassen, verwenden wir auch die Pakete `ggthemes` und `patchwork`. Ersteres hilft uns bei der Erstellung von farbenblindenfreundlichen Diagrammen, w√§hrend letzteres uns erlaubt, mehrere Diagramme zusammen zu drucken.

```{r}
pacman::p_load(tidyverse,
               here,
               janitor,
               ggthemes,
               patchwork)
```

```{r}
#| echo: false
## load magick for the slides
pacman::p_load(magick)
theme_set(theme_bw())
```

### Daten {.unnumbered}

Wir arbeiten wieder mit unserer leicht ver√§nderten Version des `english`-Datensatzes aus dem `languageR`-Paket. Sie sollten `langaugeR_english.csv` in Ihrem `Daten` Ordner haben. Der folgende Code l√§dt den Datensatz, bereinigt die Namen und korrigiert einige fehlerhafte Namen.

```{r}
df_eng <- read_csv(
  here(
    "daten",
    "languageR_english.csv"
  )
) |> 
  clean_names() |> 
  rename(
    rt_lexdec = r_tlexdec,
    rt_naming = r_tnaming
  )
```

## R√ºckblick: Visualisierung von Verteilungen

Wir haben bereits mehrere Arten von Diagrammen gesehen, die zur Visualisierung der Verteilung und der Beziehungen zwischen Variablen verwendet werden: 

  + Histogramme (1 numerische Variable)
  + Dichteplots (1 numerische Variable)
  + Streudiagramme (2 numerische Variablen)
  + Balkendiagramme (kategorische Variablen)
  
```{r}
#| echo: false
fig_hist <-
  df_eng |> 
  ggplot(aes(x = rt_lexdec, fill = age_subject)) +
  geom_histogram(binwidth = 50, alpha = 0.5, position = "identity") +
  labs(
    title = "Histogramm",
       x = "LDT-Reaktionszeit (ms)",
       y = "Anzahl",
    fill = "Altersgruppe") +
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme_minimal()

fig_dens <-
  df_eng |> 
  ggplot(aes(x = rt_lexdec, fill = age_subject, colour = age_subject)) +
  geom_density(alpha=.2) +
  labs(
    title = "Dichtediagramm",
      x = "LDT-Reaktionszeit (ms)",
       y = "Dichte",
    color = "Altersgruppe",
    fill = "Altersgruppe") +
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme_minimal()

fig_scat <-
  df_eng |> 
  ggplot(aes(x = rt_lexdec, y = rt_naming)) +
  geom_point(aes(color = age_subject, shape = age_subject), alpha = .3) +
  ## geom_smooth(method = "lm") +
  labs(
    title = "Streudiagramm",
       x = "LDT-Reaktionszeit (ms)",
       y = "Benennungsreaktionszeit (ms)",
    color = "Altersgruppe",
    shape = "Altersgruppe") +
  scale_color_colorblind() +
  theme_minimal()

fig_bar <-
  df_eng |> 
  ggplot(
       aes(x = age_subject, fill = word_category)) +
  geom_bar() +
    labs(
    title = "Balkendiagramm (gestapelt)",
    x = "Altersgruppe",
    y = "Anzahl",
    fill = "Wortkategorie"
  ) +
  scale_fill_colorblind() +
  theme_minimal()

fig_bar_dodge <-
  df_eng |> 
  ggplot(
        aes(x = age_subject, fill = word_category)) +
  geom_bar(position="dodge") +
    labs(
    title = "Balkenplot (ausgewichen)",
    x = "Altersgruppe",
    y = "Anzahl",
    fill = "Wortkategorie"
  ) +
  scale_fill_colorblind() +
  theme_minimal()
```

Schauen Sie sich jede Abbildung in @fig-distributions an. Wie viele Variablen werden jeweils dargestellt, und um welche *Typen* von Variablen handelt es sich? Welche zusammenfassende(n) Statistik(en) wird/werden in jedem Diagramm dargestellt?

```{r}
#| echo: false
#| label: fig-distributions
#| fig-cap: "Verschiedene Diagrammtypen zur Visualisierung der Verteilung von Rohdaten: Histogramm (A), Dichte-Diagramm (B), Streudiagramm (C), gestapeltes Balkendiagramm (D) und unscharfes Balkendiagramm (E)"
#| fig-width: 8
#| fig-asp: 1

(fig_hist + fig_dens) /
  (plot_spacer() + fig_scat + plot_spacer() + plot_layout(widths = c(1,2,1))) /
  (fig_bar + fig_bar_dodge) +
  plot_annotation(tag_levels = "A") +
  theme(plot.title = element_blank()) 
```

## Darstellung von zusammenfassenden Statistiken

In @sec-desc-stats haben wir etwas √ºber zusammenfassende Statistiken gelernt. Wir behandelten Ma√üe der zentralen Tendenz, n√§mlich Modus, Median und Mittelwert, sowie Ma√üe der Streuung, wie Bereich und Standardabweichung. Wie k√∂nnen wir zusammenfassende Statistiken visualisieren?

Wir haben bereits gesehen, dass Histogramme, Dichtediagramme und nun auch Geigenplots den Modus (h√∂chster Wert) und den Bereich (niedrigster und h√∂chster Wert) visualisieren. Jetzt lernen wir zwei weitere Arten von Diagrammen kennen, eines zur Darstellung der Verteilung der beobachteten Werte und eines zur Darstellung von Mittelwert und Standardabweichung.

### Boxplot {.kleiner}

Boxplots (manchmal auch Box-and-Whisker-Plots genannt, z. B. @fig-boxplot) bestehen aus einer Box mit einer Linie in der Mitte (die "Box") und Linien, die an beiden Enden der Box herausragen (die "Whisker"), sowie manchmal einigen Punkten. Schauen Sie sich @fig-boxplot an und identifizieren Sie jeden dieser 4 Aspekte der Darstellung. Kannst du erraten, was jeder dieser Aspekte darstellen k√∂nnte und wie du die Darstellung interpretieren solltest?


```{r}
#| ouput-location: column-fragment
#| echo: false
#| code-line-numbers: "|4"
#| label: fig-boxplot
#| fig-cap: "Boxplot von `df_eng` (K√∂rpermasse nach Alter_Proband)"

df_eng |> 
  ggplot(aes(x = age_subject, y = rt_lexdec, colour = age_subject)) +
  geom_boxplot() +
  labs(title = "Boxplot",
    x = "Altersgruppe",
    y = "LDT-Reaktionszeit (ms)",
    color = "Altersgruppe"
  ) +
  scale_color_colorblind() +
  theme_minimal() +
  theme(
    legend.position = "none"
  )
```

Die Box und die Whiskers stellen eine Vielzahl von Informationen in einer einzigen Visualisierung dar. Die Linie in der Mitte des Boxplots stellt den *Median* dar, auch Q2 genannt (2. Quartil; der mittlere Wert, √ºber/unter dem 50% der Daten liegen). Die Box selbst stellt den *Interquartilsbereich* (IQR; der Wertebereich, der zwischen den mittleren 50\% der Daten liegt) dar. Die Grenzen der Box stellen Q1 (1. Quartil, unter dem 25\% der Daten liegen) und Q3 (3. Quartil, √ºber dem 25\% der Daten liegen) dar. Die Whisker stellen `1,5*IQR` von Q1 (unterer Whisker) oder Q3 (oberer Whisker) dar. Alle Punkte, die au√üerhalb der Whisker liegen, stellen Ausrei√üer dar (d. h. Extremwerte, die au√üerhalb des IQR liegen).

@fig-winter-boxplot-hist [@winter_statistics_2019, S. 59] zeigt die Beziehung zwischen der Verteilung einer Variablen, wie sie in einem Histogramm dargestellt wird, und einem Boxplot. W√§hrend das Histogramm die Balkenh√∂he verwendet, um die Anzahl der Beobachtungen innerhalb eines bestimmten Bereichs anzuzeigen, verwendet der Boxplot die Box und die Whiskers, um die Schwellenwerte anzugeben, in denen bestimmte Anteile der Daten enthalten sind (d. h. der Interquartilsbereich).

::: {.content-visible when-format="revealjs"}
```{r echo = F, fig.align = "center"}
#| fig-cap: "Image source: @winter_statistics_2019 (all rights reserved)"
#| fig-cap-location: bottom

## invert colours for dark mode in slides
library(magick)
magick::image_negate(magick::image_read(here::here("media/Winter_2019_boxplot.png")))
```
:::

::: {.content-hidden when-format="revealjs"}
```{r echo = F, fig.align = "center"}
#| fig-cap: "Image source: @winter_statistics_2019 (all rights reserved)"
#| fig-cap-location: bottom
#| label: fig-winter-boxplot-hist
magick::image_read(here::here("media/Winter_2019_boxplot.png"))
```
:::

@fig-wickham-boxplot-hist [@wickham_r_2023] bietet einen √§hnlichen Vergleich, wobei die einzelnen Beobachtungen im Streudiagramm auf der linken Seite hinzugef√ºgt wurden.

::: {.content-visible when-format="revealjs"}
```{r echo = F, fig.align = "center"}
#| fig-cap: "Image source: @wickham_r_2023 (all rights reserved)"
#| fig-cap-location: bottom

## invert colours for dark mode in slides
y <- magick::image_read(here::here("media/Wickham_boxplot.png"))

magick::image_negate(y)
```
:::

::: {.content-hidden when-format="revealjs"}
```{r echo = F, fig.align = "center"}
#| fig-cap: "Image source: @wickham_r_2023 (all rights reserved)"
#| fig-cap-location: bottom
#| label: fig-wickham-boxplot-hist
magick::image_read(here::here("media/Wickham_boxplot.png"))
```
:::

Ich hoffe, Sie haben jetzt ein wenig verstanden, wie man Boxplots interpretiert. Man braucht etwas √úbung, aber das Wichtigste ist, sich daran zu erinnern, dass die mittleren 50\% der Daten in der Box enthalten sind, w√§hrend die "Schw√§nze" der Daten durch die "Whisker" dargestellt werden.

#### `geom_boxplot()`

Wir k√∂nnen Boxplots mit der Funktion `geom_boxplot()` von `ggplot2` erstellen. Zumindest m√ºssen wir eine numerische Variable als `x` oder `y` Achse angeben (@fig-geom-boxplot-y). Wenn wir Boxplots f√ºr verschiedene Gruppen erstellen wollen, k√∂nnen wir den Namen einer kategorischen Variable auf der anderen Achse angeben (@fig-geom-boxplot).

```{r}
#| code-line-numbers: "2,3"
#| label: fig-geom-boxplot-y
#| fig-cap: "Ein Boxplot f√ºr alle Beobachtungen einer kontinuierlichen Variablen"
#| output-location: column
#| fig-asp: .618
#| fig-width: 5
df_eng |> 
  ggplot(aes(y = rt_lexdec)) +
  geom_boxplot() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```


```{r}
#| code-line-numbers: "|3"
#| label: fig-geom-boxplot
#| fig-cap: "Ein Boxplot f√ºr zwei Gruppen"
#| output-location: column
#| fig-width: 5
#| fig-asp: .618
df_eng |> 
  ggplot(aes(x = age_subject, y = rt_lexdec)) +
  geom_boxplot() +
  theme_bw()
```

#### Gruppierter Boxplot

Genau wie ein Bargraph k√∂nnen wir gruppierte Boxplots erstellen, um mehr Variablen zu visualisieren. Ordnen Sie einfach eine neue Variable mit `colour` oder `fill` √§sthetisch zu.

```{r}
#| output-location: column-fragment
#| fig-width: 7
#| label: df_boxplot_group
#| fig-cap: Ein gruppierter Boxplot
df_eng |> 
  ggplot(aes(x = age_subject, y = rt_lexdec, colour = word_category)) +
  geom_boxplot() +
  labs(
    x = "Altersgruppe",
    y = "LDT-Reaktionszeit (ms)",
    color = "Wortart"
  ) +
  scale_colour_colorblind() +
  theme_bw()
```


::: {.callout-tip}

#### Boxplots in R

Mit der Funktion `boxplot()`, die einen kontinuierlichen (d.h. numerischen) Vektor als Argument akzeptiert, kann ein Boxplot in der Base-R-Syntax erstellt werden. Da Datenrahmen eine Ansammlung von Vektoren (d.h. die Variablen/Spalten) gleicher L√§nge sind, k√∂nnen wir auch eine kontinuierliche Variable in einem Datenrahmen als Argument verwenden. Dazu verwenden wir den Subsetting-Operator `$`, der einen Datenrahmen in eine einzelne Variable, in unserem Fall `rt_lexdec`, unterteilt.

```{r}
#| label: fig-baser-boxplot
#| fig-cap: Boxplot erstellt mit Basis R
#| fig-width: 5
boxplot(df_eng$rt_lexdec)
```

Wir k√∂nnen auch eine kategoriale Variable als "Pr√§diktor" verwenden, mit der Syntax `kontinuierlich ~ kategorisch`, wobei `~` als "vorhergesagt von" gelesen werden kann.

```{r}
#| label: fig-baser-boxplot-cat
#| fig-cap: Boxplot erstellt mit Basis R
#| fig-width: 5
boxplot(df_eng$rt_lexdec ~ df_eng$age_subject)
```

:::

## Visualisierung des Mittelwerts

Boxplots zeigen ein Ma√ü f√ºr die zentrale Tendenz (Median) und mehrere Ma√üe f√ºr die Streuung. In der Regel wird auch der Mittelwert mit der Standardabweichung dargestellt.^[Anstelle der Standardabweichung werden in der Regel Standardfehler oder Konfidenzintervalle (oder glaubw√ºrdige Intervalle) dargestellt, die jedoch in diesem Kurs nicht behandelt werden. Aus diesem Grund sollten wir im Titel der Grafik vermerken, was die Fehlerbalken darstellen]. Wie k√∂nnte man dies tun?

### Fehlerbalken-Diagramme

Fehlerbalkendiagramme werden √ºblicherweise verwendet, um den Mittelwert und die Standardabweichung mit Hilfe von Fehlerbalken zu visualisieren. Auch hier werden in der Regel Standardfehler oder Konfidenzintervalle (oder glaubw√ºrdige Intervalle) durch Fehlerbalken dargestellt, die wir in diesem Kurs jedoch nicht behandeln werden. Diese Diagramme bestehen aus zwei Teilen: dem Mittelwert, der mit `geom_point()` dargestellt wird, und der Standardabweichung, die mit `geom_errorbar()` dargestellt wird. Die Fehlerbalken stellen den Bereich von 1 Standardabweichung √ºber und unter dem Mittelwert dar (Mittelwert +/- 1SD).

```{r}
#| ouput-location: column-fragment
#| echo: false
#| label: fig-errorbar
#| fig-width: 5
#| fig-cap: "Fehlerbalken-Diagramm von `df_eng` (K√∂rpermasse nach Alter_Proband)"

df_eng |> 
  summarise(mean = mean(rt_lexdec),
            sd = sd(rt_lexdec),
            N = n(),
            .by = c(age_subject)) |> 
  ggplot(aes(x = age_subject, y = mean, colour = age_subject)) +
  ## geom_point(data = df_eng, alpha = .4, position = position_jitterdodge(.5), aes(x = age_subject, y = rt_lexdec)) +
  geom_point(size = 3) +
  geom_errorbar(width = .5, aes(ymin=mean-sd, ymax=mean+sd)) +
  labs(title = "Fehlerbalkendiagramm (+/-1SD)",
    x = "Altersgruppe",
    y = "LDT-Reaktionszeit (ms)",
    color = "Altersgruppe"
  ) +
  scale_color_colorblind() +
  theme_bw() +
  theme(
    legend.position = "none"
  )
```

Es gibt einige M√∂glichkeiten, Fehlerbalken-Diagramme zu erstellen, aber wir werden uns auf die Verwendung von `ggplot2` und die Erstellung von zusammenfassenden Statistiken konzentrieren, wie wir sie in @sec-desc-stats mit der Funktion `summarise()` von `dplyr` gesehen haben.

#### Berechnung der zusammenfassenden Statistik

Zun√§chst m√ºssen wir den Mittelwert und die Standardabweichung berechnen, gruppiert nach den Variablen, die wir visualisieren wollen. Bleiben wir bei `rt_lexdec` nach `age_subject`. Wie k√∂nnen wir den Mittelwert und die Standardabweichung von `rt_lexdec` nach `age_subject` berechnen?

```{r}
#| code-fold: true
#| code-summary: "Click here to see how"
df_eng |> 
  summarise(mean = mean(rt_lexdec),
            sd = sd(rt_lexdec),
            N = n(),
            .by = age_subject) |> 
  arrange(age_subject)
```

Um zusammenfassende Statistiken zu erstellen, k√∂nnen wir entweder den obigen Code direkt in ein `ggplot`-Objekt einf√ºgen, indem wir eine Pipe verwenden, oder wir k√∂nnen die Zusammenfassung als ein Objekt speichern, das wir dann in `ggplot` einf√ºgen. Beide Optionen erzeugen das gleiche Diagramm, wie wir unten sehen.

::: {.panel-tabset}
#### Neues Objekt
```{r}
#| output-location: column-fragment
## Neues Objekt mit Zusammenfassungen erstellen
sum_eng <- df_eng |> 
  summarise(mean = mean(rt_lexdec),
            sd = sd(rt_lexdec),
            N = n(),
            .by = age_subject) |> 
  arrange(age_subject, age_subject)

## Neues Objekt in ggplot einf√ºgen
sum_eng |> 
  ggplot(aes(x = age_subject, y = mean, colour = age_subject)) 
```

#### With a pipe

```{r}
#| output-location: column-fragment
df_eng |> 
  summarise(mean = mean(rt_lexdec),
            sd = sd(rt_lexdec),
            N = n(),
            .by = age_subject) |> 
  arrange(age_subject, age_subject) |> 
  arrange(age_subject, age_subject) |> 
  ggplot() +
  aes(x = age_subject, y = mean, colour = age_subject)
```

:::

Ich neige dazu, eine Mischung aus diesen beiden Optionen zu verwenden. Manchmal erstelle ich ein neues Objekt und manchmal nicht, je nachdem, was f√ºr meinen Arbeitsablauf am sinnvollsten ist. In den F√§llen, in denen ich die zusammenfassenden Statistiken auch drucken oder im Auge behalten m√∂chte, w√ºrde ich ein Objekt erstellen, das die Zusammenfassung enth√§lt. Dies hat den zus√§tzlichen Vorteil, dass es mit zus√§tzlichen Formatierungen gedruckt werden kann, um eine sch√∂ne Tabelle zu erstellen (wie @tbl-sum_eng).

```{r}
#| label: tbl-sum_eng
#| tbl-cap: Formatierte Tabelle von `sum_eng`
#| echo: false

sum_eng |> 
  mutate_if(is.numeric, round, 1) |> 
  knitr::kable(
    col.names = c("Altersgruppe", "Mittlere LDT (ms)", "SD", "N"),
  escape = F,
  full_width = F) |> 
  kableExtra::kable_styling()
```



#### Plotten von Mittelwerten

Aber alles, was wir bis jetzt haben, ist eine leere Leinwand, wir m√ºssen unsere `geom`s hinzuf√ºgen. Zuerst f√ºgen wir die Mittelwerte mit `geom_point()` ein.

```{r}
#| output-location: column-fragment
sum_eng |> 
  ggplot() +
  aes(x = age_subject, y = mean) +
  geom_point()
```

#### Hinzuf√ºgen von Fehlerbalken

F√ºgen wir nun unsere Fehlerbalken hinzu, die eine Standardabweichung √ºber und unter dem Mittelwert darstellen. Wir tun dies mit `geom_errorbar()`, das `ymin` und `ymax` als Argumente ben√∂tigt. Diese sind jeweils gleich `mean-/+sd`. Wir haben sie der √úbersichtlichkeit halber in einen weiteren `aes()`-Aufruf innerhalb von `geom_errorbar()` eingef√ºgt, aber sie k√∂nnten auch im ersten `aes()`-Aufruf erscheinen.

```{r}
#| output-location: column-fragment
sum_eng |> 
  ggplot() +
  aes(x = age_subject, y = mean) +
  geom_point() +
  geom_errorbar(aes(ymin = mean-sd, 
                    ymax = mean+sd)) +
  theme_bw()
```

Hier sehen wir also den Mittelwert mit +/-1SD f√ºr die √§lteren und j√ºngeren Teilnehmergruppen. Und wenn wir einige weitere Anpassungen hinzuf√ºgen, erhalten wir @fig-errorbar-custom.

```{r}
sum_eng |> 
  ggplot() +
  aes(x = age_subject, y = mean, colour = age_subject, shape = age_subject) +
  labs(title = "Mittlere LDT-Zeiten (+/-1SD)",
    x = "Altersgruppe",
    y = "Reaktionszeit (ms)",
    color = "Altersgruppe"
  ) +
  geom_point(size = 3) +
  geom_errorbar(width = .5, aes(ymin=mean-sd, ymax=mean+sd)) +
  scale_color_colorblind() +
  theme_bw() +
  theme(
    legend.position = "none"
  )
```


::: {.callout-tip}

### `stat_summary()`

In `ggplot2` gibt es eine weitere n√ºtzliche Funktion, mit der zusammenfassende Statistiken visualisiert werden k√∂nnen, ohne dass zuvor mit `dplyr::sumarise()` Zusammenfassungen erstellt werden m√ºssen. Die Funktion `stat_summary()` erlaubt es uns, zusammenfassende Statistiken direkt in unserem `ggplot()`-Objekt zu erstellen, was bedeutet, dass wir mehrere zusammenfassende Statistiken im selben Plot darstellen k√∂nnen (was wir noch nicht tun werden...).

Die Funktion `stat_summary()` ben√∂tigt mindestens zwei Argumente: `stat =`, das ist der Typ der Statistik, die man darstellen m√∂chte, und `geom =`, das ist der Typ des `geom`, mit dem man es visualisieren m√∂chte. Wir k√∂nnen Mittelwerte leicht mit Punkten (@fig-stat-point) oder einem Balkenplot (@fig-stat-bar) darstellen, obwohl ich dringend empfehle, Balkenplots zu vermeiden, wenn ein Punktwert wie ein Mittelwert dargestellt werden soll.

```{r}
#| label: fig-stat-point
#| fig-cap: '`stat_summary(stat_summary(fun = "mean", geom = "point"))`'
df_eng |> 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec, colour = age_subject) +
  stat_summary(fun = "mean", geom = "point") +
  labs(title = 'geom = "point"')
```

```{r}
#| label: fig-stat-bar
#| fig-cap: '`stat_summary(stat_summary(fun = "mean", geom = "bar"))`'
df_eng |> 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec, fill = age_subject) +
  stat_summary(fun = "mean", geom = "bar") +
  labs(title = 'geom = "bar"')
```

Wir k√∂nnen auch Fehlerbalken mit `stat_summary()` einf√ºgen, wie in @fig-stat-error. Dies erzeugt doppelte Standardabweichungen, so dass wir die `fun.args =`-Werte einf√ºgen m√ºssen, um anzugeben, dass wir einfache Standardabweichungen visualisieren wollen.

```{r}
#| label: fig-stat-error
#| fig-cap: '`stat_summary(fun.data = "mean_sdl", geom = "errorbar",...`'
df_eng |> 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec, colour = age_subject) +
  stat_summary(fun = "mean", geom = "point") +
  stat_summary(fun.data = "mean_sdl",
               geom = "errorbar",
               fun.args = list (mult = 1)) +
  labs(title = 'Fehlerbalken-Darstellung mit `stat_summary()`') +
  theme_bw()
```

Wie Sie sehen k√∂nnen, ist das Hinzuf√ºgen von Fehlerbalken mit `stat_summary()` etwas weniger einfach, weshalb wir uns f√ºr den Weg `summarise() |> ggplot() + ...` entschieden haben. Ein zus√§tzlicher Vorteil der Verwendung von `summarise()` ist, dass Sie Ihre Zusammenfassung als Tibble (d.h. als Tabelle oder Datenrahmen) speichern k√∂nnen, die zus√§tzlich zum Plot gedruckt werden kann (wie wir mit @tbl-df_eng gesehen haben). Ich habe erst vor ein oder zwei Jahren begonnen, `dplyr::summarise()` anstelle von `ggplot2::stat_summary()` zu verwenden, und bevorzuge Ersteres, weil ich dann die berechneten Werte vor dem Plotten √ºberpr√ºfen kann. Dies ist eine Frage der pers√∂nlichen Vorliebe, wenn Sie also neugierig sind, schlage ich vor, dass Sie `stat_summary()` ausprobieren, um zu sehen, ob Sie eine Vorliebe haben. Wenn Sie mehr √ºber `stat_summary()` erfahren wollen, k√∂nnen Sie `?stat_summary` in der `Console` eingeben oder nach Tutorials oder YouTube-Videos googeln, es gibt viele davon.
:::

### Balkendiagramm der Mittelwerte: Finger weg!

Ich flehe Sie an, *nicht* Mittelwerte mit Balkendiagramme darzustellen! Sie werden sehr oft Balkendiagramme von Mittelwerten sehen, und andere unterrichten dies vielleicht sogar in anderen Kursen, aber es gibt viele Gr√ºnde, warum dies eine schlechte Idee ist!!!

Erstens k√∂nnen sie sehr irref√ºhrend sein. Sie beginnen bei 0 und vermitteln den Eindruck, dass die Daten beim Mittelwert enden, obwohl etwa die H√§lfte der Daten (normalerweise) √ºber dem Mittelwert liegt. 

Au√üerdem hat der Balkenplot ein schlechtes Daten-Tinten-Verh√§ltnis, d. h. die Menge der Datentinte geteilt durch die Gesamttinte, die zur Erstellung der Grafik ben√∂tigt wird, oder die Menge der Tinte, die entfernt werden kann, ohne dass Informationen verloren gehen. Beispielsweise beginnen Balkenplots normalerweise bei Null und enden beim Mittelwert. Was aber, wenn es nur sehr wenige oder gar keine Beobachtungen in der N√§he von Null gibt? Wir verbrauchen eine Menge Tinte, wo es keine Beobachtungen gibt! Ein ebenso abscheuliches Verbrechen ist, dass der Balken nur den Bereich abdeckt, in dem die untere *H√§lfte* der Beobachtungen liegt; ebenso viele Beobachtungen liegen √ºber dem Mittelwert!

Meiner Meinung nach sollten Balkendiagramme nur f√ºr Z√§hlungen oder H√§ufigkeiten verwendet werden. Abgesehen davon sind Fehlerbalken allein nicht die L√∂sung. Die Darstellung *nur* des Mittelwerts und der Standardabweichung (oder des Standardfehlers/des Konfidenzintervalls/der glaubw√ºrdigen Intervalle) verbirgt eine Menge Informationen √ºber die tats√§chliche Streuung und Verteilung der Daten. Erinnern Sie sich an das Paket `datasauRus`, das Datens√§tze mit √§hnlichen Mittelwerten, Standardabweichungen und Anzahl der Beobachtungen, aber *sehr* unterschiedlichen Verteilungen enth√§lt. @fig-dino-barplot zeigt die Verteilung von 5 dieser Datens√§tze (A), einen Balkenplot des Mittelwerts, der Standardabweichung und der Anzahl der Beobachtungen f√ºr die Variablen "x" und "y" (B) sowie einen Fehlerbalkenplot (C). 

```{r}
#| echo: false
fig_datasaurus_scatter <- datasauRus::datasaurus_dozen |> 
  filter(dataset %in% c("away", "bullseye", "circle", "dino", "star")) |> 
ggplot(aes(x = x, y = y, colour = dataset))+
  geom_point() +
  theme_minimal() +
  theme(legend.position = "none")+
  facet_wrap(~dataset, ncol = 5)

fig_datasaurus_bar <-
  datasauRus::datasaurus_dozen |> 
  filter(dataset %in% c("away", "bullseye", "circle", "dino", "star")) |> 
  pivot_longer(cols = c(x,y),
               names_to = "variable",
               values_to = "value") |> 
  summarise(mean = mean(value),
            sd = sd(value),
            n = n(),
            .by = c(dataset, variable)) |> 
  pivot_wider(
    id_cols = dataset,
    names_from = variable,
    values_from = c(mean,sd,n)
  ) |> 
    pivot_longer(
      cols = c(2:7),
      names_to = "measure",
      values_to = "value"
    ) |> 
ggplot(aes(x = measure, y = value, fill = dataset)) +
  facet_grid(~dataset) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust=1))

fig_datasaurus_point <-
  datasauRus::datasaurus_dozen |> 
  filter(dataset %in% c("away", "bullseye", "circle", "dino", "star")) |> 
  pivot_longer(cols = c(x,y),
               names_to = "variable",
               values_to = "value") |> 
  summarise(mean = mean(value),
            sd = sd(value),
            n = n(),
            .by = c(dataset, variable)) |> 
  pivot_wider(
    id_cols = dataset,
    names_from = variable,
    values_from = c(mean,sd,n)
  ) |> 
    pivot_longer(
      cols = c(2:7),
      cols_vary = "slowest",
    names_to = c(".value", "variable"),
    names_sep = "_"
    ) |> 
ggplot(aes(x = variable, y = mean, colour = variable, shape = variable,
           ymin = mean-sd, ymax = mean+sd)) +
  labs(y = "value") +
  facet_grid(~dataset) +
    geom_point() +
    geom_errorbar(width = .3) +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust=1))

```

```{r}
#| fig-width: 8
#| fig-asp: .9
#| label: fig-dino-barplot
#| fig-cap: Datasets with the same means, sds, and Ns, but very different distributions
#| echo: false

fig_datasaurus_scatter / fig_datasaurus_bar / fig_datasaurus_point +
  plot_annotation(tag_levels = "A")
```

Sie werden sehen, dass die Verteilungen sehr unterschiedlich aussehen (in @fig-dino-barplot A), aber @fig-dino-barplot B und C vermitteln das nicht. Aus diesem Grund ist es ein guter Grund, die Rohdatenpunkte *immer* zu visualisieren, unabh√§ngig davon, welche zusammenfassende Darstellung Sie erstellen (z. B. verbergen Errorbar-Plots auch viele Daten). Eine gute M√∂glichkeit, alle Grundlagen abzudecken, besteht darin, die Verteilung der Daten zusammen mit einer Visualisierung der zusammenfassenden Statistiken darzustellen. Sie werden dies in der Hausaufgabe √ºben, und in @sec-dataviz4 werden wir sehen, wie man diese zusammen in einem Diagramm visualisiert.


## Lernziele üèÅ {.unnumbered .unlisted}

In diesem Kapital haben wir gelernt, wie man...

- Boxplots zu erstellen und zu interpretieren ‚úÖ
- Mittelwerte und Standardabweichungen zu visualisieren ‚úÖ

## Hausaufgabe {.unnumbered}

### Boxplot mit Facette {.unnumbered}

::: nicht-inkrementell
1. Erzeugen Sie einen Plot namens `fig_boxplot`, der ein Boxplot der `df_eng` Daten ist, mit:
    + `age_subject` auf der `x`-Achse
    + `rt_naming` auf der `y`-Achse
    + `age_subject` als `colour` *oder* `fill` (w√§hle eine, es gibt keine falsche Wahl)
    + `Wort_Kategorie` in zwei Facetten mit `facet_wrap()` aufgetragen
    + die von Ihnen gew√§hlte `theme_`-Einstellung (z.B. `theme_bw()`; f√ºr weitere Optionen siehe [hier](https://ggplot2.tidyverse.org/reference/ggtheme.html))
    
```{r}
#| echo: false
fig_boxplot <-
df_eng |> 
  ggplot() +
  aes(x = age_subject, y = rt_naming,
      colour = age_subject) +
  facet_wrap(~word_category) +
  labs(
    title = "Benennung von RTs nach Altersgruppen",
    x = "Altersgruppe",
       y = "Benennungs-RT (ms)") +
  geom_boxplot() +
  scale_color_colorblind() +
  theme_bw() +
  theme(legend.position = "none") 
```

:::
  
### Errorbar plot {.unnumbered}

::: nonincremental
2. Versuchen Sie, @fig-error-naming zu reproduzieren. Hinweis: Sie werden die Variable `rt_naming` aus `df_eng` verwenden.
:::
```{r}
#| echo: false
fig_error_naming <- df_eng |> 
  drop_na() |> 
  summarise(
    mean = mean(rt_naming),
    sd = sd(rt_naming),
    .by = age_subject
  ) |> 
  ggplot() +
  aes(x = age_subject, y = mean, 
             colour = age_subject, shape = age_subject,
      ymin = mean-sd, ymax = mean+sd) +
    labs(
      title = "Mittlere Benennungszeiten (+/-1 SD)",
      y = "Benennungs-RTs (ms)",
      x = "Altersgruppe"
  ) +
  geom_point(size = 2) +
  geom_errorbar(width = .3) +
  scale_colour_colorblind() +
  theme_bw() +
  theme(legend.position = "none")
```

```{r}
#| echo: false
#| label: fig-error-naming
#| fig-cap: "Plot to be reproduced"
#| fig-width: 5
#| fig-asp: .618
fig_error_naming
```

### Patchwork {.unnumbered}

::: nicht-inkrementell
3. Verwenden Sie das Paket `patchwork`, um Ihren Boxplot und Ihre Fehlerbalkenplots nebeneinander darzustellen. Es sollte ungef√§hr so aussehen wie @fig-patchwork. Hinweis: Wenn Sie die "tag-level" ("A" und "B") zu den Plots hinzuf√ºgen m√∂chten, m√ºssen Sie `+ plot_annotation(tag_level = "A")` aus `patchwork` hinzuf√ºgen.
:::

```{r}
#| label: fig-patchwork
#| fig-cap: Combined plots with `patchwork`
#| echo: false
#| fig-width: 8
#| fig-asp: .5
fig_boxplot + fig_error_naming + plot_annotation(tag_levels = "A")
```



## Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.9.0.463 (Desert Sunflower).

```{r}
print(sessionInfo(),locale = F)
```

## Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::
