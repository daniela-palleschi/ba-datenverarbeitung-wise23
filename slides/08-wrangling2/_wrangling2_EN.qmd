---
title: "Data Tidying"
subtitle: "Data Tidying"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 8 - Data Tidying" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: wrangling2_blatt_EN.html
    include-after-body: custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
  revealjs: 
    output-file: wrangling2_folien_EN.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: true
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
  pdf:
    output-file: wrangling2_EN.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
bibliography: references/references.bib
csl: references/apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_wrangling2_EN.qmd")
```

# Wiederholung {.unnumbered}

Last week we learned how to...

- Code-Chunk-Optionen verwenden
- formatierte Tabellen drucken
- Abbildungsunterschriften hinzuf√ºgen
- die Gr√∂√üe von Abbildungen kontrolliern
- Querverweise erstellem

## Last week's exercises {.unnumbered}

- I had some typos in my instructions :(
  + `include: false` should have been `message: false`
  + `fig-out: 6` should have been `fig-width: 6`
  
- there were some common issues
  + e.g., setting global options
  + `label` formatting
  + missing cross-references

# Heutige Ziele {.unnumbered}

Today we will...

- learn about wide versus long data
- make wide data longer
- make long data wider

## Lust auf mehr? {.unnumbered}

- Ch. 6 ([Data tidying](https://r4ds.hadley.nz/data-tidy.html)) in @wickham_r_nodate
- Ch. 8 ([Data Tidying](https://psyteachr.github.io/ads-v2/08-tidy.html)) in @nordmann_applied_2022

# Einrichtung

- packages: `tidyverse`, `here`

```{r}
pacman::p_load(tidyverse,
               here)
```

- data (in `daten` folder): 
  + `table1.csv` 
  + `df_billboard.csv` (neu)
  + `cms_patient_experience.csv` (neu)

```{r}
#| echo: false
#| eval: false

# save built-in datasets as CSV, so students have to practice loading in CSVs

data(table1)
write.csv(table1, here::here("daten", "table1.csv"), row.names = F)

data(billboard)
df_billboard <- billboard %>% 
  janitor::clean_names()
write.csv(df_billboard, here::here("daten", "df_billboard.csv"), row.names = F)

data("cms_patient_experience")
df_cms <- cms_patient_experience %>% 
  janitor::clean_names()
write.csv(df_cms, here::here("daten", "cms_patient_experience.csv"), row.names = F)
```

```{r}
df_tb <- read_csv(here("daten", "table1.csv"))
df_billboard <- read_csv(here("daten", "df_billboard.csv"))
df_cms <- read_csv(here("daten", "cms_patient_experience.csv"))
```

# Tidy workflow

- we've learned how to import (`readr::read_csv`), transform  (`dplyr` package), and visualise  (`ggplot` package) data
- so far we've always worked with tidy data, so we haven't needed to perform the 'tidy' step

::: {.content-visible when-format="revealjs"}
```{r}
#| echo: false
#| out-width: "70%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_nodate (all rights reserved)"
magick::image_negate(magick::image_read(here::here("media/Wickham_tidyworkflow.png")))
```
:::

::: {.content-hidden when-format="revealjs"}
```{r}
#| echo: false
#| out-height: "100%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_nodate (all rights reserved)"
knitr::include_graphics(here::here("media/Wickham_tidyworkflow.png"))
```
:::

# Tidy data

- the same data can be representing multiple ways
- the datasets below all show the same values of four variables: `country`, `year`, `popuplation`, and number of tuberculosis `cases`
  + each dataset organises the values differently

::: {.content-visible when-format="revealjs"}
:::: columns 
::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

::: {.column width="33%"}
```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

:::: 

:::


```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20,
    full_width = F
  )
```

- which is easiest to read?

---

Three rules for tidy data:

1.  Each variable is a column, each column is a variable
2.  Each observation is a row, each row is an observation
3.  Each value is a cell, each cell is a single value

```{r}
#| echo: false
#| out-width: "90%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/data-tidy.html) @wickham_r_nodate (all rights reserved)"
knitr::include_graphics(here::here("media/Wickham_tidydata.png"))
```

- what counts as an observations or a variable is often dependent on the task at hand

## Why tidy data?

> "**Happy families** are all alike; every **unhappy family** is unhappy in its own way."
> --- Leo Tolstoy

> "**Tidy datasets** are all alike, but every **untidy dataset** is untidy in its own way."
> --- Hadley Wickham

- data tidying requires some work up front, but is helpful in the long run
- once you have tidy data, you'll spend less time trying to get your data in the right shape to do what you want

---

There are two main advantages to working with tidy data:

1. working with a consistent data structure allows us to adopt conventions
    + since tidy data is the generally agreed upon data structure, conventions are built on the assumption of this structure
    + so tools have an underlying uniformitivity
2. R's vectorised nature can shine
    + most built-in R funtions work with *vector values*
    + all packages in the `tidyverse` are designed to work with tidy data

::: callout-note
## Vectors
Vectors are the most basic data object type in R. A vector contains data of the same type, and is essentially a list. You can create a vector using the `c()` function, for example.

```{r}
vector1 <- c(2, 3, 4, 6, 7)
vector2 <- c(2, 3, 4, 6, "c")
```

`vector1` will contain numeric values, because all elements are numbers. `vector2` will contain all character values (i.e., text), because there is a singlular unambiguous character element (`"c"`). So, R reads all elements as character type. We can create a dataframe from vectors of the same length using the `tibble()` function, for example.

```{r}
tibble(vector1,vector2)
```

:::

---

- most data "in the wild" is untidy
  + data is often first organised for some goal other than analysis
    + usually this goal is data entry: we want to make it easy to document our observations first
  + most people aren't familiar with the principles of tidy data, only after spending *a lot* of time with data does it become obvious why tidy data is necessary

- this means most *real* analyses will require at least some tidying

::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-tidy .custom}
::: nonincremental
1.  Go back to Tables 1-3. For each table, describe what each observation and each column represents.
2.  Sketch out the process you‚Äôd use to calculate the rate for table1. You will need just one verb that:
    + creates a new variable (call it `rate`) that contains:
      + the number of TB `cases` per country per year, divided by
      + the matching `population` per country per year, 
      + multiply by `10000`
    + hint: Which `dplyr` verb creates new variables? (Look back at week 5)
3.  Look at tables 2 and 3. Would it have been as easy to calculate `rate` with these data structures?

:::
:::
:::

# Data tidying

-   re-shaping
    -   e.g., from wide to long data
-   outcome:
    -   each column = a variable
    -   each row = an observation
    
## Data tidying with the `tidyverse`

- with `tidyr` package
  - `pivot_longer()`: make wide data longer
  - `pivot_wider()`: make long data wider
  
- we often need to convert between these formats to do different types of summaries or visualisation

---

::: {.content-hidden when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="100%"}
#| fig-cap-location: bottom
#| label: fig-pivot-html
#| fig-cap: die ber√ºhmteste Verwendung des Wortes Pivot (zumindest f√ºr Millenials) ([Friends](https://www.youtube.com/watch?v=8w3wmQAMoxQ))
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

::: {.content-visible when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="50%"}
#| fig-cap-location: bottom
#| label: fig-pivot-pdf
#| fig-cap: die ber√ºhmteste Verwendung des Wortes Pivot (zumindest f√ºr Millenials)
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

# Wide versus long data

- Wide data: all of the observations about one thing are in the same row
  + wide data is *usually* not tidy
- long data: each observation is on a separate row
  + long data is *usually* tidy
  
# Lengthening data: `df_billboard`

- in the `billboard.csv` dataset
  - each row is a song
  - the first three columns are variables that describe the song (`artist`, `track`, `date_entered`)
  - we have 76 columns (`wk1-wk76`) that describe the rank of the song that week
    + the columns names are one variable (the `week`), and the cell values are another variable (the `rank`)

```{r}
#| label: tbl-df_billboard
#| tbl-cap: df_billboard rank of songs in the year 2000
df_billboard %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling()
```

- is this data in @tbl-df_billboard tidy?
- is this data too wide or too long?
- how might we tidy this data?

## `pivot_longer()`

- `pivot_longer()`
  + converts a wide data table to a longer format by converting the headers from specified columns into the values of new columns
  + and combining the values of those columns into a new condensed column

```{r}
#| echo: true
df_billboard_tidy <- df_billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
```

```{r}
#| echo: true
#| output-location: column-fragment
#| label: tbl-longer
#| tbl-cap: A pivoted version of `df_billboard` (first 10 rows)
df_billboard_tidy %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

- `col = ` specifies which columns need to be pivoted (i.e., which are *not* variables)
  + takes the same syntax as `select()`, so we could use e.g., `starts_with("")`
- `names_to = ` names the variable stored in the current column names, here it is `week`
- `values_to = ` names the variable stored int he cell values, which we name `rank`
- N.B., we had to wrap `week` and `rank` with quotation marks because they aren't variable names *yet*

### Removing missing values (`NA`s)

- we have a few `NA` (missing) values; this happened when a song was not in the top 100
  + the `values_drop_na = TRUE/FALSE` argument drops pivoted rows don't have a value for the new variable

```{r}
df_billboard_tidy <- df_billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  ) 
```

```{r}
#| echo: false
#| label: tbl-billboard-tidy
#| tbl-cap: Tidy `df_billboard` data with dropped `NA` values
df_billboard_tidy %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

- how many rows fewer do we have now?

### Parsing numbers

- the data is now tidy, but `week` still contains `wk` in the values
- the `readr` package has a handy function: `parse_number()` extracts the first number from a string, ignoring all other text
  + how could we use `parse_number()` to *alter the variable* `week`?

```{r}
df_billboard_tidy <- df_billboard_tidy %>% 
  mutate(week = parse_number(week))
```

```{r}
#| echo: false
#| label: tbl-billboard-tidy-NA
#| tbl-cap: Tidy `df_billboard` data with dropped `NA` values
df_billboard_tidy  %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

### Working with dates

- the `tidyverse` also has a package that makes working with dates easier: `lubridate`
  + the variable `date_entered` has the format year-month-day (`ymd`)
  + we can use `lubridate` verbs to extract the `year`, `month`, and `day`

```{r}
df_billboard_tidy <- df_billboard_tidy %>%
  mutate(
    month = month(date_entered, label = F),
    day = day(ymd(date_entered)),
    year = year(ymd(date_entered))
  ) 
```

### Plotting our tidy data

- now we have the `week` data in one variable and the `rank` data in another variable
- let's try to plot billboard ranks by week

```{r}
#| echo: false
#| label: fig-billboard
#| fig-cap: Billboard ranks by number of weeks for songs that were in the top 100 in the year 2000
df_billboard_tidy %>% 
  ggplot(aes(x = week, y = rank, group = track, colour = as_factor(year))) + 
  labs(title = "Duration (in weeks) that songs remained in the top 100 Billboard",
       x = "Number of weeks",
       y = "Rank",
       color = "Year") +
  geom_line(alpha = 0.25) + 
  scale_y_reverse() +
  theme_minimal()
```

- what is the most number of weeks a song was in the top 100?
- why is 100 at the bottom and 0 at the top?
- why is the bottom right quarter empty? What does this mean?

::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-help .custom}
::: nonincremental
1.  Recreate @fig-billboard.
:::
:::
:::

# Widening data: `df_cms`

- `pivot_wider()` make datasets *wider* by increasing columns and reducing rows
  + this helps when one observation is spread across multiple rows
  + this type of data isn't very common in the wild, but is pretty common in governmental data
  
---

- the `cms_patient_experience.csv` dataset contains data about patient experiences fom the Centers of Medicare and Medicaid services
- the core unit being studied is an organisation (stored in `org_pac_id` and `org_nm`), but each organisation (i.e., observation) takes up 6 rows
  + one row for each measure (i.e., variable)
  + so we want these variables to be represented in columns

```{r}
#| echo: false
df_cms %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

## `pivot_wider()`

- takes long data and makes it wider
- takes a few arguments:
  + `id_cols`: identifying columns
  + `names_from`: what should we call the new column containing the previous column names?
  + `names_prefix`: prefix for the new column names
  + `values_from`: new column values

---

- how can we, for each `org`, 
  + take the six values from `measure_cd` and create six new variable `names` `from` them,
  + and take the `values` `from` `prf_rate`?
- the result should look like @tbl-cms-wider

```{r}
#| code-fold: true
#| label: tbl-cms-wider
#| tbl-cap: Wider `df_cms` data (measure variable to columns with rating as values)
cms_patient_experience %>%  
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  ) %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

---

- @tbl-cms-long shows the first 6 rows of the original dataset

```{r}
#| echo: false
#| label: tbl-cms-long
#| tbl-cap: Original `cms_patient_experience.csv` format
cms_patient_experience %>% 
  head(n = 6) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20, full_width = F)
```

- @tbl-cms-tidy shows the first 6 rows of the widened dataset

```{r}
#| echo: false
#| label: tbl-cms-tidy
#| tbl-cap: Widened `cms_patient_experience.csv` format
cms_patient_experience %>%  
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  ) %>% 
  head(n = 6) %>% 
  knitr::kable(booktabs = T) %>% 
  kableExtra::kable_styling(font_size = 20, full_width = F)
```

- how is the data from @tbl-cms-long represented in @tbl-cms-tidy?

# Aufgabe

1. Browse the tracks. Choose a song you like (or a song at random), and then
    + filter the data to include only this song, and then
    + create a line plot of the song's time on the Top 100 Billboard
    + refer to the plot and describe the song's trend (you'd want to look at the song's data for this)

An example: *@fig-say-my-name shows the trend of 'Say My Name' by Destiny's child, which entered the charts on Dec. 25th, 1999 (`date_entered`) at number 83 (`rank` for `wk1`), and stayed on the top 100 for 32 weeks (`max(week)`).*

```{r}
#| echo: false
#| label: fig-say-my-name
#| fig-cap: Example linegraph for 'Say My Name' by Destiny's Child
df_billboard_tidy %>% 
  filter(track == "Say My Name") %>% 
  ggplot(aes(week, rank)) +
  labs(title = "'Say My Name' by Destiny's Child",
       x = "Number of weeks",
       y = "Rank") +
  geom_line() +
  theme_minimal()
```


2. Load the dataset `biondo_etal_2021_tidy.csv` (subset of data from @biondo_yesterday_2022) and save it as `df_biondo`
    + print a formatted table (using `knitr::kable()`) with a `label` and caption of the `head()` of the data

3. Lengthen the data so that the columns `rt` and `tt` are in one column:
    + the variable `names` should go `to` a new variable called `measure`
    + the variable `values` should go `to` a new variable `ms` (for milliseconds)
    + save the lengthened data as `df_biondo_long`
    + print a formatted table (using `knitr::kable()`) with a `label` and caption

4. Widen `df_biondo_long` so that the columns `rt` and `tt` are back in their own columns
    + the `id_cols` should be `subj` and `item`
    + the variable `names` should come `from` `measure`
    + the variable `values` should come `from` `ms` (for milliseconds)
    + save the lengthened data as `df_biondo_wide`
    + print a formatted table (using `knitr::kable()`) with a `label` and caption
    + tip: `df_biondo_wide` should be the exact same as `df_biondo`
  


# Heutige Ziele üèÅ {.unnumbered .unlisted}

Heute haben wir...

- learn about wide versus long data  ‚úÖ
- make wide data longer  ‚úÖ
- make long data wider  ‚úÖ
- review the `dplyr` verbs from week 3  ‚úÖ

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.3.0.386 (Cherry Blossom).

```{r}
sessionInfo()
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::