---
title: "Data Wrangling 2"
subtitle: "Data Tidying"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 8 - Data Tidying" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: wrangling2_blatt_DE.html
    include-after-body: custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
    execute:
      fig-width: 6
      fig-asp: .618
  revealjs: 
    output-file: wrangling2_folien_DE.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: false
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
    execute:
      fig-width: 6
      fig-asp: .618
  pdf:
    output-file: wrangling2_DE.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
    execute:
      out-width: "70%"
      fig-asp: .618
bibliography: references/references.bib
csl: references/apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_wrangling2_DE.qmd")
```

# Wiederholung {.unnumbered}

Letzte Woche haben wir gelernt, wie man...

- Code-Chunk-Optionen verwendet
- formatierte Tabellen druckt
- Abbildungsunterschriften hinzuf√ºgt
- die Gr√∂√üe von Abbildungen kontrolliert
- Querverweise erstellet

## Die √úbungen der letzten Woche {.unnumbered}

- Ich hatte einige Tippfehler in meiner Anleitung :(
  + `include: false` sollte `message: false` sein
  + `fig-out: 6` sollte `fig-width: 6` sein
  
- es gab einige allgemeine Probleme
  + z.B. das Setzen von globalen Optionen
  + `label`-Formatierung
  + fehlende Querverweise

# Heutige Ziele {.unnumbered}

Heute werden wir...

- lernen wir etwas √ºber breite und lange Daten
- breite Daten l√§nger machen
- lange Daten breiter machen

## Lust auf mehr? {.unnumbered}

- Ch. 6 ([Data tidying](https://r4ds.hadley.nz/data-tidy.html)) in @wickham_r_nodate
- Ch. 8 ([Data Tidying](https://psyteachr.github.io/ads-v2/08-tidy.html)) in @nordmann_applied_2022

# Einrichtung

- Pakete: `tidyverse`, `here`

```{r}
pacman::p_load(tidyverse,
               here)
```

- Daten (in `daten` Ordner):
  + `table1.csv`
  + `billboard.csv` (neu)
  + `cms_patient_experience.csv` (neu)

```{r}
#| echo: false
#| eval: false

# save built-in datasets as CSV, so students have to practice loading in CSVs

data(table1)
write.csv(table1, here::here("daten", "table1.csv"), row.names = F)

data(billboard)
df_billboard <- billboard %>% 
  janitor::clean_names()
write.csv(df_billboard, here::here("daten", "df_billboard.csv"), row.names = F)

data("cms_patient_experience")
df_cms <- cms_patient_experience %>% 
  janitor::clean_names()
write.csv(df_cms, here::here("daten", "cms_patient_experience.csv"), row.names = F)
```

```{r}
df_tb <- read_csv(here("daten", "table1.csv"))
df_billboard <- read_csv(here("daten", "df_billboard.csv"))
df_cms <- read_csv(here("daten", "cms_patient_experience.csv"))
```

# Aufger√§umter Arbeitsablauf (Tidy workflow)

- wir haben gelernt, wie man Daten importiert (`readr::read_csv`), transformiert (`dplyr` Paket) und visualisiert (`ggplot` Paket)
- Bisher haben wir immer mit aufger√§umten Daten gearbeitet
  + so dass wir den Schritt "tidy" nicht durchf√ºhren mussten

::: {.content-visible when-format="revealjs"}
```{r}
#| echo: false
#| out-width: "70%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_nodate (all rights reserved)"
magick::image_negate(magick::image_read(here::here("media/Wickham_tidyworkflow.png")))
```
:::

::: {.content-hidden when-format="revealjs"}
```{r}
#| echo: false
#| out-height: "100%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_nodate (all rights reserved)"
knitr::include_graphics(here::here("media/Wickham_tidyworkflow.png"))
```
:::

# Aufger√§umte Daten (tidy data)

- dieselben Daten k√∂nnen auf verschiedene Weise dargestellt werden
- Die folgenden Datens√§tze zeigen alle dieselben Werte f√ºr vier Variablen: `country`, `year`, `popuplation`, und `cases` (Anzahl) der Tuberkulosef√§lle
  + jeder Datensatz ordnet die Werte anders an

::: {.content-visible when-format="revealjs"}
:::: columns 
::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

::: {.column width="33%"}
```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

:::: 

:::


```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20,
    full_width = F
  )
```

- was ist am einfachsten zu lesen?

---

Drei Regeln f√ºr aufger√§umte Daten:

1.  Jede Variable ist eine Spalte, jede Spalte ist eine Variable
2.  Jede Beobachtung ist eine Zeile, jede Zeile ist eine Beobachtung
3.  Jeder Wert ist eine Zelle, jede Zelle ist ein Einzelwert

```{r}
#| echo: false
#| out-width: "90%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/data-tidy.html) @wickham_r_nodate (all rights reserved)"
knitr::include_graphics(here::here("media/Wickham_tidydata.png"))
```

- was als Beobachtung oder als Variable gilt, h√§ngt oft von der jeweiligen Aufgabe ab

## Why tidy data?

> "**Happy families** are all alike; every **unhappy family** is unhappy in its own way."
> --- Leo Tolstoy

> "**Tidy datasets** are all alike, but every **untidy dataset** is untidy in its own way."
> --- Hadley Wickham

- Die Bereinigung der Daten erfordert im Vorfeld einige Arbeit, ist aber auf lange Sicht hilfreich
- wenn wir einmal aufger√§umte Daten haben, werden wir weniger Zeit damit verbringen, die Daten in die richtige Form zu bringen, um das zu tun, was wir wollen

---

Die Arbeit mit aufger√§umten Daten hat zwei wesentliche Vorteile:

1. Die Arbeit mit einer konsistenten Datenstruktur erm√∂glicht es uns, Konventionen zu √ºbernehmen
    + Da aufger√§umte Daten die allgemein anerkannte Datenstruktur sind, basieren die Konventionen auf der Annahme dieser Struktur.
    + Werkzeuge haben also eine zugrundeliegende Einheitlichkeit
2. Die vektorisierte Natur von R kann gl√§nzen
    + Die meisten eingebauten R-Funktionen arbeiten mit *Vektorwerten*.
    + Alle Pakete im `tidyverse` sind f√ºr die Arbeit mit Tidy-Daten konzipiert

---

::: callout-note
## Vectors
Vektoren sind der grundlegendste Datenobjekttyp in R. Ein Vektor enth√§lt Daten desselben Typs und ist im Wesentlichen eine Liste. Wir k√∂nnen einen Vektor zum Beispiel mit der Funktion `c()` erstellen.

```{r}
vector1 <- c(2, 3, 4, 6, 7)
vector2 <- c(2, 3, 4, 6, "c")
```

`vector1` wird numerische Werte enthalten, da alle Elemente Zahlen sind. `vector2` enth√§lt alle Zeichenwerte (d.h. Text), da es ein einziges eindeutiges Zeichenelement (`c()`) gibt. R liest also alle Elemente als Zeichentyp. Wir k√∂nnen einen Datenrahmen aus Vektoren gleicher L√§nge erstellen, indem wir z. B. die Funktion `tibble()` verwenden.

```{r}
tibble(vector1,vector2)
```

:::

---

- die meisten Daten "in the wild" sind unordentlich
  + Die Daten werden h√§ufig zun√§chst f√ºr ein anderes Ziel als die Analyse organisiert
    + Dieses Ziel ist in der Regel die Dateneingabe: Wir wollen unsere Beobachtungen zun√§chst einfach dokumentieren k√∂nnen
  + die meisten Menschen sind nicht mit den Grunds√§tzen ordentlicher Daten vertraut, und erst nachdem sie *viel* Zeit mit Daten verbracht haben, wird klar, warum ordentliche Daten notwendig sind

- Dies bedeutet, dass die meisten *echten* Analysen zumindest ein gewisses Ma√ü an Aufr√§umen erfordern.

---

::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-tidy .custom}
::: nonincremental
1.  Geht zur√ºck zu den Tabellen 1-3. Beschreibt f√ºr jede Tabelle, was jede Beobachtung und jede Spalte darstellt.
2.  √úberlegt euch, wie ihr die Rate f√ºr Tabelle 1 berechnen w√ºrdet. Ihr braucht nur ein einziges Verb, das:
    + eine neue Variable (nennt sie `rate`) erzeugt, die enth√§lt:
      + die Anzahl der TB-`cases` pro Land und Jahr, geteilt durch
      + die entsprechende `population` pro Land und Jahr, 
      + multipliziert mit `10000`
    + Hinweis: Welches `dplyr`-Verb erzeugt neue Variablen? (Schaue in Woche 5 nach)
3.  Schaut euch die Tabellen 2 und 3 an. W√§re es so einfach gewesen, die "Rate" mit diesen Datenstrukturen zu berechnen?

:::
:::
:::

## Daten aufr√§umen

- Umformung
    - z.B. von breiten zu langen Daten
- Ergebnis:
    - jede Spalte = eine Variable
    - jede Zeile = eine Beobachtung
    
### Datenaufr√§umung mit dem `tidyverse`

- mit dem `tidyr`-Paket
  - `pivot_longer()`: macht breite Daten l√§nger
  - `pivot_wider()`: lange Daten breiter machen
  
- wir m√ºssen oft zwischen diesen Formaten konvertieren, um verschiedene Arten von Zusammenfassungen oder Visualisierungen zu erstellen

---

::: {.content-hidden when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="100%"}
#| fig-cap-location: bottom
#| label: fig-pivot-html
#| fig-cap: die ber√ºhmteste Verwendung des Wortes Pivot (zumindest f√ºr Millenials) ([Friends](https://www.youtube.com/watch?v=8w3wmQAMoxQ))
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

::: {.content-visible when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="50%"}
#| fig-cap-location: bottom
#| label: fig-pivot-pdf
#| fig-cap: die ber√ºhmteste Verwendung des Wortes Pivot (zumindest f√ºr Millenials)
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

### Breite versus lange Daten

- Breite Daten: alle Beobachtungen zu einer Sache stehen in derselben Zeile
  + breite Daten sind *normalerweise* nicht 'tidy'
- lange Daten: jede Beobachtung steht in einer eigenen Zeile
  + lange Daten sind *in der Regel* 'tidy'
  
# Verl√§ngern von Daten: `df_billboard`

- in dem Datensatz `billboard.csv`
  - jede Zeile ist ein Lied
  - die ersten drei Spalten sind Variablen, die den Song beschreiben (`artist`, `track`, `date_entered`)
  - wir haben 76 Spalten (`wk1-wk76`), die den Rang des Liedes in dieser Woche beschreiben
    + Die Spaltennamen sind eine Variable (die `week`), und die Zellwerte sind eine andere Variable (der `rank`)

---

```{r}
#| label: tbl-df_billboard
#| tbl-cap: df_billboard rank of songs in the year 2000
df_billboard %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

- Sind die Daten in @tbl-df_billboard aufger√§umt?
- Sind diese Daten zu breit oder zu lang?
- Wie k√∂nnen wir diese Daten bereinigen?

## `pivot_longer()` {.smaller}

- `pivot_longer()`
  + wandelt eine breite Datentabelle in ein l√§ngeres Format um, indem es die √úberschriften der angegebenen Spalten in die Werte neuer Spalten umwandelt
  + und die Werte dieser Spalten in einer neuen komprimierten Spalte kombiniert
  
:::: columns

::: {.column width="50%"}

```{r}
#| echo: true
df_billboard_tidy <- df_billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
```


- `col = ` gibt an, welche Spalten gedreht werden m√ºssen (d.h. welche *nicht* Variablen sind)
  + hat die gleiche Syntax wie `select()`, wir k√∂nnten also z.B. `starts_with("")` verwenden
- `names_to =` benennt die Variable, die in den aktuellen Spaltennamen gespeichert ist, hier ist es `week`
- `values_to =` benennt die in den Zellwerten gespeicherte Variable, die wir `rank` nennen
- N.B., wir mussten `week` und `rank` in Anf√ºhrungszeichen setzen, weil sie noch keine Variablennamen sind

:::

::: {.column width="50%"}
```{r}
#| echo: false
#| label: tbl-longer
#| tbl-cap: A pivoted version of `df_billboard` (first 10 rows)
df_billboard_tidy %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::

::::

### Entfernen fehlender Werte (`NA`)

- wir haben ein paar `NA` (fehlende) Werte; dies geschah, wenn ein Song nicht in den Top 100 war
  + Mit dem Argument `values_drop_na = TRUE/FALSE` werden geschwenkte Zeilen gel√∂scht, die keinen Wert f√ºr die neue Variable haben.

:::: columns

::: {.column width="50%"}
```{r}
df_billboard_tidy <- df_billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  ) 
```
- Wie viele Zeilen weniger haben wir jetzt?
:::
::: {.column width="50%"}
```{r}
#| echo: false
#| label: tbl-billboard-tidy
#| tbl-cap: Tidy `df_billboard` data with dropped `NA` values
df_billboard_tidy %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::
::::


### Parsing Zahlen

- die Daten sind jetzt ordentlich, aber `week` enth√§lt immer noch `wk` in den Werten
- Das Paket `readr` hat eine praktische Funktion: `parse_number()` extrahiert die erste Zahl aus einer Zeichenkette und ignoriert alle anderen Texte
  + Wie k√∂nnten wir `parse_number()` benutzen, um die Variable `week` zu *√§ndern*?

```{r}
#| code-fold: true
#| output-location: column
df_billboard_tidy <- df_billboard_tidy %>% 
  mutate(week = parse_number(week))
```

```{r}
#| echo: false
#| label: tbl-billboard-tidy-NA
#| tbl-cap: Tidy `df_billboard` data with dropped `NA` values
df_billboard_tidy  %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

### Arbeiten mit Datumsangaben

- Das `tidyverse` hat auch ein Paket, das die Arbeit mit Datumsangaben erleichtert: `lubridate`
  + die Variable `date_entered` hat das Format Jahr-Monat-Tag (`ymd`)
  + Wir k√∂nnen `lubridate` Verben verwenden, um das `year`, den `month` und den `day` zu extrahieren

```{r}
df_billboard_tidy <- df_billboard_tidy %>%
  mutate(
    month = month(date_entered, label = F),
    day = day(ymd(date_entered)),
    year = year(ymd(date_entered))
  ) 
```

### Plotten unserer aufger√§umten Daten {.smaller}

- Jetzt haben wir die `week`-Daten in einer Variablen und die `rank` Daten in einer anderen Variablen
- Versuchen wir nun, die R√§nge der Plakate nach Woche darzustellen

:::: columns

::: {.column width="50%"}

```{r}
#| echo: false
#| label: fig-billboard
#| fig-cap: Billboard ranks by number of weeks for songs that were in the top 100 in the year 2000

df_billboard_tidy %>% 
  ggplot(aes(x = week, y = rank, group = track, colour = as_factor(year))) + 
  labs(title = "Duration (in weeks) that songs remained in the top 100 Billboard",
       x = "Number of weeks",
       y = "Rank",
       color = "Year") +
  geom_line(alpha = 0.25) + 
  scale_y_reverse() +
  theme_minimal()
```
:::

::: {.column width="50%"}
- Wie viele Wochen war ein Lied am l√§ngsten in den Top 100?
- Warum ist 100 unten und 0 oben?
- Warum ist das untere rechte Viertel leer? Was bedeutet das?
:::
::::
---

::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-help .custom}
::: nonincremental
1.  Erstellt @fig-billboard neu.
:::
:::
:::

# Widening data: `df_cms`

- `pivot_wider()` macht Datens√§tze *breiter*, indem es Spalten vergr√∂√üert und Zeilen verkleinert
  + Dies ist hilfreich, wenn eine Beobachtung √ºber mehrere Zeilen verteilt ist.
  + Diese Art von Daten ist in der freien Wildbahn nicht sehr h√§ufig, aber in Regierungsdaten ist sie ziemlich verbreitet.
  
---

- der Datensatz `cms_patient_experience.csv` enth√§lt Daten √ºber Patientenerfahrungen von den Centers of Medicare and Medicaid Services
- die untersuchte Kerneinheit ist eine Organisation (gespeichert in `org_pac_id` und `org_nm`), aber jede Organisation (d.h. Beobachtung) nimmt 6 Zeilen ein
  + eine Zeile f√ºr jede Ma√ünahme (d. h. Variable)
  + Wir wollen also, dass diese Variablen in Spalten dargestellt werden

```{r}
#| echo: false
df_cms %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

## `pivot_wider()`

- nimmt lange Daten und macht sie breiter
- ben√∂tigt einige Argumente:
  + `id_cols`: identifizierende Spalten
  + `names_from`: wie soll die neue Spalte hei√üen, die die bisherigen Spaltennamen enth√§lt?
  + `names_prefix`: Pr√§fix f√ºr die neuen Spaltennamen
  + `values_from`: neue Spaltenwerte

---

- Wie k√∂nnen wir f√ºr jede `org`, 
  + die sechs Werte aus `measure_cd` nehmen und sechs neue Variablen `names` daraus erstellen,
  + und die `values` aus `prf_rate` nehmen?
- das Ergebnis sollte wie @tbl-cms-wider aussehen

```{r}
#| code-fold: true
#| label: tbl-cms-wider
#| tbl-cap: Wider `df_cms` data (measure variable to columns with rating as values)
cms_patient_experience %>%  
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  ) %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

---

- @tbl-cms-long zeigt die ersten 6 Zeilen des Originaldatensatzes

```{r}
#| echo: false
#| label: tbl-cms-long
#| tbl-cap: Original `cms_patient_experience.csv` format
cms_patient_experience %>% 
  head(n = 6) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20, full_width = F)
```

- @tbl-cms-tidy zeigt die ersten 6 Zeilen des erweiterten Datensatzes

```{r}
#| echo: false
#| label: tbl-cms-tidy
#| tbl-cap: Widened `cms_patient_experience.csv` format
cms_patient_experience %>%  
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  ) %>% 
  head(n = 6) %>% 
  knitr::kable(booktabs = T) %>% 
  kableExtra::kable_styling(font_size = 20, full_width = F)
```

- Wie werden die Daten aus @tbl-cms-long in @tbl-cms-tidy dargestellt?

# Aufgabe {.smaller}

::: nonincremental

1. Durchsucht die Titel. W√§hlt einen Titel, der euch gef√§llt (oder einen zuf√§lligen Titel), und dann
    + filtert die Daten so, dass sie nur diesen Titel enthalten, und dann
    + Erstellt ein Liniendiagramm der Zeit des Liedes in den Top 100 Billboard
    + Bezieht sich auf das Diagramm und beschreibt den Trend des Liedes (dazu solltet euch die Daten des Liedes ansehen).

Ein Beispiel: *@fig-say-my-name zeigt den Trend von 'Say My Name' von Destiny's Child, das am 25. Dezember 1999 (`date_entered`) auf Platz 83 (`rank` f√ºr `wk1`) in die Charts einstieg und 32 Wochen lang in den Top 100 blieb (z.b., `max(week)`).*

```{r}
#| echo: false
#| output-location: slide
#| label: fig-say-my-name
#| fig-cap: Example linegraph for 'Say My Name' by Destiny's Child
df_billboard_tidy %>% 
  filter(track == "Say My Name") %>% 
  ggplot(aes(week, rank)) +
  labs(title = "'Say My Name' by Destiny's Child",
       x = "Number of weeks",
       y = "Rank") +
  geom_line() +
  theme_minimal()
```

:::

---

::: nonincremental


2. L√§dt den Datensatz `biondo_etal_2021_tidy.csv` (Teilmenge der Daten von @biondo_yesterday_2022) und speichert ihn als `df_biondo`
  + druckt eine formatierte Tabelle (mit `knitr::kable()`) mit einem `Label` und einer Beschriftung des `Kopfes()` der Daten

:::

---

::: nonincremental

3. Verl√§ngere die Daten so, dass die Spalten `rt` und `tt` in einer Spalte stehen:
    + Die Variable `Namen` sollte in eine neue Variable mit dem Namen `Ma√ü` √ºbergehen.
    + Die Variable "Werte" geht in eine neue Variable "ms" (f√ºr Millisekunden) √ºber.
    + Speichern der verl√§ngerten Daten als `df_biondo_long`
+ druckt eine formatierte Tabelle (mit `knitr::kable()`) mit einem `Label` und einer Beschriftung

:::

---

::: nonincremental

4. Erweitert `df_biondo_long` so, dass die Spalten `rt` und `tt` wieder in ihren eigenen Spalten sind
    + die `id_cols` sollten `subj` und `item` sein
    + die Variable `Namen` sollte `von` `Ma√ü` kommen
    + die Variable `values` sollte von `ms` (f√ºr Millisekunden) stammen
    + die verl√§ngerten Daten als `df_biondo_wide` speichern
    + eine formatierte Tabelle (mit `knitr::kable()`) mit einem `Label` und einer Beschriftung ausgeben
    + Tipp: `df_biondo_wide` sollte genau dasselbe sein wie `df_biondo`.
  
:::

# Heutige Ziele üèÅ {.unnumbered .unlisted}

Heute haben wir...

- etwas √ºber breite und lange Daten lernen ‚úÖ
- breite Daten l√§nger machen ‚úÖ
- lange Daten breiter machen ‚úÖ

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.3.0.386 (Cherry Blossom).

```{r}
sessionInfo()
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::