---
title: "Data Wrangling 2"
subtitle: "Data Tidying"
author: "Daniela Palleschi"
institute: Humboldt-Universität zu Berlin
footer: "Woche 8 - Data Tidying" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: wrangling2_blatt_DE.html
    include-after-body: custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
    execute:
      fig-width: 6
      fig-asp: .618
  revealjs: 
    output-file: wrangling2_folien_DE.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: false
    toc-depth: 1
    toc-title: 'Überblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
    execute:
      fig-width: 6
      fig-asp: .618
  pdf:
    output-file: wrangling2_DE.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
    execute:
      out-width: "70%"
      fig-asp: .618
bibliography: references/references.bib
csl: references/apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_wrangling2_DE.qmd")
```

# Wiederholung {.unnumbered}

Letzte Woche haben wir gelernt, wie man...

- Code-Chunk-Optionen verwendet
- formatierte Tabellen druckt
- Abbildungsunterschriften hinzufügt
- die Größe von Abbildungen kontrolliert
- Querverweise erstellet

## Die Übungen der letzten Woche {.unnumbered}

- Ich hatte einige Tippfehler in meiner Anleitung :(
  + `include: false` sollte `message: false` sein
  + `fig-out: 6` sollte `fig-width: 6` sein
  
- es gab einige allgemeine Probleme
  + z.B. das Setzen von globalen Optionen
  + `label`-Formatierung
  + fehlende Querverweise

# Heutige Ziele {.unnumbered}

Heute werden wir...

- lernen wir etwas über breite und lange Daten
- breite Daten länger machen
- lange Daten breiter machen

## Lust auf mehr? {.unnumbered}

- Ch. 6 ([Data tidying](https://r4ds.hadley.nz/data-tidy.html)) in @wickham_r_nodate
- Ch. 8 ([Data Tidying](https://psyteachr.github.io/ads-v2/08-tidy.html)) in @nordmann_applied_2022

# Einrichtung

- Pakete: `tidyverse`, `here`

```{r}
pacman::p_load(tidyverse,
               here)
```

- Daten (in `daten` Ordner):
  + `table1.csv`
  + `billboard.csv` (neu)
  + `cms_patient_experience.csv` (neu)

```{r}
#| echo: false
#| eval: false

# save built-in datasets as CSV, so students have to practice loading in CSVs

data(table1)
write.csv(table1, here::here("daten", "table1.csv"), row.names = F)

data(billboard)
df_billboard <- billboard %>% 
  janitor::clean_names()
write.csv(df_billboard, here::here("daten", "df_billboard.csv"), row.names = F)

data("cms_patient_experience")
df_cms <- cms_patient_experience %>% 
  janitor::clean_names()
write.csv(df_cms, here::here("daten", "cms_patient_experience.csv"), row.names = F)
```

```{r}
df_tb <- read_csv(here("daten", "table1.csv"))
df_billboard <- read_csv(here("daten", "df_billboard.csv"))
df_cms <- read_csv(here("daten", "cms_patient_experience.csv"))
```

# Aufgeräumter Arbeitsablauf (Tidy workflow)

- wir haben gelernt, wie man Daten importiert (`readr::read_csv`), transformiert (`dplyr` Paket) und visualisiert (`ggplot` Paket)
- Bisher haben wir immer mit aufgeräumten Daten gearbeitet
  + so dass wir den Schritt "tidy" nicht durchführen mussten

::: {.content-visible when-format="revealjs"}
```{r}
#| echo: false
#| out-width: "70%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_nodate (all rights reserved)"
magick::image_negate(magick::image_read(here::here("media/Wickham_tidyworkflow.png")))
```
:::

::: {.content-hidden when-format="revealjs"}
```{r}
#| echo: false
#| out-height: "100%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_nodate (all rights reserved)"
knitr::include_graphics(here::here("media/Wickham_tidyworkflow.png"))
```
:::

# Aufgeräumte Daten (tidy data)

- dieselben Daten können auf verschiedene Weise dargestellt werden
- Die folgenden Datensätze zeigen alle dieselben Werte für vier Variablen: `country`, `year`, `popuplation`, und `cases` (Anzahl) der Tuberkulosefälle
  + jeder Datensatz ordnet die Werte anders an

::: {.content-visible when-format="revealjs"}
:::: columns 
::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

::: {.column width="33%"}
```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```
:::

:::: 

:::


```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20,
    full_width = F
  )
```

- was ist am einfachsten zu lesen?

---

Drei Regeln für aufgeräumte Daten:

1.  Jede Variable ist eine Spalte, jede Spalte ist eine Variable
2.  Jede Beobachtung ist eine Zeile, jede Zeile ist eine Beobachtung
3.  Jeder Wert ist eine Zelle, jede Zelle ist ein Einzelwert

```{r}
#| echo: false
#| out-width: "90%"
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/data-tidy.html) @wickham_r_nodate (all rights reserved)"
knitr::include_graphics(here::here("media/Wickham_tidydata.png"))
```

- was als Beobachtung oder als Variable gilt, hängt oft von der jeweiligen Aufgabe ab

## Why tidy data?

> "**Happy families** are all alike; every **unhappy family** is unhappy in its own way."
> --- Leo Tolstoy

> "**Tidy datasets** are all alike, but every **untidy dataset** is untidy in its own way."
> --- Hadley Wickham

- Die Bereinigung der Daten erfordert im Vorfeld einige Arbeit, ist aber auf lange Sicht hilfreich
- wenn wir einmal aufgeräumte Daten haben, werden wir weniger Zeit damit verbringen, die Daten in die richtige Form zu bringen, um das zu tun, was wir wollen

---

Die Arbeit mit aufgeräumten Daten hat zwei wesentliche Vorteile:

1. Die Arbeit mit einer konsistenten Datenstruktur ermöglicht es uns, Konventionen zu übernehmen
    + Da aufgeräumte Daten die allgemein anerkannte Datenstruktur sind, basieren die Konventionen auf der Annahme dieser Struktur.
    + Werkzeuge haben also eine zugrundeliegende Einheitlichkeit
2. Die vektorisierte Natur von R kann glänzen
    + Die meisten eingebauten R-Funktionen arbeiten mit *Vektorwerten*.
    + Alle Pakete im `tidyverse` sind für die Arbeit mit Tidy-Daten konzipiert

---

::: callout-note
## Vectors
Vektoren sind der grundlegendste Datenobjekttyp in R. Ein Vektor enthält Daten desselben Typs und ist im Wesentlichen eine Liste. Wir können einen Vektor zum Beispiel mit der Funktion `c()` erstellen.

```{r}
vector1 <- c(2, 3, 4, 6, 7)
vector2 <- c(2, 3, 4, 6, "c")
```

`vector1` wird numerische Werte enthalten, da alle Elemente Zahlen sind. `vector2` enthält alle Zeichenwerte (d.h. Text), da es ein einziges eindeutiges Zeichenelement (`c()`) gibt. R liest also alle Elemente als Zeichentyp. Wir können einen Datenrahmen aus Vektoren gleicher Länge erstellen, indem wir z. B. die Funktion `tibble()` verwenden.

```{r}
tibble(vector1,vector2)
```

:::

---

- die meisten Daten "in the wild" sind unordentlich
  + Die Daten werden häufig zunächst für ein anderes Ziel als die Analyse organisiert
    + Dieses Ziel ist in der Regel die Dateneingabe: Wir wollen unsere Beobachtungen zunächst einfach dokumentieren können
  + die meisten Menschen sind nicht mit den Grundsätzen ordentlicher Daten vertraut, und erst nachdem sie *viel* Zeit mit Daten verbracht haben, wird klar, warum ordentliche Daten notwendig sind

- Dies bedeutet, dass die meisten *echten* Analysen zumindest ein gewisses Maß an Aufräumen erfordern.

---

::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-tidy .custom}
::: nonincremental
1.  Geht zurück zu den Tabellen 1-3. Beschreibt für jede Tabelle, was jede Beobachtung und jede Spalte darstellt.
2.  Überlegt euch, wie ihr die Rate für Tabelle 1 berechnen würdet. Ihr braucht nur ein einziges Verb, das:
    + eine neue Variable (nennt sie `rate`) erzeugt, die enthält:
      + die Anzahl der TB-`cases` pro Land und Jahr, geteilt durch
      + die entsprechende `population` pro Land und Jahr, 
      + multipliziert mit `10000`
    + Hinweis: Welches `dplyr`-Verb erzeugt neue Variablen? (Schaue in Woche 5 nach)
3.  Schaut euch die Tabellen 2 und 3 an. Wäre es so einfach gewesen, die "Rate" mit diesen Datenstrukturen zu berechnen?

:::
:::
:::

## Daten aufräumen

- Umformung
    - z.B. von breiten zu langen Daten
- Ergebnis:
    - jede Spalte = eine Variable
    - jede Zeile = eine Beobachtung
    
### Datenaufräumung mit dem `tidyverse`

- mit dem `tidyr`-Paket
  - `pivot_longer()`: macht breite Daten länger
  - `pivot_wider()`: lange Daten breiter machen
  
- wir müssen oft zwischen diesen Formaten konvertieren, um verschiedene Arten von Zusammenfassungen oder Visualisierungen zu erstellen

---

::: {.content-hidden when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="100%"}
#| fig-cap-location: bottom
#| label: fig-pivot-html
#| fig-cap: die berühmteste Verwendung des Wortes Pivot (zumindest für Millenials) ([Friends](https://www.youtube.com/watch?v=8w3wmQAMoxQ))
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

::: {.content-visible when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="50%"}
#| fig-cap-location: bottom
#| label: fig-pivot-pdf
#| fig-cap: die berühmteste Verwendung des Wortes Pivot (zumindest für Millenials)
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

### Breite versus lange Daten

- Breite Daten: alle Beobachtungen zu einer Sache stehen in derselben Zeile
  + breite Daten sind *normalerweise* nicht 'tidy'
- lange Daten: jede Beobachtung steht in einer eigenen Zeile
  + lange Daten sind *in der Regel* 'tidy'
  
# Verlängern von Daten: `df_billboard`

- in dem Datensatz `billboard.csv`
  - jede Zeile ist ein Lied
  - die ersten drei Spalten sind Variablen, die den Song beschreiben (`artist`, `track`, `date_entered`)
  - wir haben 76 Spalten (`wk1-wk76`), die den Rang des Liedes in dieser Woche beschreiben
    + Die Spaltennamen sind eine Variable (die `week`), und die Zellwerte sind eine andere Variable (der `rank`)

---

```{r}
#| label: tbl-df_billboard
#| tbl-cap: df_billboard rank of songs in the year 2000
df_billboard %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

- Sind die Daten in @tbl-df_billboard aufgeräumt?
- Sind diese Daten zu breit oder zu lang?
- Wie können wir diese Daten bereinigen?

## `pivot_longer()` {.smaller}

- `pivot_longer()`
  + wandelt eine breite Datentabelle in ein längeres Format um, indem es die Überschriften der angegebenen Spalten in die Werte neuer Spalten umwandelt
  + und die Werte dieser Spalten in einer neuen komprimierten Spalte kombiniert
  
:::: columns

::: {.column width="50%"}

```{r}
#| echo: true
df_billboard_tidy <- df_billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
```


- `col = ` gibt an, welche Spalten gedreht werden müssen (d.h. welche *nicht* Variablen sind)
  + hat die gleiche Syntax wie `select()`, wir könnten also z.B. `starts_with("")` verwenden
- `names_to =` benennt die Variable, die in den aktuellen Spaltennamen gespeichert ist, hier ist es `week`
- `values_to =` benennt die in den Zellwerten gespeicherte Variable, die wir `rank` nennen
- N.B., wir mussten `week` und `rank` in Anführungszeichen setzen, weil sie noch keine Variablennamen sind

:::

::: {.column width="50%"}
```{r}
#| echo: false
#| label: tbl-longer
#| tbl-cap: A pivoted version of `df_billboard` (first 10 rows)
df_billboard_tidy %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::

::::

### Entfernen fehlender Werte (`NA`)

- wir haben ein paar `NA` (fehlende) Werte; dies geschah, wenn ein Song nicht in den Top 100 war
  + Mit dem Argument `values_drop_na = TRUE/FALSE` werden geschwenkte Zeilen gelöscht, die keinen Wert für die neue Variable haben.

:::: columns

::: {.column width="50%"}
```{r}
df_billboard_tidy <- df_billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  ) 
```
- Wie viele Zeilen weniger haben wir jetzt?
:::
::: {.column width="50%"}
```{r}
#| echo: false
#| label: tbl-billboard-tidy
#| tbl-cap: Tidy `df_billboard` data with dropped `NA` values
df_billboard_tidy %>% 
  head(n = 10) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::
::::


### Parsing Zahlen

- die Daten sind jetzt ordentlich, aber `week` enthält immer noch `wk` in den Werten
- Das Paket `readr` hat eine praktische Funktion: `parse_number()` extrahiert die erste Zahl aus einer Zeichenkette und ignoriert alle anderen Texte
  + Wie könnten wir `parse_number()` benutzen, um die Variable `week` zu *ändern*?

```{r}
#| code-fold: true
#| output-location: column
df_billboard_tidy <- df_billboard_tidy %>% 
  mutate(week = parse_number(week))
```

```{r}
#| echo: false
#| label: tbl-billboard-tidy-NA
#| tbl-cap: Tidy `df_billboard` data with dropped `NA` values
df_billboard_tidy  %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

### Arbeiten mit Datumsangaben

- Das `tidyverse` hat auch ein Paket, das die Arbeit mit Datumsangaben erleichtert: `lubridate`
  + die Variable `date_entered` hat das Format Jahr-Monat-Tag (`ymd`)
  + Wir können `lubridate` Verben verwenden, um das `year`, den `month` und den `day` zu extrahieren

```{r}
df_billboard_tidy <- df_billboard_tidy %>%
  mutate(
    month = month(date_entered, label = F),
    day = day(ymd(date_entered)),
    year = year(ymd(date_entered))
  ) 
```

### Plotten unserer aufgeräumten Daten {.smaller}

- Jetzt haben wir die `week`-Daten in einer Variablen und die `rank` Daten in einer anderen Variablen
- Versuchen wir nun, die Ränge der Plakate nach Woche darzustellen

:::: columns

::: {.column width="50%"}

```{r}
#| echo: false
#| label: fig-billboard
#| fig-cap: Billboard ranks by number of weeks for songs that were in the top 100 in the year 2000

df_billboard_tidy %>% 
  ggplot(aes(x = week, y = rank, group = track, colour = as_factor(year))) + 
  labs(title = "Duration (in weeks) that songs remained in the top 100 Billboard",
       x = "Number of weeks",
       y = "Rank",
       color = "Year") +
  geom_line(alpha = 0.25) + 
  scale_y_reverse() +
  theme_minimal()
```
:::

::: {.column width="50%"}
- Wie viele Wochen war ein Lied am längsten in den Top 100?
- Warum ist 100 unten und 0 oben?
- Warum ist das untere rechte Viertel leer? Was bedeutet das?
:::
::::
---

::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-help .custom}
::: nonincremental
1.  Erstellt @fig-billboard neu.
:::
:::
:::

# Widening data: `df_cms`

- `pivot_wider()` macht Datensätze *breiter*, indem es Spalten vergrößert und Zeilen verkleinert
  + Dies ist hilfreich, wenn eine Beobachtung über mehrere Zeilen verteilt ist.
  + Diese Art von Daten ist in der freien Wildbahn nicht sehr häufig, aber in Regierungsdaten ist sie ziemlich verbreitet.
  
---

- der Datensatz `cms_patient_experience.csv` enthält Daten über Patientenerfahrungen von den Centers of Medicare and Medicaid Services
- die untersuchte Kerneinheit ist eine Organisation (gespeichert in `org_pac_id` und `org_nm`), aber jede Organisation (d.h. Beobachtung) nimmt 6 Zeilen ein
  + eine Zeile für jede Maßnahme (d. h. Variable)
  + Wir wollen also, dass diese Variablen in Spalten dargestellt werden

```{r}
#| echo: false
df_cms %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

## `pivot_wider()`

- nimmt lange Daten und macht sie breiter
- benötigt einige Argumente:
  + `id_cols`: identifizierende Spalten
  + `names_from`: wie soll die neue Spalte heißen, die die bisherigen Spaltennamen enthält?
  + `names_prefix`: Präfix für die neuen Spaltennamen
  + `values_from`: neue Spaltenwerte

---

- Wie können wir für jede `org`, 
  + die sechs Werte aus `measure_cd` nehmen und sechs neue Variablen `names` daraus erstellen,
  + und die `values` aus `prf_rate` nehmen?
- das Ergebnis sollte wie @tbl-cms-wider aussehen

```{r}
#| code-fold: true
#| label: tbl-cms-wider
#| tbl-cap: Wider `df_cms` data (measure variable to columns with rating as values)
cms_patient_experience %>%  
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  ) %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```

---

- @tbl-cms-long zeigt die ersten 6 Zeilen des Originaldatensatzes

```{r}
#| echo: false
#| label: tbl-cms-long
#| tbl-cap: Original `cms_patient_experience.csv` format
cms_patient_experience %>% 
  head(n = 6) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20, full_width = F)
```

- @tbl-cms-tidy zeigt die ersten 6 Zeilen des erweiterten Datensatzes

```{r}
#| echo: false
#| label: tbl-cms-tidy
#| tbl-cap: Widened `cms_patient_experience.csv` format
cms_patient_experience %>%  
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  ) %>% 
  head(n = 6) %>% 
  knitr::kable(booktabs = T) %>% 
  kableExtra::kable_styling(font_size = 20, full_width = F)
```

- Wie werden die Daten aus @tbl-cms-long in @tbl-cms-tidy dargestellt?

# Aufgabe {.smaller}

::: nonincremental

1. Durchsucht die Titel. Wählt einen Titel, der euch gefällt (oder einen zufälligen Titel), und dann
    + filtert die Daten so, dass sie nur diesen Titel enthalten, und dann
    + Erstellt ein Liniendiagramm der Zeit des Liedes in den Top 100 Billboard
    + Bezieht sich auf das Diagramm und beschreibt den Trend des Liedes (dazu solltet euch die Daten des Liedes ansehen).

Ein Beispiel: *@fig-say-my-name zeigt den Trend von 'Say My Name' von Destiny's Child, das am 25. Dezember 1999 (`date_entered`) auf Platz 83 (`rank` für `wk1`) in die Charts einstieg und 32 Wochen lang in den Top 100 blieb (z.b., `max(week)`).*

```{r}
#| echo: false
#| output-location: slide
#| label: fig-say-my-name
#| fig-cap: Example linegraph for 'Say My Name' by Destiny's Child
df_billboard_tidy %>% 
  filter(track == "Say My Name") %>% 
  ggplot(aes(week, rank)) +
  labs(title = "'Say My Name' by Destiny's Child",
       x = "Number of weeks",
       y = "Rank") +
  geom_line() +
  theme_minimal()
```

:::

---

::: nonincremental


2. Lädt den Datensatz `biondo_etal_2021_tidy.csv` (Teilmenge der Daten von @biondo_yesterday_2022) und speichert ihn als `df_biondo`
  + druckt eine formatierte Tabelle (mit `knitr::kable()`) mit einem `Label` und einer Beschriftung des `Kopfes()` der Daten

:::

---

::: nonincremental

3. Verlängere die Daten so, dass die Spalten `rt` und `tt` in einer Spalte stehen:
    + Die Variable `Namen` sollte in eine neue Variable mit dem Namen `Maß` übergehen.
    + Die Variable "Werte" geht in eine neue Variable "ms" (für Millisekunden) über.
    + Speichern der verlängerten Daten als `df_biondo_long`
+ druckt eine formatierte Tabelle (mit `knitr::kable()`) mit einem `Label` und einer Beschriftung

:::

---

::: nonincremental

4. Erweitert `df_biondo_long` so, dass die Spalten `rt` und `tt` wieder in ihren eigenen Spalten sind
    + die `id_cols` sollten `subj` und `item` sein
    + die Variable `Namen` sollte `von` `Maß` kommen
    + die Variable `values` sollte von `ms` (für Millisekunden) stammen
    + die verlängerten Daten als `df_biondo_wide` speichern
    + eine formatierte Tabelle (mit `knitr::kable()`) mit einem `Label` und einer Beschriftung ausgeben
    + Tipp: `df_biondo_wide` sollte genau dasselbe sein wie `df_biondo`.
  
:::

# Heutige Ziele 🏁 {.unnumbered .unlisted}

Heute haben wir...

- etwas über breite und lange Daten lernen ✅
- breite Daten länger machen ✅
- lange Daten breiter machen ✅

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.3.0.386 (Cherry Blossom).

```{r}
sessionInfo()
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::