---
title: "Datatransformation"
subtitle: "Zeilen und Spalten √§ndern"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 5 - Datatransformation" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: wrangling1_blatt_DE.html
    include-after-body: custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
  revealjs: 
    output-file: wrangling1_folien_DE.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: true
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
  pdf:
    output-file: wrangling1_DE.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
bibliography: references/references.bib
csl: references/apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_wrangling1_DE.qmd")
```

# Wiederholung {.unnumbered}

Letze Woche haben wir...

- gelernt, wie man einen neuen Datensatz in Augenschein nimmt
- gelernt, wie man verschiedene Datentypen importiert
- gelernt, wie man Daten von Hand eingibt
- einen neuen Datensatz visualisiert

# Heutige Ziele {.unnumbered}

Heute werden wir...

- lernen, wie man Daten mit dem Paket `dplyr` aus dem `tidyverse` verarbeitet
- lernen, wie man die `pipe` (` %>% `) benutzt, um das Ergebnis einer Funktion in eine andere Funktion zu √ºbertragen
- Funktionen kennenlernen, die auf Zeilen operieren
- Funktionen kennenlernen, die mit Spalten arbeiten
- lernen, wie man `dplyr`-Funktionen mit Plots von `ggplot2` kombiniert

## Lust auf mehr? {.unnumbered .unlisted}

- [Ch. 4](https://r4ds.hadley.nz/data-transform.html) in @wickham_r_nodate
- [Ch. 9](https://psyteachr.github.io/ads-v2/09-wrangle.html) in @nordmann_applied_2022

# Pre-requisites

1. Frisches Quarto-Dokument
    - ein neues Quarto-Dokument f√ºr den heutigen Unterricht erstellen
      - Datei > Neues Dokument > Quarto Dokument, mit dem Namen `04-wrangling`
    - YAML einrichten: Titel, Ihr Name, ein `toc` hinzuf√ºgen

```{r}
#| eval: false
#| code-line-numbers: false
title: "Datatransformation"
subtitle: "Woche 5"
author: "Your name here"
lang: de
format: 
  html:
    toc: true
```

::: {.content-visible when-format="revealjs"}
## Einrichtung {.unlisted .unnumbered}
:::

2. Pakete
    - Die heutigen Pakete sind:
      - `tidyverse`: zum Verarbeiten (`dplyr`) und Plotten (`ggplot2`)

```{r}
pacman::p_load("tidyverse")
```

```{r}
#| eval: false
#| echo: false
# just need this to create flights.csv
library(nycflights13)
```

3. Datensatz
    - Speichern Sie den Datensatz aus Moodle in Ihrem Ordner `daten`:
      - `flights.csv`

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Renderpr√ºfung!
::: nonincremental
Nehmt euch einen Moment Zeit, um euer Dokument zu rendern. Wurde es gerendert?

- Hat es einen Titel?
- Steht Ihr Name drin?
- Hat es eine √úberschrift f√ºr 'Pakete'?
- F√ºgen Sie eine √úberschrift f√ºr 'Data Wrangling' hinzu

:::

:::

:::

# Data Wrangling (hadern, rangeln, zanken)

- Im Englischen bezieht sich "wrangling" auf einen langen, schwierigen Prozess, oder auf einen Streif
- Es gibt zwei Hauptbestandteile des Wrangling
  + *Transformieren*: Sortieren oder Erstellen neuer Variablen (was wir heute tun werden)
  + *Aufr√§umen*: Umformung oder Strukturierung Ihrer Daten (dies werden wir in einigen Wochen tun)
- Sowohl das Aufr√§umen als auch das Transformieren von Daten erfordern das Paket `dplyr` aus dem `tidyverse`.
  + `dplyr` Funktionen werden oft als Verben bezeichnet, weil sie etwas *tun*

## `nycflights13`

- we will use the `flights.csv` dataset to explore the basic `dplyr` verbs
  + this dataset is originally from the `nycflights13` package, but I've saved it as a CSV

- die Daten enthalten Informationen √ºber Fl√ºge, die im Jahr 2013 von New York City aus gestartet sind
  + sie stammen vom Bureau of Transportation Statistics
  + um mehr dar√ºber zu erfahren, rufen Sie die Hilfeseite mit `?df_flights` auf


```{r}
#| eval: false
#| echo: false

df_flights <- nycflights13::flights
write_csv(df_flights, here::here("daten", "flights.csv"))
```

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-df_flights]: `nycflights13`
::: {#exm-df_flights .custom}
::: nonincremental
1. Ladet den Datensatz `flights.csv` und speichert ihn als `df_flights`.
    + Wie viele Beobachtungen sind vorhanden?
    + Wie viele Variablen gibt es?
2. den Datensatz untersuchen (z. B. `summary()`, `glimpse()`, usw.)

```{r}
#| eval: true
#| echo: false
#| results: hide

df_flights <- read_csv(here::here("daten", "flights.csv"))
head(df_flights)
summary(df_flights)
glimpse(df_flights)
```

:::
:::
:::


## `dplyr` Grundlagen

- heute lernen wir einige der wichtigsten `dplyr`-Verben (Funktionen) kennen, mit denen wir die meisten unserer Datenmanipulationsprobleme l√∂sen k√∂nnen
  + Ich verwende diese Verben mehrfach in wahrscheinlich jedem Analyseskript
- Die `dplyr`-Verben haben einige Dinge gemeinsam:
    1. das erste Argument ist immer ein Datenrahmen
    2. die folgenden Argumente beschreiben in der Regel die zu bearbeitenden Spalten, wobei der Variablenname (ohne Anf√ºhrungszeichen) verwendet wird
    3. die Ausgabe ist immer ein neuer Datenrahmen


## `dplyr` Grundlagen: Pipe

:::: columns
::: {.column width="60%"}
- Die Verben sind alle f√ºr eine Sache gut geeignet, so dass wir oft mehrere Verben auf einmal verwenden wollen.
  + Wir benutzen die Pipe, um dies zu tun (`%>%` oder `|>`)
  + Denkt daran, dass wir die Pipe als `(und) dann` lesen k√∂nnen
:::

::: {.content-hidden when-format="pdf"}
::: {.column width="40%"}
```{r echo = F, fig.env = "figure",out.width="60%", fig.align = "center", set.cap.width=T, fig.cap="Image source: [magrittr documentation](https://magrittr.tidyverse.org/reference/pipe.html#:~:text=The%20magrittr%20pipe%20operators%20use,to%20the%20left%2Dhand%20side.) (all rights reserved)"}
# larger image for html and revealjs
knitr::include_graphics(here::here("media/magrittr_badge.png"))
```
:::
:::
::::

::: {.content-visible when-format="pdf"}
```{r echo = F, fig.env = "figure",out.width="30%", fig.align = "center", set.cap.width=T, fig.cap="Image source: [magrittr documentation](https://magrittr.tidyverse.org/reference/pipe.html#:~:text=The%20magrittr%20pipe%20operators%20use,to%20the%20left%2Dhand%20side.) (all rights reserved)"}
# larger image for html and revealjs
knitr::include_graphics(here::here("media/magrittr_badge.png"))
```
:::

::: {.content-visible when-format="revealjs"}
## `dplyr` Grundlagen
:::

- im folgenden Code identifizieren
  + den Datenrahmen
  + "dplyr"-Verben
  + die Variablennamen
- Kannst du versuchen, herauszulesen (zu erraten), was der folgende Code macht?

```{r}
#| eval: false
df_flights %>% 
  filter(dest == "IAH") %>% 
  select(year, month, day) %>% 
  relocate(year, .after = day)
```

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Renderpr√ºfung!
::: nonincremental
Nehmt euch einen Moment Zeit, um euer Dokument zu rendern. Wird es gerendert?

K√∂nnte man das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::

:::

# Zeilen

- In aufger√§umten Daten stellen die Zeilen Beobachtungen dar.

- die wichtigsten Verben f√ºr Zeilen sind:
  + `filter()`: √§ndert, welche Zeilen vorhanden sind
  + `arrange()`: √§ndert die Reihenfolge der Zeilen
- Wir besprechen auch
  + `distinct()`: findet Zeilen mit unterschiedlichen Werten auf der Grundlage einer Variablen (Spalte)

## `filter()`

- √§ndert, welche Zeilen vorhanden sind, ohne ihre Reihenfolge zu √§ndern
- nimmt den Datenrahmen als erstes Argument
  + Die folgenden Argumente sind Bedingungen, die `TRUE` sein m√ºssen, damit die Zeile erhalten bleibt
  
::: {.content-visible when-format="revealjs"}
## `filter()` {.unlisted .unnumbered}
:::
  
- alle Fl√ºge zu finden, die mit mehr als 120 Minuten Versp√§tung abfliegen:

```{r}
#| output-location: fragment
df_flights %>% 
  filter(dep_delay > 120)
```

::: {.content-visible when-format="revealjs"}
## `filter()` {.unlisted .unnumbered}
:::

- wenn man die gefilterten Daten speichern will, ist es in der Regel ratsam, sie unter einem *neuen* Objektnamen zu speichern
  + wenn man nicht die vorgefilterte Version √ºberschreiben will, ist ein neuer Name notwendig

```{r}
df_delay_120 <- df_flights %>% 
  filter(dep_delay > 120)
```

::: {.content-visible when-format="revealjs"}
## Logical operators {.unlisted .unnumbered}
:::

::: callout-note

### Logical operators
::: nonincremental
- Symbole, die zur Beschreibung einer logischen Bedingung verwendet werden
  - `==` *ist identisch* (`1 == 1`)
  - `!=` *ist nicht identisch* (`1 != 2`)
  - `>` *ist gr√∂√üer als* (`2 > 1`)
  - `<` *ist kleiner als* (`1 < 2`)
- um Bedingungen zu kombinieren
  - `&` oder `,` *und auch* (f√ºr mehrere Bedingungen)
  - `|` *oder* (f√ºr mehrere Bedingungen)

- es gibt eine nette Abk√ºrzung f√ºr die Kombination von `==` und `|`: `%in%`
  + beh√§lt Zeilen, in denen die Variable gleich einem der Werte auf der rechten Seite ist

::: panel-tabset
### `==` and `|`
```{r}
df_flights %>% 
  filter(month == 1 | month == 2)
```

### `%in%`
```{r}
df_flights %>% 
  filter(month %in% c(1, 2))
```
:::
:::
:::

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-filter]: `filter()`
::: {#exm-filter .custom}
::: nonincremental
1. Filtert die Daten so, dass sie Zeilen von Ihrem Geburtstag enthalten.
2. Wie viele Fl√ºge sind 2013 an deinem Geburtstag von NYC abgeflogen?
:::
:::
:::

```{r}
#| eval: false
#| echo: false

# 1, 2
df_flights %>% 
  filter(month == 5,
         day == 7) %>% 
  count()
```


## `arrange()`

- √§ndert die Reihenfolge der Zeilen auf der Grundlage eines Wertes in einer oder mehreren Spalten
```{r}
#| output-location: fragment
df_flights %>% 
  arrange(arr_time)
```

::: {.content-visible when-format="revealjs"}
## `arrange()` {.unlisted .unnumbered}
:::

- wir k√∂nnen `desc()` innerhalb von `arrange()` hinzuf√ºgen, um eine absteigende Reihenfolge (von gro√ü nach klein) anstelle der standardm√§√üigen aufsteigenden Reihenfolge zu verwenden
  + `desc` ist die Abk√ºrzung f√ºr *descending* im Englischen (= absteigend)

```{r}
#| output-location: fragment
df_flights %>% 
  arrange(desc(dep_delay))
```

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-arrange]: `arrange()`
::: {#exm-arrange .custom}
::: nonincremental
1. Ordne die Daten nach Jahr, Monat, Tag und Abfahrtszeit (`dep_time`)
2. Filtere die Daten so, dass sie Beobachtungen aus deinem Geburtsmonat und dem Geburtsmonat, der 6 Monate nach deinem Geburtsmonat liegt, enthalten, *dann*
    - ordne die Daten nach Tag und absteigender Ankunftszeit (`arr_time`)
  
```{r}
#| eval: false
#| echo: false

df_flights %>% 
  filter(month %in% c(5,11)) %>% 
  arrange(day, desc(arr_time))
```
:::
:::
:::

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Renderpr√ºfung!
::: nonincremental
Nehmt euch einen Moment Zeit, um euer Dokument zu rendern. Wird es gerendert?

K√∂nnte man das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::

:::

# Spalten

- In Tidy Data stellen die Spalten Variablen dar

- die wichtigsten Verben f√ºr Spalten sind:
  + `rename()`: √§ndert die Namen der Spalten
  + `mutate()`: erzeugt neue Spalten, die von den vorhandenen Spalten abgeleitet werden
  + `select()`: √§ndert, welche Spalten vorhanden sind
  + `relocate()`: √§ndert die Position der Spalten

## `rename()`

- Mit `rename()` k√∂nnen wir den Namen von Spalten √§ndern
  + die Reihenfolge der Argumente ist `neuer_name` = `alter_name`
  
- Versuchen wir, einige der Variablennamen auf Deutsch zu √§ndern
  + Ich behalte die Variablennamen in Kleinbuchstaben, als Kodierungskonvention
  
```{r}
# single variable
fluege <- df_flights %>% rename(jahr = year)

# or multiple variables at once
fluege <- df_flights %>% 
  rename(jahr = year,
         monat = month,
         tag = day)
```

## `mutate()`

- `mutate()` erzeugt neue Spalten aus vorhandenen Spalten
  + z.B. k√∂nnen wir einfache Algebra mit den Werten in jeder Spalte durchf√ºhren

```{r}
#| output-location: fragment
df_flights %>% 
  mutate(
    gain = dep_delay - arr_delay,
  )
```

::: {.content-visible when-format="revealjs"}
## `mutate()` {.unlisted .unnumbered}
:::

- mit "mutate()" werden diese neuen Spalten auf der rechten Seite des Datensatzes hinzugef√ºgt
  + Das macht es schwierig zu sehen, was passiert.
- um zu kontrollieren, wo die neue Spalte hinzugef√ºgt wird, k√∂nnen wir `.before` oder `.after` verwenden

```{r}
#| output-location: fragment
df_flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    .after = day
  )
```

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Renderpr√ºfung!
::: nonincremental
Nehmt euch einen Moment Zeit, um euer Dokument zu rendern. Wird es gerendert?

K√∂nnte man das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::

:::

## Exercise

1. Erstelle eine neue Variable namens `Geschwindigkeit`, die gleich ist:
    - Entfernung" geteilt durch "air_time", multipliziert mit 60
    - erscheint vor `dep_time`
2. Rendert euer Dokument

```{r}
#| echo: false
#| eval: true
df_flights <- df_flights %>% 
  mutate(
    speed = distance / air_time * 60,
    .before = dep_time
  )
```


## `select()`

- `select()` fasst die Daten so zusammen, dass sie nur die gew√ºnschten Spalten enthalten

- Spalten nach Namen ausw√§hlen

```{r}
#| output-location: fragment
df_flights %>% 
  select(year, month, day)
```

::: {.content-visible when-format="revealjs"}
## `select()` {.unlisted .unnumbered}
:::

- alle Spalten zwischen `year` und `day` ausw√§hlen

```{r}
#| output-location: fragment
df_flights %>% 
  select(year:day)
```

::: {.content-visible when-format="revealjs"}
## `select()` {.unlisted .unnumbered}
:::

- alle Spalten au√üer denen von Jahr bis Tag ausw√§hlen (`!` wird als "nicht" gelesen)

```{r}
#| output-location: fragment
df_flights %>% 
  select(!year:day)
```

## `select()` helper functions

- einige Hilfsfunktionen, die das Leben bei der Arbeit mit `select()` erleichtern:
  + `starts_with("abc")`
  + `ends_with("xyz")`
  + `contains("ijk")`
  + `where(is.character)`

:::: columns

::: {.column width="50%"}
```{r}
#| output-location: fragment
df_flights %>% 
  select(starts_with("d"))
```
:::

::: {.column width="50%"}
```{r}
#| output-location: fragment
df_flights %>% 
  select(ends_with("ay"))
```
:::
::::

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-select]: `select()`
::: {#exm-select .custom}
::: nonincremental

1. Drucke die Spalten in `df_flights`, die mit "d" beginnen
2. Drucke die Spalten in `df_flights`, die "dep" enthalten
3. Drucke die Spalten in `df_flights`, die
    + mit mit "a" beginnen, und
    + mit "e" enden

:::
:::
:::
  
```{r}
#| echo: false
#| eval: false

# 1
df_flights %>%
  select(starts_with("d"))
# 2
df_flights %>%
  select(contains("dep"))
# 3
df_flights %>%
  select(starts_with("a"),
         ends_with("e"))
```


## `relocate()`

- `relocate()` verschiebt Variablen
  + standardm√§√üig werden sie nach vorne verschoben

```{r}
#| output-location: fragment
df_flights %>% relocate(speed)
```

::: {.content-visible when-format="revealjs"}
## `relocate()` {.unlisted .unnumbered}
:::

- aber wir k√∂nnen auch `.before` oder `.after` verwenden, um eine Variable zu platzieren

```{r}
#| output-location: fragment
df_flights %>% relocate(speed, .after = day)
```

# `dplyr` and `ggplot2`

- wir k√∂nnen einen Datensatz mit Hilfe der Verben "dplyr" √§ndern und diese √Ñnderungen dann in "ggplot2" einspeisen

- Was w√ºrde der folgende Code ergeben?

```{r}
#| output-location: column-fragment
df_flights %>% 
  # filter the data
  filter(dep_delay > 120,
         arr_delay < 120) %>% 
  # plot the filtered data
  ggplot(aes(x = fct_infreq(carrier))) +
  geom_bar() +
  theme_minimal()
```

- wichtig: wir k√∂nnen Pipes (` %>% `) f√ºr neue Verben/Funktionen verwenden
  + aber die Funktion `ggplot()` verwendet `+`, um neue *Ebenen* zur Darstellung hinzuzuf√ºgen
  
::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Renderpr√ºfung!
::: nonincremental
Nehmt euch einen Moment Zeit, um euer Dokument zu rendern. Wird es gerendert?

K√∂nnte man das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::

:::

## Exercises

- damit Ihr Quarto-Skript f√ºr diese Woche als abgeschlossen gilt, muss es zumindest die √úbungen aus `nettle_1999_climate.csv` enthalten (siehe unten)

### `flights.csv`

::: nonincremental

1. Drucke in einer einzigen Pipeline alle Fl√ºge aus, die jede der folgenden Bedingungen erf√ºllen:
    - Kam mit mehr als zwei Stunden Versp√§tung an, ist aber nicht zu sp√§t abgeflogen
    - Sie flogen nach Houston (`IAH` oder `HOU`)
    - Wurden von United Airlines (`UA`), American Airlines (`AA`) oder Delta (`DL`) durchgef√ºhrt
    - Sie sind im Sommer abgeflogen (Juli, August oder September)
    - kamen mehr als zwei Stunden zu sp√§t an, flogen aber nicht zu sp√§t ab

```{r}
#| eval: false
#| echo: false

df_flights %>%
  filter(arr_delay <= 120 & dep_delay <= 0,
         dest %in% c("IAH", "HOU"),
         carrier %in% c("UA", "DL", "AA"),
         month %in% c(7,8,9))
```


2. Sortiert `df_flights`, um die Fl√ºge mit den gr√∂√üten Abflugversp√§tungen zu finden

```{r}
#| eval: false
#| echo: false

df_flights %>% 
  arrange(dep_delay)
```

3. Welche Fl√ºge haben die weiteste Strecke zur√ºckgelegt? Welche Fl√ºge haben die geringste Entfernung zur√ºckgelegt?

```{r}
#| eval: false
#| echo: false

df_flights %>% 
  arrange(distance)

df_flights %>% 
  arrange(desc(distance))
```
:::

::: {.content-visible when-format="revealjs"}
## {.unlisted unnumbered}
:::

::: nonincremental
4. Speichert in einer einzigen Pipeline ein neues Objekt namens `df_fluege` und:
    + den Datensatz `flights.csv` erneut laden
    + Auswahl der Variablen `Jahr`, `Monat`, `Tag`, `dep_delay`, `arr_delay`, `carrier`
    + eine neue Variable `gain` erstellen, die `dep_delay` subtrahiert von `arr_delay` ist
      + und vor `dep_delay` eingef√ºgt wird
    + benennen Sie diese Variablen um, so dass sie deutsch sind

```{r}
df_fluege <- 
  read_csv(here::here("daten","flights.csv")) %>% 
  select(year,month,day,dep_delay,arr_delay,carrier) %>% 
  mutate(gewinn = dep_delay - arr_delay, .before = dep_delay) %>% 
  rename(jahr = year,
         monat = month) # etcetera
```
:::

### `nettle_1999_climate.csv`

::: nonincremental
5. Speichere den Datensatz `nettle_1999_climate.csv` als ein Objekt namens `df_nettle`
    + einen kurzen Blick auf den Datensatz werfen (z.B. `summary()`)

6. In einer einzigen Pipeline:
    + Erstellen eines neuen Objekts namens `fig_nettle`, das die folgenden Schritte enth√§lt:
+ nehmt `df_nettle`, *und dann* (d.h., benutzt eine `Pipeline`)
    + verwende die Funktion `clean_names` aus dem `janitor`-Paket, um die Namen zu bereinigen (siehe die Anmerkungen von letzter Woche), *und dann*
    + Umbenennen von `mgs` in `grow_seasons`, *und dann*
    + ein Streudiagramm erstellen, das `grow_seasons` auf der `x` Achse und `langs` auf der `y` Achse hat

```{r}
#| echo: false
#| eval: false

# 1
df_nettle <- read_csv(here::here("daten","nettle_1999_climate.csv"))

# 2
fig_nettle <- df_nettle %>% 
  janitor::clean_names() %>% 
  rename(grow_seasons = mgs) %>% 
  ggplot(aes(x = grow_seasons, y = langs, colour = population)) +
  geom_point()
```
:::

# Heutige Ziele üèÅ {.unnumbered .unlisted}

Heute haben wir gelernt...

- gelernt, wie man mit dem Paket `dplyr` aus dem `tidyverse` Daten verarbeiten kann ‚úÖ
- gelernt, wie man die `pipe` (` %>%`) verwendet, um das Ergebnis einer Funktion in eine andere Funktion einzuspeisen ‚úÖ
- Funktionen kennengelernt, die auf Zeilen operieren ‚úÖ
- Funktionen kennengelernt, die mit Spalten arbeiten ‚úÖ
- gelernt, wie man `dplyr`-Funktionen mit Plots von `ggplot2` kombiniert ‚úÖ

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.3.0.386 (Cherry Blossom).

```{r}
sessionInfo()
```