---
title: "Datenimport"
subtitle: "Einlesen von Datendateien"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 4 - Datenimport" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: data_import_DE_blatt.html
    include-after-body: custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
  revealjs: 
    output-file: data_import_DE_folien.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: true
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
  pdf:
    output-file: data_import_DE.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
bibliography: references/references.bib
csl: references/apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_data_import_EN.qmd")
```

# Wiederholung {.unnumbered .unlisted}

Letzte Woche haben wir...

- den Unterschied zwischen numerischen und kategorialen Datentypen gelernt
- haben wir unsere ersten Diagramme mit `ggplot2` erstellt
- gelernt, welche Diagramme f√ºr verschiedene Datentypen geeignet sind

# Heutige Ziele {.unnumbered .unlisted}

Heute werden wir...

- lernen, wie man einen neuen Datensatz in Augenschein nimmt
- lernen, wie man verschiedene Datentypen importiert
- lernen, wie man Daten von Hand eingibt
- einen neuen Datensatz visualisieren

## Lust auf mehr? {.unnumbered .unlisted}

- [Ch. 8](https://r4ds.hadley.nz/data-import.html) in @wickham_r_nodate
- [Ch. 4](https://psyteachr.github.io/ads-v2/04-data.html) in @nordmann_applied_2022

# Daten erforschen

- letzte Woche haben wir mit Daten aus dem R-Paket `palmerpenguings` gearbeitet
  + Daten aus Paketen sind ein guter Weg, um Data Science Tools zu lernen
+ aber ihr werdet irgendwann mit euren eigenen Daten arbeiten wollen
- Heute lernen wir die Grundlagen des Einlesens von Datendateien in R

## Pakete

:::: columns

::: {.column width="50%"}

```{r}
#| eval: false
# install new packages IN THE CONSOLE!
install.packages("pacman")
```

:::

::: {.column width="50%"}

```{r}
# load packages
pacman::p_load("tidyverse", # wrangling
               "janitor", # wrangling
               "here", # relative file paths
               "patchwork" # plot layout
               )
```

:::

::::


- wir werden mit dem Paket `pacman` beginnen
  - die Funktion `p_load()` nimmt Paketnamen als Argumente
  - sie pr√ºft dann, ob wir das Paket installiert haben
    + wenn ja, dann l√§dt sie das Paket
    + wenn nicht, wird das Paket installiert und geladen
- dies erspart uns, jedes Mal neue Pakete zu installieren

- wir haben jetzt `tidyverse` und `patchwork` geladen und die neuen Pakete `janitor` und `here` installiert und geladen

## Dateien

- Speichert die Dateien unter 'daten' in den Moodle-Materialien f√ºr diese Woche
- Speichert die Dateien im Ordner `daten` in eurem .RProj f√ºr diesen Kurs!


::: {.column width="100%"}
::: {.content-visible when-format="revealjs"}

```{r}
#| echo: false
#| out-width: "70%"
#| fig-cap: "'data' file path"
knitr::include_graphics(here::here("media/daten_ordner.jpeg"))
```
:::
:::

::: {.content-hidden when-format="revealjs"}
```{r echo = F, fig.env = "figure",out.width="90%", fig.align = "center", set.cap.width=T, fig.cap="'data' file path"}
knitr::include_graphics(here::here("media/daten_ordner.jpeg"))
```
:::


## Eingebaute Daten

- Lasst uns zun√§chst einige eingebaute Daten untersuchen: den `iris`-Datensatz
  + wie viele *Variablen* gibt es?
  + wie viele *Beobachtungen*?

:::: columns
::: {.column width="30%"}
```{r}
# load tidyverse
library(tidyverse)
# read-in iris dataset
data("iris")
```

- iris = Iris
- petal = Blumenblatt
- sepal = Kelchblatt
:::

::: {.column width="70%"}
```{r echo = F, fig.env = "figure",out.width="90%", fig.align = "center", set.cap.width=T, fig.cap=" [Image source:](https://www.analyticsvidhya.com/blog/2022/06/iris-flowers-classification-using-machine-learning/) Analytics Vidhya (all rights reserved)"}
knitr::include_graphics(here::here("media", "iris.png"))
```
:::
::::

## Einen Datensatz erforschen

- `view()`: Datensatz √∂ffnen
  + F√ºhrt dies nur **in der Konsole** aus! Euer Dokument wird nicht gerendert, wenn ihr es in eurem Skript habt
- die Funktion `head()` gibt die ersten 6 Zeilen der Daten aus

```{r}
# print dataset (first 6 rows)
head(iris)
```

### `glimpse()` {.smaller}

::: {.column width="100%"}
- EN: glimpse = DE: Einblick
- aus dem Paket `tibble`
- gibt eine seitliche Vorschau des Datenrahmens
:::

:::: columns
::: {.column width="60%"}
```{r}
glimpse(iris)
```
:::

::: {.column width="40%"}
```{r}
# print dataset (first 6 rows)
head(iris)
```
:::
:::: 

### `summary()`

- druckt eine Zusammenfassung f√ºr jede Variable
  + Minimum, Maximum, Mittelwert von numerischen Variablen
  + Anzahl der Beobachtungen pro Stufe einer kategorischen Variable

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-table1]: `table1`
::: {#exm-table1 .custom}
::: nonincremental
1.  Versuch, den eingebauten Datensatz `table1` zu laden
2.  Untersuche den Datensatz mit den Funktionen, die wir gerade gelernt haben
3.  Gibt es irgendetwas Komisches in der Zusammenfassung? Wie k√∂nnten wir das beheben?

```{r}
#| eval: false
#| echo: false

data(table1)
summary(table1) # population is in scientific notation

options(scipen=999)
summary(table1)
```

:::
:::
:::

# Daten importieren

- wir wollen normalerweise mit unseren *eigenen* Daten arbeiten, nicht mit eingebauten Spielzeugdaten
- wir konzentrieren uns nur auf *rechteckige* Daten (d. h. aufger√§umte Daten)
- Es gibt viele verschiedene Dateitypen, die Daten annehmen k√∂nnen, z. B. `.xlsx`, `.txt`, `.csv`, `.tsv`

- `csv` ist der am h√§ufigsten verwendete Dateityp: Kommagetrennte Werte (EN: `C`omma `S`eparated `V`alue)
  + Versucht, `.xlsx` zu vermeiden; wenn ihr einen Excel-Datensatz habt, versucht, ihn als `.csv` zu speichern, bevor ihr ihn in R lest

::: {.content-visible when-format="revealjs"}
# Daten importieren {.unlisted .unnumbered}
:::

- So sieht eine einfache CSV-Datei aus

```{r}
#| echo: false
#| output-location: fragment
#| message: false
#| comment: ""

read_lines(here::here("daten", "students.csv")) |> cat(sep = "\n")
```

- die erste Zeile (die "Kopfzeile") enth√§lt die Spaltennamen
- die folgenden Zeilen enthalten die Daten

- Wie viele Variablen gibt es? Wie viele Beobachtungen?

## `readr` Paket

- dieselben Daten k√∂nnen als Tabelle angezeigt werden, so wie wir es mit `penguins` und `iris` gemacht haben
  + aber zuerst m√ºssen wir die Daten *einlesen*
- das `readr` Paket (Teil von `tidyverse`) kann die meisten Datentypen einlesen


```{r}
#| echo: true
#| eval: false
#| message: false

read_csv(here::here("daten", "students.csv"))
```


::: {.content-hidden when-format="revealjs"}
```{r}
#| label: tbl-students-table2
#| echo: false
#| message: false
#| tbl-cap: Data from the students.csv file as a table.

read_csv(here::here("daten", "students.csv")) |>
  knitr::kable()
```
:::

::: {.content-visible when-format="revealjs"}
```{r}
#| label: tbl-students-table
#| echo: false
#| message: false
#| tbl-cap: Data from the students.csv file as a table.
library(kableExtra)

read_csv(here::here("daten", "students.csv")) |>
  knitr::kable() %>%
  kable_styling(font_size = 20)
```
:::


## `here` Paket

- Woher wei√ü R genau, wo der Ordner "Daten" zu finden ist?
- unser *Arbeitsverzeichnis* ist auf den Ort unseres RProjekts auf unserem Computer festgelegt
- Wann immer wir auf Daten in unserem RProjekt zugreifen wollen, sollten wir `here::here()` verwenden.
- um zu sehen, von wo aus `here()` startet, f√ºhrt `here()` aus

```{r}
#| output-location: fragment
here()
```

- dies wird auf allen unseren Rechnern anders aussehen
  + Was jedoch *gleich* sein sollte, ist unsere Ordnerstruktur innerhalb unserer Projekte (z. B. `daten/students.csv`).

::: {.content-visible when-format="revealjs"}
## `here` Paket {.unlisted .unnumbered}

```{r echo = F, fig.env = "figure",out.width="70%", fig.align = "center", set.cap.width=T, fig.cap=" [Image source: Allison Horst](https://allisonhorst.com/other-r-fun) (all rights reserved)"}
knitr::include_graphics(here::here("media", "Horst_here.png"))
```
:::

::: {.content-hidden when-format="revealjs"}
```{r echo = F, fig.env = "figure",out.width="90%", fig.align = "center", set.cap.width=T, fig.cap=" [Image source: Allison Horst](https://allisonhorst.com/other-r-fun) (all rights reserved)"}
knitr::include_graphics(here::here("media", "Horst_here.png"))
```
:::

::: {.content-visible when-format="revealjs"}
## `here` Paket {.unlisted .unnumbered}
:::

::: callout-note

### `here` Paket
::: nonincremental
Vor dem `here`-Paket mussten wir R explizit mitteilen, wo sich eine Datei auf unserem Computer befindet (z.B., `/Users/danielapalleschi/Documents/IdSL/Teaching/SoSe23/BA/ba_daten/daten/students.csv`), oder die Funktion `setwd()` (set Working Directory) benutzen, um R mitzuteilen, wo alle Dateien zu finden sind (z.B. `setwd(/Users/danielapalleschi/Documents/IdSL/Teaching/SoSe23/BA/ba_daten)`). Gl√ºcklicherweise brauchen wir diese absoluten Dateipfade oder `setwd()` nie zu verwenden!

Aus der [`here`-Paketdokumentation](https://here.r-lib.org/): 

> The goal of the here package is to enable easy file referencing in project-oriented workflows. In contrast to using `setwd()`, which is fragile and dependent on the way you organize your files, here uses the top-level directory of a project to easily build paths to files.

Das bedeutet, dass wir nun den ***gro√üen*** Vorteil haben, dass wir unseren Projektordner √ºberall hin verschieben k√∂nnen und unser Dateipfad immer noch relativ zu dem Ort ist, an den wir unseren Projektordner verschoben haben. Das bedeutet, dass das Projekt unabh√§ngig davon l√§uft, wo es sich auf eurem Computer befindet. Ihr k√∂nnt auch jemandem den Projektordner schicken, und alles sollte auf dessen Rechner laufen!

:::
:::


::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-students]: `table1`
::: {#exm-students .custom}
::: nonincremental
1.  Importiert den Datensatz `students.csv` und speichert ihn als Objekt mit dem Namen `df_students`.
    - `df_` ist die Abk√ºrzung f√ºr DataFrame; es ist eine gute Idee, ein Pr√§fix vor Objektnamen zu verwenden, damit wir wissen, was jedes Objekt enth√§lt.
2.  Beim Importieren von Daten mit `read_csv` werden einige Informationen in der Konsole ausgegeben. Was wird gedruckt?
2.  Untersucht den Datensatz mit den Funktionen, die wir gerade gelernt haben
3.  F√§llt Ihnen etwas Ungew√∂hnliches auf?
:::
:::
:::

```{r}
#| eval: false
#| echo: false

df_students <- read_csv(here::here("daten", "students.csv"))
head(df_students) # missing data points
```


## Fehlende Werte {.smaller}

- Die Datentransformation bezieht sich auf die "Korrektur" unserer Daten, wenn sie nicht "ordentlich" sind.
- in unserem `df_students` Datenrahmen habt ihr vielleicht einige `NA` oder `N/A` Werte bemerkt
  + `N/A` wurde als Text geschrieben und wird daher von R als solcher gelesen.
  + `NA` in R bezieht sich auf fehlende Daten (EN: `N`ot `A`vailable = DE:  "Nicht verf√ºgbar")
- letzte Woche haben wir einige Warnmeldungen gesehen, als wir unsere Streudiagramme erstellt haben
  + Diese Warnungen informierten uns √ºber fehlende Werte (`NA`s), die nicht geplottet wurden
- Echte fehlende Werte sind v√∂llig leer, so dass die Angabe `N/A` in unseren `df_students`-Daten nicht wirklich als fehlender Wert gelesen wird.
- Um dies zu beheben, k√∂nnen wir das Argument `na =` f√ºr die Funktion `read_csv()` verwenden
  + Dieses Argument teilt `read_csv()` mit, welche Werte mit fehlenden Werten gleichgesetzt werden sollen.

::: {.content-visible when-format="revealjs"}
## Fehlende Werte {.unlisted .unnumbered}
:::

```{r}
#| output-location: fragment

df_students <- read_csv(here::here("daten", "students.csv"),
                        na = "N/A")
head(df_students)
```

- jetzt wird der Wert, der vorher `N/A` war, als `NA` gelesen
  + aber was ist mit der leeren Zelle?
- Wir haben jetzt √ºberschrieben, dass `read_csv()` leere Zellen als `NA` liest.
  + Wie k√∂nnen wir `read_csv()` anweisen, *mehr als eine* Art von Eingabe als `NA` zu lesen?
  + d.h. wir wollen, dass es `""` *und* `"N/A"`x als `NA` liest

::: {.content-visible when-format="revealjs"}
## Fehlende Werte {.unlisted .unnumbered}
:::

```{r}
#| output-location: fragment

df_students <- read_csv(here::here("daten", "students.csv"),
                        na = c("N/A",""))
head(df_students)
```

## Spaltennamen {.smaller}

- Wenn wir `df_students` in der Konsole ausgeben, werden wir sehen, dass die ersten beiden Spaltennamen von Backticks umgeben sind (z.B. `` `Student ID` ``)
  + Das liegt daran, dass sie ein Leerzeichen enthalten, das syntaktisch nicht g√ºltig ist (Variablennamen m√ºssen mit einem Buchstaben beginnen und d√ºrfen keine Leer- oder Sonderzeichen enthalten).
- eine schnelle L√∂sung ist die Funktion `clean_names()` aus dem Paket `janitor`

```{r}
#| output-location: fragment
janitor::clean_names(df_students)
```

- Das sieht besser aus!
  - aber wenn wir jetzt `head(df_students)` ausf√ºhren, sehen wir dann die bereinigten Spaltennamen?

::: {.content-visible when-format="revealjs"}
## Spaltennamen {.unlisted .unnumbered}
:::

- Wenn wir ein Objekt durch eine Funktion √ºbergeben, wird das Objekt nicht "aktualisiert".
  + so m√ºssen wir das Objekt erneut zuweisen

```{r}
df_students <- janitor::clean_names(df_students)
```

- aber wir wissen oft, dass wir mehrere Funktionen (`read_csv()`, `clean_names()`) auf demselben Objekt ausf√ºhren wollen
  - k√∂nnen wir das mit Pipes tun

## Pipes {.smaller}

- Pipes werden am Ende eines Funktionsaufrufs gesetzt, wenn das Ergebnis dieser Funktion durch eine nachfolgende Funktion weitergegeben werden soll
  + sie k√∂nnen als "und dann..." gelesen werden

```{r}
#| output-location: fragment
read_csv(here::here("daten", "students.csv")) %>%
  head()
```

- Es gibt derzeit 2 Pipes, die in R verwendet werden k√∂nnen
    1. die `magrittr`-Paket-Pipe: `%>%`
    2. die neue native R-Pipe: `|>`
- Bis jetzt habe ich noch keinen gro√üen Unterschied zwischen den beiden entdeckt, aber im Moment bleibe ich bei `%>%`

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-pipes]: pipes
::: {#exm-pipes .custom}
::: nonincremental
1.    Ladet den `students.csv`-Datensatz erneut mit festen `NA`s *und dann*
        + Benutze eine Pipe, um `clean_names()` auf dem Datensatz aufzurufen, *und dann*
        + Ruft man die Funktion `head()` auf
2.    Ladet den Datensatz `students.csv` erneut mit festen `NA`s und speichert ihn als Objekt `df_students`, *und dann*
      + Verwendet eine Pipe, um `clean_names()` auf den Datensatz anzuwenden
4.    Warum sollte man nicht eine Pipe und die Funktion `head()` verwenden, wenn man den Datensatz als Objekt speichert?

```{r}
#| eval: false
#| echo: false

# 1
read_csv(here("daten", "students.csv"), na = c("","N/A")) %>%
  clean_names() %>%
  head()

# 2
df_students <- read_csv(here("daten", "students.csv"), na = c("","N/A")) %>%
  clean_names()

# 3: cause then it'll save the output of head(), i.e., just the first 6 rows
```

:::
:::
:::

## Andere Dateitypen

- Sobald wir mit `read_csv()` vertraut sind, sind die anderen Funktionen von `readr` einfach zu benutzen
  + man muss nur wissen, wann man welche benutzt
  
- `read_csv2()` liest Semikolon-getrennte Dateien
  + Diese verwenden `;` anstelle von `,` zur Trennung von Feldern und sind in L√§ndern √ºblich, die `,` als Dezimalzeichen verwenden
- `read_tsv()` liest Tabulator-getrennte Dateien
- `read_delim()` liest Dateien mit beliebigen Begrenzungszeichen ein
  + versucht, das Trennzeichen zu erraten
  + es sei denn, ihr gebt es mit dem Argument `delim =` an (z. B. `read_delim("students.csv", delim = ",")`)

::: {.content-visible when-format="revealjs"}
## Andere Dateitypen {.unlisted .unnumbered}
:::

Andere habe ich noch nicht gebraucht:

- `read_fwf()` liest Dateien mit fester Breite
- `read_table()` liest eine g√§ngige Variante von Dateien mit fester Breite, bei der die Spalten durch Leerzeichen getrennt sind
- `read_log()` liest Log-Dateien im Apache-Stil

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-filetypes]: filetypes
::: {#exm-filetypes .custom}
::: nonincremental
1.  Welche Funktion wird verwendet, um eine Datei zu lesen, deren Felder durch `|` getrennt sind?
2.  Welche Argumente haben `read_csv()` und `read_tsv()` gemeinsam?
3.  Wie w√ºrdet ihr einen Datensatz mit einem Semikolon als Begrenzungszeichen einlesen?
3.  Ladet den Datensatz `nettle_1999_climate.csv` ein
    + wie viele Variablen gibt es?
3.  Ladet den Datensatz `nettle_1999_climate2.csv` ein
    + Wie viele Variablen gibt es? Ist das richtig?
3.  Ladet den Datensatz `nettle_1999_climate3.csv` ein
    + wie viele Variablen sind vorhanden? Ist dies richtig?

```{r}
#| eval: false
#| echo: false

df_nettle <- read_csv(here("daten", "nettle_1999_climate.csv"))
df_nettle2 <- read_csv2(here("daten", "nettle_1999_climate2.csv"))
df_nettle3 <- read_tsv(here("daten", "nettle_1999_climate3.csv"))
```

:::
:::
:::

# Dateneingabe

- wenn wir kleine Datenmengen sammeln, m√∂chten wir sie vielleicht von Hand in R eingeben
  - Es gibt zwei n√ºtzliche Funktionen, die uns dabei helfen, gesammelte Daten zu nehmen und ein "Tibble" zu erstellen
- `tibble`s sind *moderne* Datenrahmen, macht euch noch keine Gedanken √ºber die Definition eines Tibbles

- Sammeln wir die Initialen, die K√∂rpergr√∂√üe (cm) und das Geburtsdatum (ttmm) von allen

```{r}
i <- "DP" # a "string"
h <- 171 # a number
m <- 05 # a number
d <- 07
```

## `tibble()`

```{r}
tibble(
  initial = i,
  height = h,
  month = "Mai",
  day = 7)
```

## `tribble()`

- es k√∂nnte einfacher sein, die Daten Zeile f√ºr Zeile einzugeben
  + dies ist mit einem *transponierten* Tibble (`Tribble`) m√∂glich

```{r}
tribble(
  ~initial, ~height, ~month, ~day,
  "DP", 171, 07, 05
)
```

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-tibble]: tibbles
::: {#exm-tibble .custom}
::: nonincremental
1.    Speichert das Tibble (d.h. den Datenrahmen) als das Objekt `df_wir`.
2.    Den Datensatz untersuchen (z.B. Zusammenfassungen drucken)
3.    Was kommt Ihnen seltsam vor?

```{r}
#| eval: true
#| echo: false

# first question
df_wir <- tribble(
  ~initial, ~height, ~month, ~ day,
  "DP", 171, 05, 07
)
summary(df_wir)
```

:::
:::
:::

# Arbeiten mit Variablen

- In einem Datenrahmen sind die Variablen in Spalten organisiert

## Variablentypen

- `readr` err√§t den Typ der Daten, die jede Spalte enth√§lt
  + Die wichtigsten Spaltentypen, die man kennen sollte, sind `numerisch` und `kategorisch` (= `factor`).
- `factor`s enthalten *Kategorien* oder *Gruppen* von Daten, k√∂nnen aber manchmal wie `numerische` Daten *aussehen*. 
  + Unsere Spalte `month` enth√§lt zum Beispiel Zahlen, aber sie kann auch den Namen jedes Monats enthalten.
  + Es ist sinnvoll, den Mittelwert einer `numerischen` Variable zu berechnen, aber nicht den eines `factor`s.
    + Es ist sinnvoll, den Mittelwert der K√∂rpergr√∂√üe zu berechnen, aber nicht den Mittelwert des Geburtsmonats.

```{r}
df_wir$month <- as_factor(df_wir$month)
```

## Indizierung

- manchmal wollen wir auf eine bestimmte Variable (Spalte) in einem Datenrahmen zugreifen
  + Bei Verwendung von Base R tun wir das mit `$`: `Datenrahmen$Variable`

```{r}
df_wir$height
```

- und wir k√∂nnen dies als Argument f√ºr eine Funktion verwenden
  + Versuche, die minimale und maximale H√∂he in unserer Gruppe zu finden.
  + die Summe (EN: `sum`) unserer H√∂hen berechnen

```{r}
#| echo: false
#| eval: false

min(df_wir$height)
max(df_wir$height)
```


::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-tibble]: tibbles
::: {#exm-tibble .custom}
::: nonincremental
1.    Umrechnung von `df_wir$month` in einen Faktor
3.    Berechne unsere mittlere H√∂he mit der Funktion `mean()` und der Indizierung
4.    Berechne die Summe unserer H√∂hen.

```{r}
#| eval: false
#| echo: false

# first question
df_wir <- tribble(
  ~initial, ~height, ~month, ~ day,
  "DP", 171, 05, 07
)
summary(df_wir)

mean(c(df_wir$height,df_wir$month))

c(df_wir$month,df_wir$day)
```

:::
:::
:::


## In Datei schreiben

- wir k√∂nnen unseren Datenrahmen auch speichern, so dass wir sp√§ter darauf zur√ºckkommen k√∂nnen mit `write_csv(object_name, "desired_filename.csv")`
  + oder, mit `here`:  `write_csv(object_name, here::here("ordner", "desired_filename.csv"))`
- Seid ***sehr vorsichtig***! Wenn ihr einen existierenden Dateinamen verwendet, k√∂nnt ihr einen bereits existierenden Datensatz √ºberschreiben

```{r}
write_csv(df_wir, file = here("daten", "wir.csv"))
```

# √úbungen

Hier findet ihr einige vertiefende √úbungen.

## Import/Export

::: nonincremental
1. Ladet den eingebauten `starwars`-Datensatz, der Informationen √ºber Star Wars Charaktere enth√§lt.
2. Exportiert die Daten als `csv` Datei mit dem Namen `starwars` in euren `daten` Ordner.
3. Importiere die `starwars.csv` Datei mit `read_csv()`.
:::

```{r}
#| eval: false
#| echo: false

data(starwars)
write_csv(starwars, here("daten","starwars.csv"))
starwars <- read_csv(here("daten", "starwars.csv"))
```

## Spaltentypen konvertieren

::: nonincremental
1. Konvertiere die folgenden Variablen in Faktoren:
    + `hair_color`
    + `skin_color`
    + `eye_color`
    + `sex`
    + `gender`
    + `homeworld`
    + `species`
:::

```{r}
#| eval: true
#| echo: false
#| results: hide
starwars$hair_color <- as_factor(starwars$hair_color)
starwars$skin_color <- as_factor(starwars$skin_color)
starwars$eye_color <- as_factor(starwars$eye_color)
starwars$sex <- as_factor(starwars$sex)
starwars$gender <- as_factor(starwars$gender)
starwars$homeworld <- as_factor(starwars$homeworld)
starwars$species <- as_factor(starwars$species)
spec(starwars)
```

## Plots

:::: columns

::: {.column width="60%"}

1. Erstellt die folgenden drei Diagramme und beschreibt kurz, was sie zeigen und welche Schlussfolgerungen daraus gezogen werden k√∂nnen.


2. Erstellt ein weiteres Diagramm eurer Wahl aus dem "Starwars"-Datensatz. F√ºgt sie in das Diagrammgitter ein (ihr m√ºsst die Syntax anpassen). Beschreibt was sie zeigt.

:::

::: {.column width="40%"}

```{r}
#| eval: true
#| echo: false
fig_sw_height <- ggplot(starwars, aes(height)) +
  geom_histogram(binwidth = 25, colour = "black", alpha = .3) +
  scale_x_continuous(breaks = seq(from = 50, to = 300, by = 25)) +
  labs(title = "Height (cm) distribution") +
  theme_classic()

fig_sw_height_mass <- ggplot(starwars, aes(height, mass)) +
  geom_point() +
  labs(title = "Mass (kg) by height (cm) distribution") +
  scale_x_continuous(breaks = seq(from = 0, to = 300, by = 50)) +
  scale_y_continuous(breaks = seq(from = 0, to = 2000, by = 100)) +
  coord_cartesian(xlim = c(0, 300)) +
  theme_minimal()

fig_sw_gender <- ggplot(starwars, aes(x = gender, fill = gender)) +
  geom_bar(show.legend = FALSE, colour = "black") +
  scale_x_discrete(name = "Gender of character", labels = (c("Masculine", "Feminine", "Missing"))) +
  scale_fill_brewer(palette = 2) +
  labs(title = "Gender of SW characters") +
  theme_bw()
```

::: {.content-hidden when-format="pdf"}
```{r}
#| fig-height: 6
#| fig-width: 6
#| fig-pos: centre
(fig_sw_height + fig_sw_gender) /
  fig_sw_height_mass +
  plot_layout(nrow = 2,  heights = c(.4,.6)) +
  plot_annotation(
    title = "Some plots using the `starwars` dataset",
    subtitle = "Each plot visualises different variables",
    tag_levels = "A")
```
:::

::: {.content-visible when-format="pdf"}
```{r}
#| fig-height: 5
(fig_sw_height + fig_sw_gender) /
  fig_sw_height_mass +
  plot_layout(nrow = 2,  heights = c(.4,.6)) +
  plot_annotation(
    title = "Some plots using the `starwars` dataset",
    subtitle = "Each plot visualises different variables",
    tag_levels = "A")
```
:::

:::

::::


# Heutige Ziele üèÅ {.unnumbered .unlisted}

Heute haben wir...

- gelernt, wie man einen neuen Datensatz in Augenschein nimmt ‚úÖ
- gelernt, wie man verschiedene Datentypen importiert ‚úÖ
- gelernt, wie man Daten von Hand eingibt ‚úÖ
- einen neuen Datensatz visualisiert ‚úÖ


# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.3.0.386 (Cherry Blossom).

```{r}
sessionInfo()
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::
